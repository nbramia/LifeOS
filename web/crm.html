<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>LifeOS CRM</title>
    <link rel="icon" type="image/svg+xml" href="/static/favicon.svg">
    <style>
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #0f3460;
            --text-primary: #eaeaea;
            --text-secondary: #a0a0a0;
            --text-muted: #6a6a8a;
            --accent: #e94560;
            --accent-hover: #ff6b6b;
            --border: #2a2a4e;
            --success: #4caf50;
            --warning: #ff9800;
            --error: #f44336;
            --people: #00bcd4;
            --people-hover: #26c6da;
            --sidebar-width: 320px;
            --header-height: 56px;
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --safe-left: env(safe-area-inset-left, 0px);
            --safe-right: env(safe-area-inset-right, 0px);
            --mobile-panel-transition: transform 0.3s ease;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            touch-action: manipulation;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            padding-top: var(--safe-top);
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 1rem;
            height: var(--header-height);
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .header-left h1 {
            font-size: 1.25rem;
            font-weight: 600;
        }

        .header-brand {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
            color: var(--text-primary);
            font-weight: 600;
            font-size: 1rem;
            padding: 0.375rem 0.5rem;
            border-radius: 6px;
            transition: background 0.2s;
        }

        .header-brand:hover {
            background: var(--bg-tertiary);
        }

        .header-nav {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            margin-left: 0.5rem;
            padding-left: 0.75rem;
            border-left: 1px solid var(--border);
        }

        .nav-link {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.375rem 0.75rem;
            border-radius: 6px;
            text-decoration: none;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .nav-link:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .nav-link.active {
            background: var(--accent);
            color: white;
        }

        .nav-link.me-link {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
        }

        .nav-link.me-link:hover {
            background: var(--people);
            color: white;
            border-color: var(--people);
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .stats-display {
            display: flex;
            gap: 1rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .stat-item .value {
            color: var(--text-primary);
            font-weight: 500;
        }

        /* Main layout */
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Left panel - People list */
        .people-list-panel {
            width: var(--sidebar-width);
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .search-bar {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .search-input {
            width: 100%;
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.875rem;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--people);
        }

        .search-input::placeholder {
            color: var(--text-muted);
        }

        .search-input-wrapper {
            position: relative;
            width: 100%;
        }

        .search-input-wrapper .search-input {
            padding-right: 2.5rem;
        }

        .search-clear-btn {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.25rem;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            line-height: 1;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .search-clear-btn:hover {
            color: var(--text-primary);
        }

        .search-input-wrapper:has(.search-input:not(:placeholder-shown)) .search-clear-btn {
            opacity: 1;
        }

        .filters {
            display: flex;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
        }

        .filter-chip {
            padding: 0.375rem 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 16px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-chip:hover {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .filter-chip.active {
            background: var(--people);
            border-color: var(--people);
            color: white;
        }

        .people-filter-dropdown {
            position: relative;
        }

        .people-filter-btn {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.375rem 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 16px;
            color: var(--text-primary);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .people-filter-btn:hover {
            background: var(--bg-primary);
            border-color: var(--people);
        }

        .people-filter-options {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 4px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.5rem;
            min-width: 160px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .people-filter-options.show {
            display: block;
        }

        .people-filter-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.375rem 0.5rem;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.8rem;
            white-space: nowrap;
        }

        .people-filter-option:hover {
            background: var(--bg-primary);
        }

        .people-filter-option input {
            margin: 0;
        }

        .people-filter-toggles {
            display: flex;
            gap: 0.5rem;
            padding: 0.25rem 0.5rem 0.5rem;
            border-bottom: 1px solid var(--border);
            margin-bottom: 0.25rem;
        }

        .filter-toggle-btn {
            flex: 1;
            padding: 0.25rem 0.5rem;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .filter-toggle-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border-color: var(--people);
        }

        /* Tag filter section styles */
        .tag-filter-section {
            padding: 0.25rem 0;
        }

        .tag-filter-section-label {
            font-size: 0.65rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 0.375rem 0.5rem 0.125rem;
            display: block;
        }

        /* Tag search input */
        .tag-search-input {
            width: calc(100% - 1rem);
            margin: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.75rem;
        }

        .tag-search-input:focus {
            outline: none;
            border-color: var(--people);
        }

        .tag-search-input::placeholder {
            color: var(--text-muted);
        }

        /* Bulk tag button */
        .bulk-tag-btn {
            padding: 0.375rem 0.625rem;
            background: #6366f1;
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            white-space: nowrap;
        }

        .bulk-tag-btn:hover {
            background: #5558e3;
        }

        /* Bulk tag modal */
        .bulk-tag-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .bulk-tag-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            width: 90%;
            max-width: 400px;
        }

        .bulk-tag-content h3 {
            margin: 0 0 1rem;
            font-size: 1.1rem;
        }

        .bulk-tag-input {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.9rem;
            margin-bottom: 0.75rem;
            box-sizing: border-box;
        }

        .bulk-tag-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .tag-suggestions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .tag-suggestion {
            padding: 0.25rem 0.5rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            color: var(--text-secondary);
        }

        .tag-suggestion:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--text-primary);
        }

        .bulk-tag-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }

        .bulk-tag-cancel {
            padding: 0.5rem 1rem;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
        }

        .bulk-tag-apply {
            padding: 0.5rem 1rem;
            background: var(--accent);
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
        }

        /* Family selector row (below title) */
        .family-selector-row {
            margin-bottom: 1.5rem;
            padding: 0 0.5rem;
        }

        /* Family selector container (inside detail-title, below name) */
        .family-selector-container {
            margin-top: 0.25rem;
        }

        .family-selector-container .family-member-selector {
            position: relative;
        }

        .family-selector-container .family-dropdown {
            position: fixed;
            z-index: 1000;
        }

        .people-list {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .person-card {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
            margin-bottom: 0.25rem;
        }

        .person-card:hover {
            background: var(--bg-tertiary);
        }

        .person-card.selected {
            background: var(--bg-tertiary);
            border: 1px solid var(--people);
        }

        .person-avatar {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--people) 0%, var(--people-hover) 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            flex-shrink: 0;
            background-size: cover;
            background-position: center;
        }
        .person-avatar.has-photo {
            color: transparent;
        }

        .person-info {
            flex: 1;
            min-width: 0;
        }

        .person-name {
            font-size: 0.875rem;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .person-company {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .person-strength {
            width: 32px;
            height: 4px;
            background: var(--bg-primary);
            border-radius: 2px;
            overflow: hidden;
        }

        .person-strength-bar {
            height: 100%;
            background: var(--people);
            border-radius: 2px;
            transition: width 0.3s;
        }

        .dunbar-badge {
            font-size: 0.625rem;
            font-weight: 600;
            min-width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: var(--bg-primary);
            color: var(--text-secondary);
            margin-left: 0.5rem;
        }

        .dunbar-badge.circle-0 { background: #e94560; color: white; }
        .dunbar-badge.circle-1 { background: #ff6b6b; color: white; }
        .dunbar-badge.circle-2 { background: #ffa502; color: white; }
        .dunbar-badge.circle-3 { background: #2ed573; color: white; }
        .dunbar-badge.circle-4 { background: #1e90ff; color: white; }
        .dunbar-badge.circle-5 { background: #5352ed; color: white; }
        .dunbar-badge.circle-6 { background: #747d8c; color: white; }

        .source-badges {
            display: flex;
            gap: 0.25rem;
        }

        .source-badge {
            font-size: 0.625rem;
            padding: 0.125rem 0.25rem;
            background: var(--bg-primary);
            border-radius: 4px;
        }

        /* Multi-select checkbox */
        .person-checkbox {
            width: 18px;
            height: 18px;
            border: 2px solid var(--border);
            border-radius: 4px;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.2s;
        }

        .person-checkbox:hover {
            border-color: var(--people);
        }

        .person-checkbox.checked {
            background: var(--people);
            border-color: var(--people);
        }

        .person-checkbox.checked::after {
            content: 'âœ“';
            color: white;
            font-size: 0.75rem;
            font-weight: bold;
        }

        /* Merge toolbar */
        .merge-toolbar {
            display: none;
            padding: 0.5rem 0.75rem;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .merge-toolbar.visible {
            display: flex;
        }

        .merge-toolbar-info {
            font-size: 0.75rem;
            color: var(--text-primary);
            white-space: nowrap;
        }

        .merge-toolbar-info strong {
            color: var(--people);
        }

        .merge-toolbar-actions {
            display: flex;
            gap: 0.375rem;
            flex-wrap: wrap;
            margin-left: auto;
        }

        .merge-btn {
            padding: 0.375rem 0.625rem;
            background: var(--people);
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
            white-space: nowrap;
        }

        .merge-btn:hover {
            background: var(--people-hover);
        }

        .merge-btn.hide-btn {
            background: #e85d75;
        }

        .merge-btn.hide-btn:hover {
            background: #d64a63;
        }

        .clear-selection-btn {
            padding: 0.375rem 0.625rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .clear-selection-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: var(--text-secondary);
        }

        /* Cleanup modal */
        .cleanup-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .cleanup-modal.visible {
            display: flex;
        }

        .cleanup-modal-content {
            background: var(--bg-secondary);
            border-radius: 12px;
            max-width: 700px;
            width: 95%;
            max-height: 85vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .cleanup-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border);
        }

        .cleanup-modal-title {
            font-size: 1.25rem;
            font-weight: 600;
        }

        .cleanup-close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
        }

        .cleanup-close-btn:hover {
            color: var(--text-primary);
        }

        .cleanup-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            padding: 0 1rem;
        }

        .cleanup-tab {
            padding: 0.75rem 1rem;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 0.875rem;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .cleanup-tab:hover {
            color: var(--text-primary);
        }

        .cleanup-tab.active {
            color: var(--people);
            border-bottom-color: var(--people);
        }

        .cleanup-tab-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 18px;
            height: 18px;
            padding: 0 5px;
            background: var(--accent);
            color: white;
            font-size: 0.7rem;
            font-weight: 600;
            border-radius: 9px;
            margin-left: 0.5rem;
        }

        .cleanup-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .cleanup-item {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            border: 1px solid var(--border);
        }

        .cleanup-item-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.75rem;
        }

        .cleanup-item-names {
            flex: 1;
        }

        .cleanup-item-name {
            font-weight: 500;
            font-size: 0.95rem;
        }

        .cleanup-item-vs {
            color: var(--text-muted);
            font-size: 0.75rem;
            margin: 0.25rem 0;
        }

        .cleanup-item-name-secondary {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .cleanup-confidence {
            display: inline-flex;
            align-items: center;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .cleanup-confidence.high {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
        }

        .cleanup-confidence.medium {
            background: rgba(255, 152, 0, 0.2);
            color: #ff9800;
        }

        .cleanup-confidence.low {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }

        .cleanup-item-reason {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
        }

        .cleanup-item-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .cleanup-action-btn {
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--bg-secondary);
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .cleanup-action-btn:hover {
            border-color: var(--people);
            color: var(--text-primary);
        }

        .cleanup-action-btn.primary {
            background: var(--people);
            border-color: var(--people);
            color: white;
        }

        .cleanup-action-btn.primary:hover {
            background: var(--people-hover);
        }

        .cleanup-action-btn.danger {
            border-color: var(--error);
            color: var(--error);
        }

        .cleanup-action-btn.danger:hover {
            background: var(--error);
            color: white;
        }

        .cleanup-merge-search {
            margin-top: 0.75rem;
            padding: 0.75rem;
            background: var(--bg-primary);
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .cleanup-merge-input {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 0.875rem;
        }

        .cleanup-merge-input:focus {
            outline: none;
            border-color: var(--people);
        }

        .cleanup-merge-results {
            margin-top: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .cleanup-merge-result {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .cleanup-merge-result:hover {
            background: var(--bg-hover);
        }

        .cleanup-merge-result-name {
            font-weight: 500;
            color: var(--text-primary);
        }

        .cleanup-merge-result-meta {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .cleanup-empty {
            text-align: center;
            padding: 3rem;
            color: var(--text-muted);
        }

        .cleanup-empty-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .cleanup-loading {
            text-align: center;
            padding: 2rem;
            color: var(--text-secondary);
        }

        .cleanup-nav-btn {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.375rem 0.75rem;
            border-radius: 6px;
            text-decoration: none;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-secondary);
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.2s;
        }

        .cleanup-nav-btn:hover {
            background: var(--warning);
            color: white;
            border-color: var(--warning);
        }

        .cleanup-nav-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 18px;
            height: 18px;
            padding: 0 5px;
            background: var(--warning);
            color: white;
            font-size: 0.7rem;
            font-weight: 600;
            border-radius: 9px;
        }

        /* Split modal */
        .split-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .split-modal.visible {
            display: flex;
        }

        .split-modal-content {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .split-modal-header {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .split-modal-section {
            margin-bottom: 1rem;
        }

        .split-modal-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .split-source-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border);
            border-radius: 8px;
        }

        .split-source-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.15s;
        }

        .split-source-item:last-child {
            border-bottom: none;
        }

        .split-source-item:hover {
            background: var(--bg-tertiary);
        }

        .split-source-item.selected {
            background: rgba(0, 188, 212, 0.1);
        }

        .split-source-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .split-source-badge {
            display: inline-block;
            padding: 0.125rem 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            font-size: 0.75rem;
            text-transform: uppercase;
        }

        .split-source-info {
            flex: 1;
            min-width: 0;
        }

        .split-source-name {
            font-size: 0.875rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .split-source-meta {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .split-target-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }

        .split-target-options {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .split-target-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .split-target-option:hover {
            background: var(--bg-tertiary);
        }

        .split-target-option.selected {
            background: rgba(0, 188, 212, 0.1);
        }

        .split-person-search {
            margin-top: 0.5rem;
            padding: 0.5rem;
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.875rem;
        }

        .split-person-results {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 0.5rem;
        }

        .split-person-result {
            padding: 0.5rem;
            cursor: pointer;
            border-radius: 6px;
            font-size: 0.875rem;
        }

        .split-person-result:hover {
            background: var(--bg-tertiary);
        }

        .split-person-result.selected {
            background: rgba(0, 188, 212, 0.2);
        }

        .split-new-name-input {
            margin-top: 0.5rem;
            padding: 0.5rem;
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.875rem;
        }

        .split-modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            margin-top: 1.5rem;
        }

        .split-cancel-btn {
            padding: 0.5rem 1rem;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
        }

        .split-confirm-btn {
            padding: 0.5rem 1rem;
            background: var(--people);
            border: none;
            border-radius: 6px;
            color: var(--bg-primary);
            font-weight: 600;
            cursor: pointer;
        }

        .split-confirm-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .split-btn {
            padding: 0.25rem 0.5rem;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .split-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* Merge modal */
        .merge-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .merge-modal.visible {
            display: flex;
        }

        .merge-modal-content {
            background: var(--bg-secondary);
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .merge-modal-header {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .merge-modal-section {
            margin-bottom: 1.5rem;
        }

        .merge-modal-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .merge-primary-select {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .merge-person-option {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .merge-person-option:hover {
            border-color: var(--border);
        }

        .merge-person-option.selected {
            border-color: var(--people);
            background: rgba(0, 188, 212, 0.1);
        }

        .merge-person-option .person-avatar {
            width: 32px;
            height: 32px;
            font-size: 0.75rem;
        }

        .merge-person-details {
            flex: 1;
        }

        .merge-person-name {
            font-weight: 500;
            font-size: 0.875rem;
        }

        .merge-person-meta {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .merge-modal-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
            margin-top: 1.5rem;
        }

        .merge-cancel-btn {
            padding: 0.625rem 1.25rem;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.875rem;
            cursor: pointer;
        }

        .merge-confirm-btn {
            padding: 0.625rem 1.25rem;
            background: var(--people);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
        }

        .merge-confirm-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Right panel - Person detail */
        .detail-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0; /* Allow flex child to scroll */
            background: var(--bg-primary);
        }

        #detailContent {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0; /* Allow flex child to scroll */
        }

        #detailContent[style*="display: flex"] {
            flex-direction: column;
        }

        .detail-empty {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            color: var(--text-muted);
        }

        .detail-empty-icon {
            font-size: 3rem;
            opacity: 0.5;
        }

        .detail-header {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
        }

        /* Header indicators (strength ring + dunbar circle) */
        .header-indicators {
            display: flex;
            align-items: center;
            gap: 1.25rem;
            margin-left: auto;
            padding-left: 1rem;
        }

        .header-strength,
        .header-dunbar {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
        }

        .header-strength-ring {
            position: relative;
            width: 44px;
            height: 44px;
        }

        .header-strength-ring svg {
            transform: rotate(-90deg);
        }

        .header-strength-ring .strength-ring-bg {
            fill: none;
            stroke: var(--bg-tertiary);
            stroke-width: 4;
        }

        .header-strength-ring .strength-ring-fill {
            fill: none;
            stroke: var(--people);
            stroke-width: 4;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.6s ease;
        }

        .header-strength-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.8rem;
            font-weight: 700;
            color: var(--text-primary);
            font-family: ui-monospace, 'SF Mono', Menlo, monospace;
        }

        .header-dunbar-circle {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            font-weight: 700;
            color: white;
            font-family: ui-monospace, 'SF Mono', Menlo, monospace;
        }

        .header-dunbar-circle.circle-0 { background: #e94560; }
        .header-dunbar-circle.circle-1 { background: #ff6b6b; }
        .header-dunbar-circle.circle-2 { background: #ffa502; }
        .header-dunbar-circle.circle-3 { background: #2ed573; }
        .header-dunbar-circle.circle-4 { background: #1e90ff; }
        .header-dunbar-circle.circle-5 { background: #5352ed; }
        .header-dunbar-circle.circle-6 { background: #747d8c; }
        .header-dunbar-circle.circle-7 { background: #747d8c; }

        .header-indicator-label {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Hide header indicators in graph/timeline mode */
        .graph-mode .header-indicators,
        .timeline-mode .header-indicators {
            display: none;
        }

        /* Compact header for graph/timeline mode */
        .graph-mode .detail-header,
        .timeline-mode .detail-header {
            padding: 0.75rem 1.5rem;
            align-items: center;
        }

        .graph-mode .detail-avatar,
        .timeline-mode .detail-avatar {
            width: 40px;
            height: 40px;
            font-size: 1rem;
        }

        .graph-mode .detail-company,
        .graph-mode .detail-contact-quick,
        .graph-mode .detail-tags,
        .graph-mode .detail-actions,
        .timeline-mode .detail-company,
        .timeline-mode .detail-contact-quick,
        .timeline-mode .detail-tags,
        .timeline-mode .detail-actions {
            display: none;
        }

        .graph-mode .detail-name,
        .timeline-mode .detail-name {
            font-size: 1.1rem;
            margin-bottom: 0;
        }

        .graph-mode .detail-content,
        .timeline-mode .detail-content {
            padding: 0.5rem;
        }

        .graph-mode #tabGraph {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        /* Mobile details drawer - hidden on desktop */
        .mobile-details-drawer {
            display: none;
        }

        .detail-avatar {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, var(--people) 0%, var(--people-hover) 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: 600;
            color: white;
            flex-shrink: 0;
            background-size: cover;
            background-position: center;
        }
        .detail-avatar.has-photo {
            color: transparent;
        }

        .detail-title {
            flex: 1;
        }

        .detail-name {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .detail-company {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .detail-contact-quick {
            display: flex;
            gap: 0.75rem;
            margin-top: 0.5rem;
        }

        .detail-contact-link {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.375rem 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.75rem;
            transition: all 0.2s;
        }

        .detail-contact-link:hover {
            background: var(--people);
            border-color: var(--people);
            color: white;
        }

        .detail-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.375rem;
            margin-top: 0.5rem;
        }

        .detail-tag-chip {
            padding: 0.25rem 0.625rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 12px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
        }

        .detail-tag-chip .remove-tag {
            cursor: pointer;
            color: var(--text-muted);
            font-size: 0.875rem;
            line-height: 1;
        }

        .detail-tag-chip .remove-tag:hover {
            color: var(--error);
        }

        .detail-birthday-chip {
            padding: 0.25rem 0.625rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--people);
            border-radius: 12px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
        }

        .detail-birthday-chip .remove-birthday {
            cursor: pointer;
            color: var(--text-muted);
            font-size: 0.875rem;
            line-height: 1;
        }

        .detail-birthday-chip .remove-birthday:hover {
            color: var(--error);
        }

        .detail-tag-add {
            padding: 0.25rem 0.625rem;
            background: transparent;
            border: 1px dashed var(--border);
            border-radius: 12px;
            font-size: 0.75rem;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.2s;
        }

        .detail-tag-add:hover {
            border-color: var(--people);
            color: var(--people);
        }

        .detail-hide-btn {
            padding: 0.25rem 0.5rem;
            background: transparent;
            border: none;
            font-size: 0.7rem;
            color: var(--text-muted);
            cursor: pointer;
            opacity: 0.5;
            transition: all 0.2s;
        }

        .detail-hide-btn:hover {
            opacity: 1;
            color: var(--error);
        }

        .detail-actions {
            display: flex;
            gap: 0.5rem;
        }

        .detail-strength-container {
            text-align: right;
        }

        .detail-strength-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 0.25rem;
        }

        .detail-strength-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--people);
        }

        /* Tabs */
        .detail-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            padding: 0 1rem;
        }

        .tab {
            padding: 0.75rem 1rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab:hover {
            color: var(--text-primary);
        }

        .tab.active {
            color: var(--people);
            border-bottom-color: var(--people);
        }

        .detail-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 1.5rem;
        }

        /* Overview tab */
        .info-section {
            margin-bottom: 1.5rem;
        }

        .info-section-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.75rem;
        }

        /* Relationship strength breakdown */
        .strength-breakdown {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }

        .strength-bar-main {
            width: 100%;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .strength-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--people) 0%, var(--people-hover) 100%);
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        .strength-components {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.75rem;
        }

        .strength-component {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .strength-component-icon {
            font-size: 1rem;
        }

        .strength-component-info {
            flex: 1;
            min-width: 0;
        }

        .strength-component-label {
            font-size: 0.625rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        .strength-component-value {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Hero Stats Row - Compact inline stats */
        .hero-stats {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.875rem 1rem;
            background: linear-gradient(135deg, rgba(22, 33, 62, 0.6) 0%, rgba(15, 52, 96, 0.4) 100%);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .hero-stat {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.3rem 0.625rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 16px;
            font-size: 0.8125rem;
            transition: all 0.2s ease;
            cursor: default;
        }

        .hero-stat:hover {
            background: rgba(0, 188, 212, 0.15);
        }

        .hero-stat-clickable {
            cursor: pointer;
        }

        .hero-stat-clickable:hover {
            background: rgba(0, 188, 212, 0.25);
            transform: translateY(-1px);
        }

        .hero-stat-icon {
            font-size: 0.8125rem;
            opacity: 0.9;
        }

        .hero-stat-value {
            font-family: ui-monospace, 'SF Mono', Menlo, monospace;
            font-weight: 600;
            color: var(--people);
        }

        .hero-stat-label {
            color: var(--text-secondary);
            font-size: 0.75rem;
        }

        .hero-stat-divider {
            width: 1px;
            height: 18px;
            background: var(--border);
            margin: 0 0.125rem;
        }

        /* Strength ring in hero stats */
        .hero-strength {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: auto;
            padding-left: 0.5rem;
        }

        .strength-ring {
            position: relative;
            width: 32px;
            height: 32px;
        }

        .strength-ring svg {
            transform: rotate(-90deg);
        }

        .strength-ring-bg {
            fill: none;
            stroke: var(--bg-tertiary);
            stroke-width: 3;
        }

        .strength-ring-fill {
            fill: none;
            stroke: var(--people);
            stroke-width: 3;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.5s ease;
        }

        .strength-ring-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: ui-monospace, 'SF Mono', Menlo, monospace;
            font-size: 0.5625rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .hero-strength-label {
            font-size: 0.625rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        /* Dunbar circle in hero stats */
        .hero-dunbar {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding-left: 0.75rem;
            border-left: 1px solid var(--border);
            margin-left: 0.5rem;
        }

        .dunbar-circle-indicator {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 700;
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .dunbar-circle-indicator.circle-0 { background: #e94560; }
        .dunbar-circle-indicator.circle-1 { background: #ff6b6b; }
        .dunbar-circle-indicator.circle-2 { background: #ffa502; }
        .dunbar-circle-indicator.circle-3 { background: #2ed573; }
        .dunbar-circle-indicator.circle-4 { background: #1e90ff; }
        .dunbar-circle-indicator.circle-5 { background: #5352ed; }
        .dunbar-circle-indicator.circle-6 { background: #747d8c; }

        .hero-dunbar-label {
            font-size: 0.625rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        /* Legacy stats cards - hidden by default, kept for backwards compatibility */
        .stats-cards {
            display: none;
        }

        .stat-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            transition: all 0.2s;
        }

        .stat-card:hover {
            background: var(--bg-tertiary);
            transform: translateY(-2px);
        }

        .stat-card-icon {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }

        .stat-card-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--people);
            margin-bottom: 0.25rem;
        }

        .stat-card-label {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* Heat map calendar - GitHub contribution style */
        .heatmap-container {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            overflow-x: auto;
        }

        .heatmap-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .heatmap-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: #ffffff;
        }

        .heatmap-legend {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.625rem;
            color: #ffffff;
        }

        .heatmap-years-select {
            padding: 2px 4px;
            font-size: 0.625rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            cursor: pointer;
            margin-left: 8px;
        }

        .heatmap-years-select:focus {
            outline: none;
            border-color: var(--people);
        }

        .heatmap-legend-item {
            width: 10px;
            height: 10px;
            border-radius: 2px;
        }

        .heatmap-scroll-wrapper {
            overflow-x: auto;
            overflow-y: hidden;
        }

        .heatmap-inner {
            min-width: fit-content;
            padding-right: 1rem;
        }

        .heatmap-months {
            display: flex;
            margin-bottom: 4px;
            font-size: 0.625rem;
            color: var(--text-muted);
            padding-left: 0;
            justify-content: space-between;
            padding-right: 1rem;
        }

        .heatmap-month-label {
            text-align: left;
            white-space: nowrap;
            overflow: visible;
            flex: 1;
            min-width: 2.5em;
        }

        .heatmap-body {
            display: flex;
        }

        .heatmap-weekdays {
            display: none; /* Hide weekday labels for cleaner full-width look */
        }

        .heatmap-weekday {
            height: 10px;
            line-height: 10px;
            width: 24px;
            text-align: right;
        }

        .heatmap-weekday:nth-child(even) {
            visibility: hidden;
        }

        .heatmap-grid {
            display: flex;
            flex: 1;
            justify-content: space-between;
            padding-right: 1rem;
        }

        .heatmap-week {
            display: flex;
            flex-direction: column;
            flex: 1;
            gap: 2px;
        }

        .heatmap-day {
            aspect-ratio: 1;
            flex: 1;
            min-height: 8px;
            max-height: 14px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.15s;
            margin: 0 1px;
        }

        .heatmap-day:hover {
            transform: scale(1.3);
            z-index: 10;
        }

        .heatmap-day[data-level="0"] { background: var(--bg-tertiary); }
        .heatmap-day[data-level="1"] { background: rgba(0, 188, 212, 0.25); }
        .heatmap-day[data-level="2"] { background: rgba(0, 188, 212, 0.45); }
        .heatmap-day[data-level="3"] { background: rgba(0, 188, 212, 0.65); }
        .heatmap-day[data-level="4"] { background: rgba(0, 188, 212, 0.85); }
        .heatmap-day[data-level="5"] { background: var(--people); }

        /* Floating tooltip */
        .heatmap-tooltip {
            position: fixed;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.625rem 0.75rem;
            font-size: 0.75rem;
            color: var(--text-primary);
            pointer-events: none;
            z-index: 1000;
            white-space: nowrap;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 0.15s;
        }

        .heatmap-tooltip.visible {
            opacity: 1;
        }

        .heatmap-tooltip-date {
            font-weight: 600;
            margin-bottom: 0.375rem;
            color: var(--text-primary);
        }

        .heatmap-tooltip-item {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            margin-bottom: 0.125rem;
            color: var(--text-secondary);
        }

        .heatmap-tooltip-total {
            margin-top: 0.375rem;
            padding-top: 0.375rem;
            border-top: 1px solid var(--border);
            font-weight: 600;
            color: var(--people);
        }

        /* Volume Chart Styles */
        .volume-chart-container {
            margin-top: 1.5rem;
            padding: 0.75rem 0;
            background: var(--bg-secondary);
            border-radius: 0.5rem;
        }

        .volume-chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding: 0 0.5rem;
        }

        .volume-chart-title {
            font-size: 0.875rem;
            font-weight: 500;
            color: #ffffff;
        }

        /* Chart Loading States */
        .chart-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            min-height: 80px;
            color: var(--text-muted);
            font-size: 0.875rem;
        }

        .chart-loading-spinner {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border);
            border-top-color: var(--people);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .volume-chart-canvas {
            width: 100%;
            height: 120px;
            display: block;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 0.75rem;
        }

        .info-item {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .info-label {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .info-value {
            font-size: 0.875rem;
            color: var(--text-primary);
        }

        .info-value a {
            color: var(--people);
            text-decoration: none;
        }

        .info-value a:hover {
            text-decoration: underline;
        }

        .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .tag {
            padding: 0.25rem 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .notes-area {
            width: 100%;
            min-height: 100px;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.875rem;
            resize: vertical;
        }

        .notes-area:focus {
            outline: none;
            border-color: var(--people);
        }

        .notes-save-btn {
            padding: 0.25rem 0.75rem;
            font-size: 0.75rem;
            background: var(--people);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .notes-save-btn:hover {
            opacity: 0.9;
        }

        .notes-save-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Two-column content grid for Overview tab */
        .overview-content-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        @media (max-width: 900px) {
            .overview-content-grid {
                grid-template-columns: 1fr;
            }
        }

        .overview-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
        }

        .overview-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .overview-panel-title {
            font-size: 0.6875rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Contact info compact styling */
        .contact-grid-compact {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .contact-row {
            display: flex;
            align-items: flex-start;
            gap: 0.625rem;
        }

        .contact-icon-box {
            flex-shrink: 0;
            width: 26px;
            height: 26px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 0.75rem;
        }

        .contact-values {
            flex: 1;
            min-width: 0;
        }

        .contact-value-link {
            font-size: 0.8125rem;
            color: var(--people);
            text-decoration: none;
            display: block;
            padding: 0.0625rem 0;
            transition: color 0.2s;
            word-break: break-all;
        }

        .contact-value-link:hover {
            color: var(--people-hover);
        }

        .contact-meta-row {
            display: flex;
            gap: 1.5rem;
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }

        .contact-meta-item {
            display: flex;
            flex-direction: column;
            gap: 0.125rem;
        }

        .contact-meta-label {
            font-size: 0.5625rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .contact-meta-value {
            font-size: 0.8125rem;
            color: var(--text-secondary);
        }

        /* Notes panel collapsed state */
        .notes-panel-compact {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
        }

        .notes-panel-compact .notes-area {
            min-height: 70px;
            margin-top: 0.5rem;
            background: rgba(0, 0, 0, 0.15);
        }

        /* Source entities footer (collapsed by default) */
        .source-entities-footer {
            background: rgba(0, 0, 0, 0.1);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            margin-top: 0.5rem;
        }

        .source-entities-toggle-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.625rem 1rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .source-entities-toggle-bar:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        .source-entities-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .source-entities-label {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .source-entities-count-badge {
            font-family: ui-monospace, 'SF Mono', Menlo, monospace;
            font-size: 0.6875rem;
            color: var(--text-secondary);
            padding: 0.125rem 0.375rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
        }

        .source-entities-chevron {
            color: var(--text-muted);
            font-size: 0.5rem;
            transition: transform 0.2s;
        }

        .source-entities-footer.expanded .source-entities-chevron {
            transform: rotate(180deg);
        }

        .source-entities-expanded-content {
            display: none;
            padding: 0 1rem 1rem;
        }

        .source-entities-footer.expanded .source-entities-expanded-content {
            display: block;
        }

        /* Timeline tab */
        .timeline-filters {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 1rem;
        }

        .timeline-count {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-primary);
            background: var(--bg-tertiary);
            padding: 0.25rem 0.6rem;
            border-radius: 12px;
            min-width: 2rem;
            text-align: center;
        }

        .timeline-count.has-more::after {
            content: '+';
            color: var(--text-muted);
        }

        .timeline-date-range {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-left: auto;
        }

        .timeline-date-range label {
            color: var(--text-muted);
        }

        .timeline-date-range input[type="date"] {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            color: var(--text-primary);
            color-scheme: dark;
        }

        .timeline-date-range input[type="date"]:focus {
            outline: none;
            border-color: var(--people);
        }

        .timeline-date-range button {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
        }

        .timeline-date-range button:hover {
            border-color: var(--people);
            color: var(--people);
        }

        .timeline-filter-chip {
            padding: 0.375rem 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 16px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
        }

        .timeline-filter-chip:hover {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .timeline-filter-chip.active {
            background: var(--people);
            border-color: var(--people);
            color: white;
        }

        .timeline {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .timeline-date-filter {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.625rem 0.875rem;
            background: rgba(0, 188, 212, 0.1);
            border: 1px solid rgba(0, 188, 212, 0.3);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            font-size: 0.8125rem;
            color: var(--people);
        }

        .timeline-date-filter button {
            background: transparent;
            border: 1px solid var(--people);
            color: var(--people);
            padding: 0.25rem 0.625rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
        }

        .timeline-date-filter button:hover {
            background: var(--people);
            color: white;
        }

        .timeline-item {
            display: flex;
            gap: 0.75rem;
            padding: 0.75rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            transition: all 0.2s;
        }

        .timeline-item:hover {
            background: var(--bg-tertiary);
            border-color: var(--people);
        }

        .timeline-badge {
            width: 32px;
            height: 32px;
            background: var(--bg-tertiary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            flex-shrink: 0;
        }

        .timeline-content {
            flex: 1;
            min-width: 0;
        }

        .timeline-title {
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .timeline-title a {
            color: var(--text-primary);
            text-decoration: none;
        }

        .timeline-title a:hover {
            color: var(--people);
            text-decoration: underline;
        }

        .timeline-snippet {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .timeline-meta {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .timeline-source-badge {
            display: inline-block;
            padding: 0.125rem 0.375rem;
            background: var(--bg-primary);
            border-radius: 4px;
            font-size: 0.625rem;
            margin-left: 0.5rem;
        }

        /* Photo groups in timeline */
        .photo-group-header {
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .photo-group-toggle {
            font-size: 0.75rem;
            color: var(--text-muted);
            transition: transform 0.2s;
        }
        .photo-group-details {
            margin-top: 0.75rem;
            padding-left: 1rem;
            border-left: 2px solid var(--border);
        }
        .photo-card {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding: 0.75rem 0;
            border-bottom: 1px solid var(--border);
        }
        .photo-card:last-child {
            border-bottom: none;
        }
        .photo-thumbnail {
            width: 50%;
            max-width: 400px;
            max-height: 400px;
            object-fit: contain;
            border-radius: 6px;
            background: var(--bg-secondary);
            cursor: pointer;
        }
        .photo-thumbnail:hover {
            opacity: 0.9;
        }
        .photo-thumbnail-placeholder {
            width: 100%;
            height: 150px;
            border-radius: 6px;
            background: var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            font-size: 3rem;
        }
        .photo-thumbnail-placeholder.icloud-photo {
            cursor: pointer;
            background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(59, 130, 246, 0.1) 100%);
            border: 1px dashed rgba(59, 130, 246, 0.3);
        }
        .photo-thumbnail-placeholder.icloud-photo:hover {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(59, 130, 246, 0.2) 100%);
            border-color: rgba(59, 130, 246, 0.5);
        }
        .photo-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .photo-time {
            color: var(--text-muted);
            font-size: 0.8rem;
        }
        .photo-open-btn {
            color: var(--people);
            text-decoration: none;
            font-size: 0.8rem;
        }
        .photo-open-btn:hover {
            text-decoration: underline;
        }

        /* Graph visualization */
        .graph-controls {
            display: flex;
            flex-direction: column;
            gap: 0;
            padding: 0;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 1rem;
            overflow: visible;
        }

        .graph-controls-primary {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem;
            flex-wrap: nowrap;
        }

        .graph-controls-expansion {
            display: none;
            align-items: center;
            gap: 1rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            flex-wrap: wrap;
        }

        .graph-refresh-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            font-size: 2.2rem;
            display: flex;
            align-items: center;
            margin-left: auto;
            line-height: 1;
        }

        .graph-refresh-btn:hover {
            color: var(--text-primary);
        }

        .graph-controls-expansion.visible {
            display: flex;
        }

        .graph-expand-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .graph-expand-btn:hover {
            color: var(--text-primary);
        }

        .graph-expand-btn .expand-arrow {
            transition: transform 0.2s;
        }

        .graph-expand-btn.expanded .expand-arrow {
            transform: rotate(180deg);
        }

        .graph-btn {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background 0.2s;
        }

        .graph-btn:hover {
            background: var(--people);
        }

        .graph-slider-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-left: 1rem;
        }

        .graph-slider-container input[type="range"] {
            width: 120px;
            cursor: pointer;
            accent-color: var(--people);
        }

        .graph-slider-container span {
            min-width: 35px;
            color: var(--text-primary);
        }

        .graph-layout-tuning {
            position: relative;
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            margin-left: auto;
        }

        .tuning-toggle {
            padding: 0.25rem 0.5rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 0.75rem;
            cursor: pointer;
        }

        .tuning-toggle:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .tuning-sliders {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            flex-direction: column;
            gap: 0.35rem;
            padding: 0.5rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin-top: 0.25rem;
            z-index: 200;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .tuning-sliders.visible {
            display: flex;
        }

        .tuning-slider {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        .tuning-slider label {
            min-width: 70px;
        }

        .tuning-slider input[type="range"] {
            width: 80px;
            cursor: pointer;
            accent-color: var(--people);
        }

        .tuning-slider span {
            min-width: 35px;
            color: var(--text-primary);
            font-size: 0.65rem;
        }

        .graph-degree-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-left: 1rem;
        }

        .graph-degree-toggle select {
            padding: 0.25rem 0.5rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.875rem;
            cursor: pointer;
        }

        .graph-degree-toggle select:focus {
            outline: none;
            border-color: var(--people);
        }

        .graph-source-filter {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-left: 1rem;
            position: relative;
        }

        .source-filter-dropdown {
            position: relative;
        }

        .source-filter-btn {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.25rem 0.5rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.875rem;
            cursor: pointer;
        }

        .source-filter-btn:hover {
            border-color: var(--people);
        }

        .dropdown-arrow {
            font-size: 0.6rem;
            color: var(--text-secondary);
        }

        .source-filter-options {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 0.5rem;
            margin-top: 0.25rem;
            z-index: 200;
            min-width: 160px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .source-filter-options.visible {
            display: block;
        }

        .source-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.3rem 0.5rem;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .source-option:hover {
            background: var(--bg-secondary);
        }

        .source-option input {
            cursor: pointer;
        }

        .source-icon {
            font-size: 0.9rem;
        }

        .category-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .graph-category-filter,
        .graph-dunbar-filter {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .category-filter-dropdown,
        .dunbar-filter-dropdown {
            position: relative;
        }

        .graph-node-sizing {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .node-sizing-toggle {
            display: flex;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid var(--border);
        }

        .node-sizing-toggle .sizing-option {
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.15s;
        }

        .node-sizing-toggle .sizing-option:hover {
            color: var(--text-primary);
        }

        .node-sizing-toggle .sizing-option.active {
            background: var(--people);
            color: white;
        }

        .edge-panel-section-title {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-top: 0.75rem;
            margin-bottom: 0.25rem;
            border-top: 1px solid var(--border);
            padding-top: 0.5rem;
        }

        .graph-wrapper {
            position: relative;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .graph-container {
            width: 100%;
            flex: 1;
            min-height: 400px;
            background: var(--bg-secondary);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        .graph-container svg {
            width: 100%;
            height: 100%;
        }

        .graph-node {
            cursor: pointer;
        }

        .graph-node circle {
            stroke: var(--bg-primary);
            stroke-width: 2px;
            transition: r 0.2s;
        }

        .graph-node:hover circle {
            stroke: var(--people);
            stroke-width: 3px;
        }

        .graph-node.selected circle {
            stroke: var(--accent);
            stroke-width: 4px;
            filter: drop-shadow(0 0 6px var(--accent));
        }

        /* Node selected via panel (single-click) - distinct from navigation selection */
        .graph-node.panel-selected circle {
            stroke: var(--people);
            stroke-width: 4px;
            filter: drop-shadow(0 0 6px var(--people));
        }

        .graph-node text {
            fill: var(--text-primary);
            font-size: 10px;
            text-anchor: middle;
            pointer-events: none;
        }

        /* Degree-based node styling */
        .graph-node.degree-0 text {
            font-size: 12px;
            font-weight: 600;
        }

        .graph-node.degree-2 text {
            font-size: 9px;
            fill: var(--text-secondary);
        }

        .graph-link {
            /* Base styles - actual stroke/opacity set dynamically based on weight */
            stroke-linecap: round;
            cursor: pointer;
            transition: stroke-width 0.15s, stroke-opacity 0.15s, stroke 0.15s;
        }

        .graph-link:hover {
            stroke-opacity: 1 !important;
            stroke-width: 4px !important;
        }

        .graph-link.selected {
            stroke: #ff6b6b !important;
            stroke-opacity: 1 !important;
            stroke-width: 4px !important;
        }

        .graph-tooltip {
            position: absolute;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            font-size: 0.75rem;
            color: var(--text-primary);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
        }

        .graph-tooltip.visible {
            opacity: 1;
        }

        .edge-panel {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            width: 280px;
            background: rgba(26, 26, 46, 0.95);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            z-index: 101;
            display: none;
        }

        .edge-panel.visible {
            display: block;
        }

        .edge-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.75rem;
        }

        .edge-panel-title {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .edge-panel-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0;
            line-height: 1;
        }

        .edge-panel-close:hover {
            color: var(--text-primary);
        }

        .edge-panel-header-actions {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .edge-panel-copy {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.9rem;
            padding: 0;
            line-height: 1;
            transition: color 0.15s;
        }

        .edge-panel-copy:hover {
            color: var(--text-primary);
        }

        .edge-panel-copy.copied {
            color: var(--accent);
        }

        .edge-panel-people {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
            font-size: 0.85rem;
        }

        .edge-panel-person {
            color: var(--people);
            cursor: pointer;
        }

        .edge-panel-person:hover {
            text-decoration: underline;
        }

        .edge-panel-connector {
            color: var(--text-secondary);
        }

        .edge-panel-stat {
            display: flex;
            justify-content: space-between;
            padding: 0.4rem 0;
            border-bottom: 1px solid var(--border);
            font-size: 0.8rem;
        }

        .edge-panel-stat:last-child {
            border-bottom: none;
        }

        /* Clickable interaction stats in node panel */
        .edge-panel-stat.clickable-stat {
            cursor: pointer;
            transition: background 0.15s;
            margin: 0 -0.5rem;
            padding: 0.4rem 0.5rem;
            border-radius: 4px;
        }

        .edge-panel-stat.clickable-stat:hover {
            background: var(--bg-secondary);
        }

        .edge-panel-stat.clickable-stat .edge-panel-stat-value {
            color: var(--people);
        }

        .edge-panel-stat-label {
            color: var(--text-secondary);
        }

        .edge-panel-stat-value {
            color: var(--text-primary);
            font-weight: 500;
        }

        .edge-panel-contexts {
            margin-top: 0.75rem;
        }

        .edge-panel-contexts-title {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.4rem;
        }

        .edge-panel-context-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
        }

        .edge-panel-context-tag {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
        }

        /* Node Panel (person details on single-click) */
        .node-panel {
            /* Inherits from .edge-panel, additional styles below */
        }

        .node-panel-name {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
        }

        .node-panel-category {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: capitalize;
            margin-bottom: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }

        .node-panel-goto-btn {
            width: 100%;
            margin-top: 1rem;
            padding: 0.6rem 1rem;
            background: var(--accent-primary);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: background 0.2s;
        }

        .node-panel-goto-btn:hover {
            background: var(--accent-secondary);
        }

        .graph-legend {
            position: absolute;
            bottom: 0.5rem;
            right: 0.5rem;
            background: rgba(26, 26, 46, 0.9);
            border-radius: 6px;
            padding: 0.5rem;
            font-size: 0.75rem;
        }

        .graph-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }

        .graph-legend-item:last-child {
            margin-bottom: 0;
        }

        .graph-legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        /* Graph legend mode toggle */
        .graph-legend-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding-bottom: 0.5rem;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
            font-size: 0.65rem;
        }

        .graph-legend-toggle-label {
            color: var(--text-muted);
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .graph-legend-toggle-label:hover {
            background: var(--bg-secondary);
        }

        .graph-legend-toggle-label.active {
            color: var(--text-primary);
            background: var(--bg-tertiary);
            font-weight: 500;
        }

        .graph-legend-items {
            display: flex;
            flex-direction: column;
        }

        /* Source entities section */
        .source-entities-section {
            border-top: 1px solid var(--border);
            margin-top: 1rem;
            padding-top: 1rem;
        }

        .source-entities-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.75rem;
        }

        .source-entities-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .source-entities-toggle {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .source-entities-list {
            display: none;
        }

        .source-entities-list.expanded {
            display: block;
        }

        .source-entity-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            font-size: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            margin-bottom: 0.25rem;
        }

        .source-entity-badge {
            font-size: 0.875rem;
        }

        .source-entity-info {
            flex: 1;
            min-width: 0;
        }

        .source-entity-name {
            color: var(--text-primary);
        }

        .source-entity-meta {
            color: var(--text-muted);
        }

        .source-entity-status {
            padding: 0.125rem 0.375rem;
            border-radius: 4px;
            font-size: 0.625rem;
            text-transform: uppercase;
        }

        .source-entity-status.confirmed {
            background: var(--success);
            color: white;
        }

        .source-entity-status.auto {
            background: var(--warning);
            color: white;
        }

        /* Button styles */
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--people);
            color: white;
        }

        .btn-primary:hover {
            background: var(--people-hover);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--bg-primary);
        }

        /* Loading state */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            color: var(--text-muted);
        }

        .loading::after {
            content: '';
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-top-color: var(--people);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-left: 0.5rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Empty state */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            color: var(--text-muted);
            text-align: center;
        }

        .empty-state-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            opacity: 0.5;
        }

        /* Quick Facts section */
        .quick-facts-section {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }

        .quick-facts-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .quick-facts-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .extract-facts-btn {
            padding: 0.375rem 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.375rem;
        }

        .extract-facts-btn:hover {
            background: var(--people);
            border-color: var(--people);
            color: white;
        }

        .extract-facts-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .extract-facts-btn.extracting::after {
            content: '';
            width: 12px;
            height: 12px;
            border: 2px solid var(--border);
            border-top-color: var(--people);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .facts-categories {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .facts-category {
            display: flex;
            flex-direction: column;
            gap: 0.375rem;
        }

        .facts-category-header {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .facts-category-icon {
            font-size: 0.875rem;
        }

        .facts-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .fact-item {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            padding: 0.375rem 0;
            font-size: 0.8rem;
            color: var(--text-primary);
            position: relative;
            border-radius: 4px;
            transition: background 0.15s;
        }

        .fact-item:hover {
            background: var(--bg-tertiary);
        }

        .fact-item.unconfirmed {
            opacity: 0.85;
        }

        .fact-bullet {
            flex-shrink: 0;
            margin-top: 0.1rem;
            font-size: 1.2em;
            font-weight: bold;
        }

        .fact-bullet.unconfirmed {
            color: goldenrod;
        }

        .fact-bullet.confirmed {
            color: var(--success);
        }

        .fact-content {
            flex: 1;
            min-width: 0;
        }

        .fact-text {
            color: var(--text-primary);
            line-height: 1.4;
        }

        .fact-source {
            color: var(--text-muted);
            font-size: 0.7rem;
            margin-left: 0.25rem;
            cursor: help;
            position: relative;
        }

        .fact-source:hover {
            color: var(--people);
        }

        .fact-source-tooltip {
            display: none;
            position: absolute;
            bottom: 100%;
            left: 0;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 0.5rem;
            font-size: 0.7rem;
            white-space: nowrap;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .fact-source:hover .fact-source-tooltip {
            display: block;
        }

        .fact-actions {
            display: none;
            gap: 0.25rem;
            flex-shrink: 0;
        }

        .fact-item:hover .fact-actions {
            display: flex;
        }

        .fact-action-btn {
            background: none;
            border: none;
            padding: 0.125rem;
            cursor: pointer;
            font-size: 0.7rem;
            color: var(--text-muted);
            opacity: 0.6;
            transition: opacity 0.15s, color 0.15s;
        }

        .fact-action-btn:hover {
            opacity: 1;
        }

        .fact-action-btn.confirm:hover {
            color: var(--success);
        }

        .fact-action-btn.delete:hover {
            color: var(--error);
        }

        .facts-empty {
            font-size: 0.75rem;
            color: var(--text-muted);
            padding: 0.5rem 0;
        }

        /* Fact source quote - shown on hover */
        .fact-quote {
            display: none;
            margin-top: 0.375rem;
            padding: 0.5rem;
            background: var(--bg-primary);
            border-left: 2px solid var(--people);
            border-radius: 0 4px 4px 0;
            font-size: 0.7rem;
            color: var(--text-secondary);
            font-style: italic;
            line-height: 1.4;
        }

        .fact-item:hover .fact-quote {
            display: block;
        }

        .fact-quote::before {
            content: '"';
            color: var(--people);
            font-size: 0.875rem;
        }

        .fact-quote::after {
            content: '"';
            color: var(--people);
            font-size: 0.875rem;
        }

        /* Clickable source link */
        .fact-source-link {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            color: var(--people);
            text-decoration: none;
            font-size: 0.65rem;
            padding: 0.125rem 0.375rem;
            background: rgba(0, 188, 212, 0.1);
            border-radius: 3px;
            transition: all 0.15s;
            margin-left: 0.375rem;
        }

        .fact-source-link:hover {
            background: rgba(0, 188, 212, 0.2);
            color: var(--people-hover);
        }

        .fact-source-link-icon {
            font-size: 0.625rem;
        }

        /* Confidence indicator */
        .fact-confidence {
            font-size: 0.625rem;
            color: var(--text-muted);
            margin-left: 0.25rem;
        }

        .fact-confidence.high {
            color: var(--success);
        }

        .fact-confidence.medium {
            color: var(--warning);
        }

        /* Me Dashboard Widgets */
        .me-dashboard {
            display: none;
        }

        .me-dashboard.visible {
            display: block;
        }

        /* Family Dashboard */
        .family-dashboard {
            display: none;
        }

        .family-dashboard.visible {
            display: block;
            padding-bottom: 2rem;
        }

        /* Ensure scrolling works when family dashboard is visible */
        .detail-content:has(.family-dashboard.visible) {
            overflow-y: auto;
            min-height: 0;
        }

        .family-member-selector-row {
            margin-bottom: 1.5rem;
        }

        .family-member-selector {
            position: relative;
        }

        .family-selector-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            color: var(--text-primary);
            font-size: 0.875rem;
            cursor: pointer;
            min-width: 200px;
            justify-content: space-between;
        }

        .family-selector-btn:hover {
            background: var(--bg-tertiary);
        }

        .family-selector-arrow {
            font-size: 0.625rem;
            color: var(--text-muted);
        }

        .family-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 0.25rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            min-width: 280px;
            max-height: 400px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 100;
        }

        .family-dropdown-actions {
            display: flex;
            gap: 0.5rem;
            padding: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .family-action-btn {
            flex: 1;
            padding: 0.375rem 0.5rem;
            font-size: 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            color: var(--text-secondary);
            cursor: pointer;
        }

        .family-action-btn:hover {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .family-dropdown-list {
            max-height: 320px;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .family-member-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            border-radius: 0.25rem;
            cursor: pointer;
        }

        .family-member-option:hover {
            background: var(--bg-tertiary);
        }

        .family-member-option input[type="checkbox"] {
            width: 1rem;
            height: 1rem;
            accent-color: var(--people);
        }

        .family-member-name {
            flex: 1;
            font-size: 0.875rem;
            color: var(--text-primary);
        }

        .family-member-strength {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* ================================================
           FAMILY INSIGHTS VISUALIZATIONS
           ================================================ */

        .family-insights-section {
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border);
        }

        .family-insights-title {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 1.25rem;
            letter-spacing: -0.01em;
        }

        .family-insights-row {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .family-insights-row:has(.full-width) {
            grid-template-columns: 1fr;
        }

        .family-insight-card {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(22, 33, 62, 0.8) 100%);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.25rem;
            position: relative;
            overflow: hidden;
        }

        .family-insight-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--accent) 0%, var(--people) 100%);
            opacity: 0.6;
        }

        .family-insight-card.full-width {
            grid-column: 1 / -1;
        }

        /* Allow tooltips to overflow on channel mix card */
        .family-insight-card.channel-mix-card {
            overflow: visible;
        }

        .insight-card-header {
            margin-bottom: 1rem;
            display: flex;
            flex-wrap: wrap;
            align-items: baseline;
            gap: 0.5rem;
        }

        .insight-card-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-right: auto;
        }

        .insight-card-subtitle {
            font-size: 0.7rem;
            color: var(--text-muted);
            width: 100%;
            order: 3;
        }

        .insight-period-select {
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            border: 1px solid var(--border);
            background: var(--bg-secondary);
            color: var(--text-primary);
            cursor: pointer;
            order: 2;
        }

        .insight-period-select:hover {
            border-color: var(--accent);
        }

        .insight-period-select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(0, 188, 212, 0.2);
            font-weight: 400;
        }

        .insight-loading {
            color: var(--text-muted);
            font-size: 0.8rem;
            padding: 2rem;
            text-align: center;
        }

        /* Days Since Contact Card */
        .days-since-grid {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .days-since-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.625rem 0.75rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .days-since-item:hover {
            transform: translateX(4px);
            box-shadow: -2px 0 0 var(--accent);
        }

        .days-since-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: 600;
            flex-shrink: 0;
        }

        .days-since-info {
            flex: 1;
            min-width: 0;
        }

        .days-since-name {
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .days-since-expected {
            font-size: 0.65rem;
            color: var(--text-muted);
        }

        .days-since-badge {
            padding: 0.25rem 0.625rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            min-width: 50px;
            text-align: center;
        }

        .days-since-badge.on-track {
            background: rgba(76, 175, 80, 0.2);
            color: #81c784;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .days-since-badge.warning {
            background: rgba(255, 152, 0, 0.2);
            color: #ffb74d;
            border: 1px solid rgba(255, 152, 0, 0.3);
        }

        .days-since-badge.overdue {
            background: rgba(233, 69, 96, 0.2);
            color: #e57373;
            border: 1px solid rgba(233, 69, 96, 0.3);
        }

        .days-since-badge.recent {
            background: rgba(0, 188, 212, 0.2);
            color: #4dd0e1;
            border: 1px solid rgba(0, 188, 212, 0.3);
        }

        /* Streak Tracker Card */
        .streak-grid {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .streak-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.625rem 0.75rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .streak-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: 600;
            flex-shrink: 0;
        }

        .streak-info {
            flex: 1;
            min-width: 0;
        }

        .streak-name {
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .streak-visual {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            margin-top: 0.25rem;
        }

        .streak-flame {
            font-size: 0.75rem;
        }

        .streak-days {
            display: flex;
            gap: 2px;
        }

        .streak-day {
            width: 8px;
            height: 8px;
            border-radius: 2px;
            background: var(--bg-primary);
        }

        .streak-day.active {
            background: linear-gradient(135deg, #ff6b6b 0%, #e94560 100%);
            box-shadow: 0 0 4px rgba(233, 69, 96, 0.4);
        }

        .streak-count {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
            min-width: 40px;
            text-align: right;
        }

        .streak-count.hot {
            color: #ff6b6b;
            text-shadow: 0 0 8px rgba(255, 107, 107, 0.4);
        }

        .streak-count.warm {
            color: #ffb74d;
        }

        .streak-count.cold {
            color: var(--text-muted);
        }

        /* Channel Mix Card */
        .channel-mix-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .channel-mix-item {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .channel-mix-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .channel-mix-name {
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .channel-mix-total {
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .channel-mix-bar {
            display: flex;
            height: 28px;
            border-radius: 6px;
            /* overflow: hidden removed to allow tooltips to appear above */
            background: var(--bg-primary);
        }

        .channel-segment {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 0;
            transition: all 0.2s ease;
            cursor: default;
            position: relative;
        }

        .channel-segment:hover {
            filter: brightness(1.15);
        }

        .channel-segment-tooltip {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s ease;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            color: var(--text-primary);
        }

        .channel-segment:hover .channel-segment-tooltip {
            opacity: 1;
        }

        .channel-segment-label {
            font-size: 0.65rem;
            color: white;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 0 0.375rem;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        /* Channel colors - vibrant, distinctive palette */
        .channel-imessage { background: linear-gradient(135deg, #34c759 0%, #30d158 100%); }
        .channel-whatsapp { background: linear-gradient(135deg, #25d366 0%, #128c7e 100%); }
        .channel-gmail { background: linear-gradient(135deg, #ea4335 0%, #c5221f 100%); }
        .channel-calendar { background: linear-gradient(135deg, #5856d6 0%, #7c3aed 100%); }
        .channel-phone { background: linear-gradient(135deg, #ff9500 0%, #ff6b00 100%); }
        .channel-slack { background: linear-gradient(135deg, #e01e5a 0%, #d91a52 100%); }
        .channel-vault { background: linear-gradient(135deg, #00bcd4 0%, #0097a7 100%); }
        .channel-granola { background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); }
        .channel-linkedin { background: linear-gradient(135deg, #0077b5 0%, #005582 100%); }
        .channel-photos { background: linear-gradient(135deg, #e040fb 0%, #aa00ff 100%); }
        .channel-other { background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); }

        /* Channel Mix Legend */
        .channel-legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.75rem;
            margin-top: 0.5rem;
            padding-top: 0.75rem;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }

        .channel-legend-item {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .channel-legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 3px;
        }

        /* Communication Gaps Card */
        .gaps-timeline-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .gaps-person-section {
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.15);
            border-radius: 8px;
        }

        .gaps-person-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.75rem;
        }

        .gaps-person-name {
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .gaps-person-stats {
            font-size: 0.65rem;
            color: var(--text-muted);
        }

        .gaps-timeline {
            position: relative;
            height: 32px;
            background: var(--bg-primary);
            border-radius: 4px;
            /* overflow: hidden removed to allow tooltips to appear above */
        }

        .gaps-bar-fill {
            position: absolute;
            top: 0;
            bottom: 0;
            background: rgba(0, 188, 212, 0.3);
        }

        .gap-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            background: linear-gradient(180deg, rgba(233, 69, 96, 0.6) 0%, rgba(233, 69, 96, 0.3) 100%);
            border-left: 2px solid var(--accent);
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .gap-marker:hover {
            background: linear-gradient(180deg, rgba(233, 69, 96, 0.8) 0%, rgba(233, 69, 96, 0.5) 100%);
        }

        .gap-marker-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            font-size: 0.7rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s ease;
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .gap-marker:hover .gap-marker-tooltip {
            opacity: 1;
        }

        .gaps-timeline-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 0.25rem;
            font-size: 0.6rem;
            color: var(--text-muted);
        }

        .gaps-summary {
            display: flex;
            gap: 1.5rem;
            padding: 0.75rem 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin-top: 0.5rem;
        }

        .gaps-summary-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .gaps-summary-value {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .gaps-summary-label {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* No data state */
        .insight-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            color: var(--text-muted);
            font-size: 0.8rem;
            text-align: center;
        }

        .insight-empty-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            opacity: 0.5;
        }

        /* ================================================
           BIRTHDAYS PAGE
           ================================================ */

        .birthdays-page {
            display: none;
            padding: 1.5rem;
            max-width: 900px;
            margin: 0 auto;
            height: 100%;
            overflow-y: auto;
        }

        .birthdays-page.visible {
            display: block;
        }

        .birthdays-header {
            margin-bottom: 1.5rem;
        }

        .birthdays-header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 0 0 0.5rem 0;
        }

        .birthdays-stats {
            color: var(--text-muted);
            font-size: 0.875rem;
        }

        .birthdays-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.5rem;
        }

        .birthdays-tab {
            background: none;
            border: none;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            color: var(--text-muted);
            cursor: pointer;
            border-radius: 0.375rem;
        }

        .birthdays-tab:hover {
            background: var(--bg-tertiary);
        }

        .birthdays-tab.active {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        /* Birthday Heatmap (separate from person heatmap) */
        .birthday-heatmap-container {
            background: var(--bg-secondary);
            border-radius: 0.5rem;
            padding: 1rem;
        }

        .birthday-heatmap-months {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
        }

        .birthday-heatmap-month {
            display: flex;
            flex-direction: column;
            gap: 2px;
            flex: 0 0 auto;
        }

        .birthday-heatmap-month-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-align: center;
            margin-bottom: 0.25rem;
        }

        .birthday-heatmap-days {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
        }

        .birthday-heatmap-day {
            width: 10px;
            height: 10px;
            border-radius: 2px;
            background: var(--bg-tertiary);
            cursor: default;
            position: relative;
        }

        .birthday-heatmap-day.has-birthday {
            background: var(--people);
            cursor: pointer;
        }

        .birthday-heatmap-day.has-birthday:hover {
            outline: 2px solid var(--text-primary);
            outline-offset: 1px;
        }

        .birthday-heatmap-day.today {
            outline: 2px solid #f472b6;
            outline-offset: -1px;
        }

        /* Birthday heatmap tooltip */
        .birthday-heatmap-tooltip {
            position: fixed;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            padding: 0.5rem 0.75rem;
            font-size: 0.75rem;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            max-width: 200px;
        }

        .birthday-heatmap-tooltip-date {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .birthday-heatmap-tooltip-names {
            color: var(--text-muted);
        }

        .birthday-heatmap-legend {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            justify-content: flex-end;
            margin-top: 1rem;
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .birthday-heatmap-legend .legend-box {
            width: 10px;
            height: 10px;
            border-radius: 2px;
            background: var(--bg-tertiary);
        }

        .birthday-heatmap-legend .legend-box.has-birthday { background: var(--people); }
        .birthday-heatmap-legend .legend-box.today { outline: 2px solid #f472b6; outline-offset: -1px; }

        /* Birthday Timeline */
        .birthday-timeline-filter {
            background: var(--bg-secondary);
            padding: 0.75rem 1rem;
            border-radius: 0.375rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .birthday-timeline-filter button {
            background: var(--bg-tertiary);
            border: none;
            padding: 0.375rem 0.75rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            cursor: pointer;
            color: var(--text-primary);
        }

        .birthday-timeline-filter button:hover {
            background: var(--bg-primary);
        }

        .birthday-timeline {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .birthday-timeline-entry {
            background: var(--bg-secondary);
            border-radius: 0.5rem;
            overflow: hidden;
        }

        .birthday-timeline-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            cursor: pointer;
        }

        .birthday-timeline-header:hover {
            background: var(--bg-tertiary);
        }

        .birthday-timeline-date {
            font-weight: 500;
        }

        .birthday-timeline-count {
            font-size: 0.75rem;
            color: var(--text-muted);
            background: var(--bg-tertiary);
            padding: 0.125rem 0.5rem;
            border-radius: 1rem;
        }

        .birthday-timeline-people {
            border-top: 1px solid var(--border);
            display: none;
        }

        .birthday-timeline-entry.expanded .birthday-timeline-people {
            display: block;
        }

        .birthday-timeline-person {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            cursor: pointer;
        }

        .birthday-timeline-person:hover {
            background: var(--bg-tertiary);
        }

        .birthday-timeline-person:not(:last-child) {
            border-bottom: 1px solid var(--border);
        }

        .birthday-timeline-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            color: var(--text-muted);
        }

        .birthday-timeline-avatar img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }

        .birthday-timeline-name {
            flex: 1;
            color: var(--people);
        }

        /* Single person entry (no expand needed) */
        .birthday-timeline-entry.single .birthday-timeline-header {
            cursor: pointer;
        }

        .birthday-timeline-entry.single .birthday-timeline-person {
            padding: 0;
        }

        /* ================================================
           RELATIONSHIP DASHBOARD
           ================================================ */

        .relationship-dashboard {
            display: none;
        }

        .relationship-dashboard.visible {
            display: block;
            padding-bottom: 2rem;
        }

        /* Ensure scrolling works when relationship dashboard is visible */
        .detail-content:has(.relationship-dashboard.visible) {
            overflow-y: auto;
            min-height: 0;
        }

        /* Warm accent colors for relationship page */
        .relationship-dashboard {
            --rel-warm: #e94560;
            --rel-warm-light: #ff6b8a;
            --rel-gold: #f4a261;
            --rel-coral: #e76f51;
            --rel-teal: #2a9d8f;
        }

        /* Trend Callout Cards - Horizontal Scroll */
        .trend-callouts-scroll {
            display: flex;
            gap: 1rem;
            overflow-x: auto;
            padding: 0.5rem 0 1rem;
            scrollbar-width: thin;
            scrollbar-color: var(--border) transparent;
            margin-bottom: 1.5rem;
        }

        .trend-callout-card {
            flex: 0 0 auto;
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1rem 1.25rem;
            min-width: 200px;
            max-width: 280px;
            position: relative;
            overflow: hidden;
        }

        .trend-callout-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--rel-warm) 0%, var(--rel-gold) 100%);
        }

        .trend-callout-icon {
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
        }

        .trend-callout-text {
            font-size: 0.875rem;
            color: var(--text-primary);
            line-height: 1.4;
        }

        .trend-callout-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--rel-warm);
            margin-top: 0.5rem;
        }

        /* Therapy Insights - 6 Panel Grid */
        .insights-section-label {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 1.5rem 0 0.75rem 0;
        }

        .insights-grid-3col {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .insight-panel {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(22, 33, 62, 0.9) 100%);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1rem;
            position: relative;
            min-height: 200px;
            display: flex;
            flex-direction: column;
        }

        .insight-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            border-radius: 10px 10px 0 0;
        }

        .insight-panel-user::before { background: var(--rel-warm); }
        .insight-panel-partner::before { background: #9b59b6; }
        .insight-panel-ai::before { background: linear-gradient(90deg, #f1c40f, #f39c12); }
        .insight-panel-growth::before { background: var(--rel-teal); }
        .insight-panel-themes::before { background: #e67e22; }
        .insight-panel-strengths::before { background: var(--success); }

        .insight-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.25rem;
        }

        .insight-panel-title-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .insight-panel-icon {
            font-size: 1rem;
        }

        .insight-panel-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .insight-panel-subtitle {
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .insight-panel-refresh {
            width: 26px;
            height: 26px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .insight-panel-refresh:hover {
            background: var(--rel-teal);
            border-color: var(--rel-teal);
            color: white;
        }

        .insight-panel-refresh:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .insight-panel-refresh.loading {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .insight-panel-content {
            flex: 1;
            overflow-y: auto;
            max-height: 300px;
        }

        .insight-panel-loading {
            color: var(--text-muted);
            font-size: 0.75rem;
            text-align: center;
            padding: 2rem 0;
        }

        .insight-panel-empty {
            color: var(--text-muted);
            font-size: 0.75rem;
            text-align: center;
            padding: 2rem 1rem;
        }

        .insight-panel-empty-icon {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }

        .insight-item {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .insight-item:last-child {
            border-bottom: none;
        }

        .insight-text {
            flex: 1;
            font-size: 0.8rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .insight-confirmed .insight-text {
            color: var(--text-primary);
        }

        .insight-confirmed::before {
            content: '';
            display: inline-block;
            width: 6px;
            height: 6px;
            background: var(--success);
            border-radius: 50%;
            margin-right: 0.5rem;
            margin-top: 0.4rem;
            flex-shrink: 0;
        }

        .insight-actions {
            display: flex;
            gap: 0.25rem;
            flex-shrink: 0;
        }

        .insight-btn {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
            background: var(--bg-tertiary);
            color: var(--text-muted);
        }

        .insight-btn:hover {
            color: white;
        }

        .insight-btn.confirm:hover {
            background: var(--success);
        }

        .insight-btn.dismiss:hover {
            background: var(--error);
        }

        .insight-source-link {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-decoration: none;
            display: block;
            margin-top: 0.25rem;
        }

        .insight-source-link:hover {
            color: var(--people);
        }

        .insight-source-text {
            font-size: 0.65rem;
            color: var(--text-muted);
            display: block;
            margin-top: 0.25rem;
        }

        /* AI suggestions get italic styling */
        .insight-panel-ai .insight-text {
            font-style: italic;
        }

        /* Visualization Grid */
        .relationship-viz-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .relationship-viz-card {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(22, 33, 62, 0.8) 100%);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.25rem;
            position: relative;
            overflow: hidden;
        }

        .relationship-viz-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--rel-warm) 0%, var(--rel-gold) 100%);
            opacity: 0.7;
        }

        .relationship-viz-card.full-width {
            grid-column: 1 / -1;
        }

        .viz-card-header {
            margin-bottom: 1rem;
        }

        .viz-card-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .viz-card-subtitle {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        .viz-card-content {
            min-height: 180px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .viz-loading {
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        /* iMessage Dynamics (merged balance + flow) */
        .imessage-dynamics-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .dynamics-row {
            display: flex;
            gap: 1.5rem;
        }

        .dynamics-metric {
            flex: 1;
        }

        .dynamics-label {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .dynamics-bar-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }

        .dynamics-bar-label {
            font-size: 0.6rem;
            color: var(--text-muted);
            width: 35px;
        }

        .dynamics-bar {
            flex: 1;
            height: 16px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
        }

        .dynamics-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .dynamics-bar-value {
            font-size: 0.65rem;
            color: var(--text-secondary);
            width: 35px;
            text-align: right;
            font-weight: 500;
        }

        .dynamics-insight {
            font-size: 0.6rem;
            color: var(--text-muted);
            font-style: italic;
            margin-top: 0.25rem;
        }

        .dynamics-summary {
            display: flex;
            justify-content: center;
            gap: 0.75rem;
            padding-top: 0.5rem;
            border-top: 1px solid var(--border);
        }

        .dynamics-summary-stat {
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        .dynamics-summary-divider {
            color: var(--text-muted);
        }

        /* Intensity Waves */
        .intensity-waves-container {
            width: 100%;
            height: 140px;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .intensity-date-range {
            text-align: center;
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-top: 0.5rem;
        }

        .intensity-waves-svg {
            width: 100%;
            height: 100%;
        }

        .intensity-wave-path {
            fill: url(#intensityGradient);
            opacity: 0.8;
        }

        .intensity-wave-line {
            fill: none;
            stroke: var(--rel-warm);
            stroke-width: 2;
        }

        /* Weekly Rhythm Polar Chart */
        .weekly-rhythm-container {
            width: 100%;
            height: 180px;
            display: flex;
            justify-content: center;
        }

        .polar-chart {
            position: relative;
            width: 160px;
            height: 160px;
        }

        .polar-chart svg {
            width: 100%;
            height: 100%;
        }

        .polar-spoke {
            fill: none;
            stroke: var(--border);
            stroke-width: 1;
        }

        .polar-fill {
            fill: rgba(233, 69, 96, 0.3);
            stroke: var(--rel-warm);
            stroke-width: 2;
        }

        .polar-label {
            font-size: 0.65rem;
            fill: var(--text-muted);
        }

        /* Tone Evolution Timeline - Line Chart */
        .tone-timeline-container {
            width: 100%;
            height: 180px;
            position: relative;
        }

        .tone-timeline-svg {
            width: 100%;
            height: 100%;
        }

        .tone-data-point {
            transition: r 0.2s, fill 0.2s;
            cursor: pointer;
        }

        .tone-data-point:hover {
            r: 6;
        }

        .tone-axis-label {
            font-family: var(--font-primary);
        }

        .tone-month-label {
            font-family: var(--font-primary);
        }

        .tone-summary {
            font-family: var(--font-primary);
        }

        /* Beyond Texting (Other Channels) */
        .beyond-texting-grid {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .beyond-channel-card {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border-left: 3px solid var(--channel-color);
        }

        .beyond-channel-icon {
            font-size: 1.25rem;
        }

        .beyond-channel-info {
            flex: 1;
        }

        .beyond-channel-name {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .beyond-channel-stat {
            font-size: 0.65rem;
            color: var(--text-muted);
        }

        .beyond-channel-count {
            font-size: 1rem;
            font-weight: 700;
            color: var(--text-secondary);
        }

        /* Deep vs Quick Bubbles Grid */
        .depth-grid {
            display: grid;
            grid-template-columns: auto repeat(3, 1fr);
            gap: 0.4rem;
            font-size: 0.7rem;
        }

        .depth-header-row {
            display: contents;
        }

        .depth-col-header {
            text-align: center;
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 0.65rem;
            padding-bottom: 0.25rem;
        }

        .depth-subtext {
            font-size: 0.55rem;
            color: var(--text-muted);
            font-weight: 400;
        }

        .depth-row-label {
            color: var(--text-muted);
            font-size: 0.65rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .depth-cell {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 50px;
        }

        .depth-bubble {
            border-radius: 50%;
            opacity: 0.8;
            transition: transform 0.2s, opacity 0.2s;
            cursor: help;
        }

        .depth-bubble:hover {
            transform: scale(1.1);
            opacity: 1;
        }

        .depth-empty {
            color: var(--text-muted);
            font-size: 0.6rem;
        }

        .depth-legend {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            margin-top: 0.75rem;
            font-size: 0.55rem;
            color: var(--text-muted);
            flex-wrap: wrap;
        }

        /* Shared Context Map (Constellation) */
        .context-constellation {
            position: relative;
            width: 100%;
            height: 180px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .context-center-node {
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, var(--rel-warm), var(--rel-gold));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.7rem;
            text-align: center;
            z-index: 2;
            box-shadow: 0 4px 20px rgba(233, 69, 96, 0.3);
        }

        .context-orbits {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }

        .context-person {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(var(--angle)) translateX(var(--distance)) rotate(calc(-1 * var(--angle)));
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: help;
            transition: transform 0.2s, border-color 0.2s;
        }

        .context-person:hover {
            border-color: var(--rel-warm);
            transform: translate(-50%, -50%) rotate(var(--angle)) translateX(var(--distance)) rotate(calc(-1 * var(--angle))) scale(1.1);
        }

        .context-person-avatar {
            font-size: 0.6rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .context-list {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            margin-top: 0.5rem;
        }

        .context-list-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.65rem;
        }

        .context-list-avatar {
            width: 20px;
            height: 20px;
            background: var(--bg-tertiary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.5rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .context-list-name {
            flex: 1;
            color: var(--text-secondary);
        }

        .context-list-count {
            color: var(--text-muted);
            font-size: 0.6rem;
        }

        .context-map-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
        }

        .context-hint {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-align: center;
            max-width: 200px;
        }

        .me-widget {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .me-widget-title {
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.75rem;
        }

        /* 100% Bar Chart */
        .bar-chart-container {
            margin-bottom: 0.75rem;
        }

        .bar-chart-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-bottom: 0.25rem;
        }

        .bar-chart {
            display: flex;
            height: 24px;
            border-radius: 4px;
            overflow: hidden;
            background: var(--bg-primary);
        }

        .bar-segment {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            color: white;
            min-width: 0;
            transition: all 0.2s;
            cursor: pointer;
        }

        .bar-segment:hover {
            filter: brightness(1.2);
        }

        .bar-segment-label {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 0 0.25rem;
        }

        /* Bar chart colors */
        .bar-imessage { background: #34c759; }
        .bar-email, .bar-gmail { background: #ff9500; }
        .bar-calendar { background: #5856d6; }
        .bar-slack { background: #e01e5a; }
        .bar-vault { background: #00bcd4; }
        .bar-phone { background: #30b0c7; }
        .bar-whatsapp { background: #25d366; }
        .bar-linkedin { background: #0077b5; }
        .bar-granola { background: #8b5cf6; }
        .bar-contacts { background: #64748b; }
        .bar-other { background: #64748b; }

        /* Circle colors */
        .bar-circle-0 { background: #ef4444; }
        .bar-circle-1 { background: #f97316; }
        .bar-circle-2 { background: #eab308; }
        .bar-circle-3 { background: #22c55e; }
        .bar-circle-4 { background: #06b6d4; }
        .bar-circle-5 { background: #3b82f6; }
        .bar-circle-6 { background: #8b5cf6; }
        .bar-circle-7 { background: #64748b; }

        /* Relationship trends */
        .trends-period-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .trends-period-pill {
            padding: 0.25rem 0.75rem;
            font-size: 0.7rem;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            color: var(--text-muted);
            border-radius: 1rem;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .trends-period-pill:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .trends-period-pill.active {
            background: var(--people);
            color: white;
            border-color: var(--people);
        }

        .trends-section {
            margin-bottom: 1rem;
        }

        .trends-title {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
        }

        .trend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.375rem 0;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
        }

        .trend-item:last-child {
            border-bottom: none;
        }

        .trend-item:hover {
            background: var(--bg-primary);
        }

        .trend-indicator {
            font-size: 0.875rem;
        }

        .trend-warming .trend-indicator { color: #22c55e; }
        .trend-cooling .trend-indicator { color: #ef4444; }

        .trend-pct {
            font-size: 0.7rem;
            font-weight: 600;
            min-width: 2.5rem;
        }

        .trend-pct-warming { color: #22c55e; }
        .trend-pct-cooling { color: #ef4444; }

        .trend-name {
            flex: 1;
            font-size: 0.8rem;
            color: var(--text-primary);
        }

        .trend-change {
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        /* Me Dashboard Widgets */
        .me-widgets-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        @media (max-width: 900px) {
            .me-widgets-row {
                grid-template-columns: 1fr;
            }
        }

        /* Health Score Widget */
        .me-health-panel {
            min-height: 200px;
        }

        /* Family dashboard panels - equal height */
        .family-dashboard .me-widgets-row {
            align-items: stretch;
        }

        .family-dashboard .me-health-panel,
        .family-dashboard .family-trends-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .family-dashboard .family-trends-panel #familyRelationshipTrends {
            flex: 1;
            overflow-y: auto;
        }

        /* Taller chart for family health panel */
        .family-dashboard .health-chart-container {
            height: 200px;
            flex: 1;
        }

        .health-current-score {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--people);
        }

        .health-period-selector {
            display: flex;
            gap: 0.375rem;
            margin-bottom: 0.5rem;
            padding: 0 0.5rem;
        }

        .health-period-pill {
            padding: 0.2rem 0.6rem;
            font-size: 0.65rem;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-muted);
        }

        .health-period-pill:hover {
            border-color: var(--people);
            color: var(--people);
        }

        .health-period-pill.active {
            background: var(--people);
            color: white;
            border-color: var(--people);
        }

        .health-chart-container {
            height: 140px;
            padding: 0.25rem 0;
            width: 100%;
            position: relative;
        }

        .health-line-chart {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .health-chart-svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        .health-chart-tooltip {
            position: absolute;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.35rem 0.5rem;
            font-size: 0.7rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 100;
            white-space: nowrap;
        }

        .health-chart-tooltip.visible {
            opacity: 1;
        }

        .health-chart-tooltip-date {
            color: var(--text-muted);
            font-size: 0.6rem;
        }

        .health-chart-tooltip-score {
            font-weight: 600;
            color: var(--people);
        }

        .health-info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: transparent;
            border: 1.5px solid var(--text-muted);
            font-size: 0.6rem;
            font-weight: 600;
            font-style: italic;
            color: var(--text-muted);
            cursor: help;
            margin-left: 0.35rem;
            position: relative;
        }

        .health-info-icon:hover {
            background: var(--bg-primary);
            border-color: var(--people);
            color: var(--people);
        }

        .health-info-tooltip {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 6px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 0.75rem;
            width: 260px;
            font-size: 0.7rem;
            line-height: 1.4;
            color: var(--text-secondary);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.15s, visibility 0.15s;
            z-index: 200;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .health-info-icon:hover .health-info-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .health-info-tooltip strong {
            color: var(--text-primary);
            display: block;
            margin-bottom: 0.25rem;
        }

        .health-chart-line {
            fill: none;
            stroke: var(--people);
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .health-chart-area {
            fill: var(--people);
            opacity: 0.1;
        }

        .health-chart-dot {
            cursor: pointer;
            transition: r 0.1s ease-out;
            /* fill set via inline style based on score */
        }

        .health-chart-dot:hover {
            r: 6;
            filter: brightness(1.2);
        }

        .tracked-chart-dot {
            cursor: pointer;
            transition: r 0.1s ease-out;
            /* fill set via inline style based on score */
        }

        .tracked-chart-dot:hover {
            r: 6;
            filter: brightness(1.2);
        }

        .health-chart-labels {
            display: flex;
            justify-content: space-between;
            padding: 0.25rem 0;
        }

        .health-chart-label {
            font-size: 0.55rem;
            color: var(--text-muted);
        }

        .health-chart-grid-line {
            stroke: var(--border-color);
            stroke-width: 1;
            stroke-dasharray: 2, 2;
        }

        /* Tracked Relationships Widget */
        .me-tracked-panel {
            min-height: 200px;
            flex: 1;
        }

        .tracked-current-count {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--people);
        }

        .tracked-current-count.tracked-inverse {
            color: var(--people);
        }

        .tracked-current-count.healthy {
            color: #22c55e;
        }

        .tracked-current-count.warning {
            color: #eab308;
        }

        .tracked-current-count.unhealthy {
            color: #ef4444;
        }

        .tracked-people-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.375rem;
            padding: 0.375rem 0.5rem;
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .tracked-person-chip {
            padding: 0.15rem 0.4rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .tracked-person-chip:hover {
            border-color: var(--people);
            color: var(--people);
        }

        /* Tracked chart colors (green for healthy direction) */
        .tracked-chart-line {
            fill: none;
            stroke: var(--people);
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .tracked-chart-line.inverse {
            stroke: #22c55e;  /* Green - fewer is better */
        }

        .tracked-chart-area {
            fill: var(--people);
            opacity: 0.1;
        }

        .tracked-chart-area.inverse {
            fill: #22c55e;
            opacity: 0.1;
        }

        .tracked-chart-dot {
            fill: var(--people);
            cursor: pointer;
            transition: r 0.1s ease-out;
        }

        .tracked-chart-dot.inverse {
            fill: #22c55e;
        }

        .tracked-chart-dot:hover {
            r: 6;
            filter: brightness(1.2);
        }

        /* Neglected Contacts Widget */
        .me-neglected-panel {
            min-height: 180px;
        }

        .neglected-list {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            max-height: 180px;
            overflow-y: auto;
        }

        .neglected-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.375rem 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .neglected-item:hover {
            background: var(--bg-primary);
        }

        .neglected-circle {
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            font-weight: 600;
            color: white;
            flex-shrink: 0;
        }

        .neglected-circle-0 { background: #ef4444; }
        .neglected-circle-1 { background: #f97316; }
        .neglected-circle-2 { background: #eab308; }
        .neglected-circle-3 { background: #22c55e; }

        .neglected-name {
            flex: 1;
            font-size: 0.8rem;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .neglected-days {
            font-size: 0.7rem;
            color: #ef4444;
            white-space: nowrap;
        }

        .neglected-typical {
            font-size: 0.65rem;
            color: var(--text-muted);
            white-space: nowrap;
        }

        /* Chart Panels */
        .me-chart-panel {
            min-height: 220px;
        }

        .me-compact-panel {
            min-height: 220px;
            display: flex;
            flex-direction: column;
            padding-bottom: 0.5rem;
        }

        .me-compact-panel #meTopContacts {
            flex: 1;
            overflow-y: auto;
            max-height: 170px;
        }

        .me-messaging-panel {
            min-height: 380px;
        }

        .me-tall-row {
            align-items: stretch;
        }

        .chart-container {
            height: 180px;
            padding: 0.5rem;
        }

        .chart-container-tall {
            height: 320px;
            flex: 1;
        }

        .chart-subtitle {
            font-size: 0.65rem;
            color: var(--text-muted);
            font-weight: 400;
        }

        /* Network Growth Chart */
        .growth-chart {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .growth-chart-inner {
            display: flex;
            position: relative;
            height: 120px;
        }

        .growth-y-axis {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            width: 24px;
            padding-right: 4px;
            text-align: right;
            height: 120px;
            padding-bottom: 4px;
        }

        .growth-y-label {
            font-size: 0.65rem;
            color: var(--text-primary);
            line-height: 1;
        }

        /* Network Growth tooltip */
        .growth-tooltip {
            position: absolute;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.35rem 0.5rem;
            font-size: 0.7rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 100;
            white-space: nowrap;
        }

        .growth-tooltip.visible {
            opacity: 1;
        }

        .growth-bar {
            cursor: pointer;
        }

        .growth-bars {
            display: flex;
            align-items: flex-end;
            gap: 2px;
            flex: 1;
            height: 120px;
            padding-bottom: 4px;
        }

        .growth-bar-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100%;
            justify-content: flex-end;
        }

        .growth-bar {
            width: 100%;
            background: linear-gradient(to top, var(--people), #a78bfa);
            border-radius: 2px 2px 0 0;
            min-height: 2px;
            transition: height 0.3s ease-out;
        }

        .growth-bar:hover {
            filter: brightness(1.1);
        }

        .growth-labels {
            display: flex;
            gap: 2px;
            margin-top: 0;
        }

        .growth-label {
            flex: 1;
            font-size: 0.6rem;
            color: var(--text-primary);
            text-align: center;
        }

        .growth-label.clickable-month {
            cursor: pointer;
            transition: color 0.15s ease, transform 0.15s ease;
            user-select: none;
        }

        .growth-label.clickable-month:hover {
            color: var(--people);
            transform: scale(1.1);
        }

        .growth-chart-header {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 0.25rem;
        }

        .growth-reset-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            color: var(--text-muted);
            font-size: 0.6rem;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .growth-reset-btn:hover {
            background: var(--people);
            border-color: var(--people);
            color: white;
        }

        .growth-cumulative {
            margin-top: 0.5rem;
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-align: center;
        }

        /* Messaging by Circle Chart */
        .messaging-chart {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .messaging-stacked-bars {
            display: flex;
            align-items: flex-end;
            gap: 3px;
            flex: 1;
            height: 200px;
        }

        .messaging-bar-container {
            flex: 1;
            height: 100%;
            display: flex;
            align-items: flex-end;
        }

        .messaging-stacked-bar {
            width: 100%;
            display: flex;
            flex-direction: column;
            border-radius: 2px 2px 0 0;
            overflow: hidden;
            min-height: 2px;
        }

        .messaging-segment {
            width: 100%;
            transition: height 0.3s ease-out;
        }

        .messaging-segment-0 { background: #ef4444; }
        .messaging-segment-1 { background: #f97316; }
        .messaging-segment-2 { background: #eab308; }
        .messaging-segment-3 { background: #22c55e; }
        .messaging-segment-4 { background: #3b82f6; }
        .messaging-segment-5 { background: #6b7280; }

        .messaging-bar-container {
            cursor: pointer;
        }

        .messaging-bar-container:hover .messaging-stacked-bar {
            filter: brightness(1.1);
        }

        /* Messaging tooltip */
        .messaging-tooltip {
            position: absolute;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.35rem 0.5rem;
            font-size: 0.7rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 100;
            white-space: nowrap;
        }

        .messaging-tooltip.visible {
            opacity: 1;
        }

        .messaging-chart-header {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .messaging-toggles-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .messaging-mode-toggle {
            display: flex;
            gap: 2px;
            background: var(--bg-secondary);
            border-radius: 4px;
            padding: 2px;
        }

        .mode-toggle-btn {
            padding: 0.2rem 0.5rem;
            font-size: 0.6rem;
            border: none;
            background: transparent;
            color: var(--text-muted);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .mode-toggle-btn:hover {
            color: var(--text-primary);
        }

        .mode-toggle-btn.active {
            background: var(--people);
            color: white;
        }

        .messaging-chart-inner {
            display: flex;
            flex: 1;
        }

        .messaging-y-axis {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            width: 28px;
            padding-right: 4px;
            text-align: right;
            height: 200px;
        }

        .messaging-y-label {
            font-size: 0.65rem;
            color: var(--text-primary);
            line-height: 1;
        }

        .messaging-labels {
            display: flex;
            gap: 3px;
            margin-top: 0.25rem;
        }

        .messaging-label {
            flex: 1;
            font-size: 0.6rem;
            color: var(--text-primary);
            text-align: center;
        }

        .messaging-label.clickable-month {
            cursor: pointer;
            transition: color 0.15s ease, transform 0.15s ease;
            user-select: none;
        }

        .messaging-label.clickable-month:hover {
            color: var(--people);
            transform: scale(1.1);
        }

        .messaging-reset-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            color: var(--text-muted);
            font-size: 0.65rem;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .messaging-reset-btn:hover {
            background: var(--people);
            border-color: var(--people);
            color: white;
        }

        .messaging-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
            justify-content: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.6rem;
            color: var(--text-muted);
        }

        .legend-dot {
            width: 8px;
            height: 8px;
            border-radius: 2px;
        }

        .legend-toggle {
            cursor: pointer;
            padding: 0.15rem 0.35rem;
            border-radius: 4px;
            transition: all 0.15s;
            opacity: 0.4;
        }

        .legend-toggle.selected {
            opacity: 1;
            background: var(--bg-tertiary);
        }

        .legend-toggle:hover {
            background: var(--bg-tertiary);
        }

        .messaging-insight {
            margin-top: 0.25rem;
            padding: 0.35rem 0.5rem;
            background: var(--bg-primary);
            border-radius: 4px;
            font-size: 0.75rem;
            color: var(--text-primary);
            line-height: 1.4;
        }

        .messaging-insight:first-of-type {
            margin-top: 0.75rem;
        }

        /* Top contacts */
        .top-contact {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .top-contact:hover {
            background: var(--bg-primary);
        }

        .top-contact-rank {
            width: 1.5rem;
            height: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--people);
            color: white;
            border-radius: 50%;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .top-contact-info {
            flex: 1;
        }

        .top-contact-name {
            font-size: 0.8rem;
            color: var(--text-primary);
        }

        .top-contact-count {
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .fact-confidence.low {
            color: var(--error);
        }

        /* Summary facts have distinct styling */
        .facts-category.summary .fact-item {
            background: linear-gradient(90deg, rgba(0, 188, 212, 0.05) 0%, transparent 100%);
            padding: 0.5rem;
            margin: 0.25rem 0;
        }

        .facts-category.summary .fact-text {
            font-size: 0.75rem;
        }

        /* ===============================
           Mobile Menu Button (hidden on desktop)
           =============================== */
        .mobile-menu-btn {
            display: none;
            width: 44px;
            height: 44px;
            padding: 0;
            background: transparent;
            border: none;
            cursor: pointer;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            transition: background 0.2s;
        }

        .mobile-menu-btn:hover,
        .mobile-menu-btn:active {
            background: var(--bg-tertiary);
        }

        .mobile-menu-btn .hamburger-icon {
            display: block;
            width: 20px;
            height: 2px;
            background: var(--text-primary);
            position: relative;
            transition: background 0.2s;
        }

        .mobile-menu-btn .hamburger-icon::before,
        .mobile-menu-btn .hamburger-icon::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 2px;
            background: var(--text-primary);
            left: 0;
            transition: transform 0.3s, top 0.3s;
        }

        .mobile-menu-btn .hamburger-icon::before { top: -6px; }
        .mobile-menu-btn .hamburger-icon::after { top: 6px; }

        .mobile-menu-btn.active .hamburger-icon {
            background: transparent;
        }

        .mobile-menu-btn.active .hamburger-icon::before {
            top: 0;
            transform: rotate(45deg);
        }

        .mobile-menu-btn.active .hamburger-icon::after {
            top: 0;
            transform: rotate(-45deg);
        }

        /* Sidebar overlay */
        .sidebar-overlay {
            display: none;
            position: fixed;
            top: var(--header-height);
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 998;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .sidebar-overlay.visible {
            opacity: 1;
        }

        /* ===============================
           Mobile Responsive Styles (768px)
           =============================== */
        @media (max-width: 768px) {
            /* Show mobile menu button */
            .mobile-menu-btn {
                display: flex;
            }

            /* Show overlay on mobile */
            .sidebar-overlay {
                display: block;
                pointer-events: none;
            }

            .sidebar-overlay.visible {
                pointer-events: auto;
            }

            /* Header adjustments */
            .header {
                padding: 0 0.75rem;
                padding-left: calc(0.75rem + var(--safe-left));
                padding-right: calc(0.75rem + var(--safe-right));
            }

            .header-left {
                gap: 0.5rem;
            }

            .header-brand {
                padding: 0.25rem;
                font-size: 0.9rem;
            }

            .header-nav {
                margin-left: 0.25rem;
                padding-left: 0.5rem;
                gap: 0.125rem;
            }

            .nav-link {
                padding: 0.5rem 0.625rem;
                font-size: 0.8rem;
                min-height: 44px;
                display: flex;
                align-items: center;
            }

            .header-right {
                gap: 0.5rem;
            }

            .header-right .nav-link.me-link {
                display: none;
            }

            .stats-display {
                display: none;
            }

            /* Main layout - people panel as slide-out drawer */
            .main-container {
                flex-direction: row;
                position: relative;
            }

            .people-list-panel {
                position: fixed;
                top: var(--header-height);
                left: 0;
                bottom: 0;
                width: 85%;
                max-width: 320px;
                height: auto;
                z-index: 999;
                transform: translateX(-100%);
                transition: var(--mobile-panel-transition);
                box-shadow: 4px 0 20px rgba(0, 0, 0, 0.3);
                padding-left: var(--safe-left);
                padding-bottom: var(--safe-bottom);
            }

            .people-list-panel.visible {
                transform: translateX(0);
            }

            /* Detail panel takes full width */
            .detail-panel {
                width: 100%;
                height: calc(100vh - var(--header-height));
                padding-bottom: var(--safe-bottom);
            }

            /* Search input - prevent iOS zoom */
            .search-input {
                font-size: 16px;
                min-height: 48px;
                padding: 0.875rem 1rem;
            }

            .search-bar {
                padding: 0.75rem;
            }

            /* Filter chips */
            .filters {
                padding: 0.5rem 0.75rem;
                gap: 0.5rem;
            }

            .filter-chip {
                padding: 0.625rem 0.875rem;
                min-height: 44px;
                font-size: 0.8rem;
            }

            .filter-chip:active {
                background: var(--people);
                color: white;
            }

            /* Filter dropdowns as bottom sheet */
            .people-filter-options {
                position: fixed;
                top: auto;
                bottom: 0;
                left: 0;
                right: 0;
                max-height: 60vh;
                border-radius: 16px 16px 0 0;
                padding-bottom: calc(1rem + var(--safe-bottom));
                box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3);
            }

            .people-filter-option {
                min-height: 48px;
                padding: 0.75rem 1rem;
            }

            /* Person cards */
            .person-card {
                min-height: 64px;
                padding: 0.875rem;
            }

            .person-card:active {
                background: var(--bg-tertiary);
            }

            .person-avatar {
                width: 48px;
                height: 48px;
                font-size: 1.25rem;
            }

            .dunbar-badge {
                width: 24px;
                height: 24px;
                font-size: 0.65rem;
            }

            .person-checkbox {
                width: 24px;
                height: 24px;
                opacity: 1;
            }

            /* Detail header - compact on mobile */
            .detail-header {
                flex-wrap: nowrap;
                padding: 0.75rem;
                gap: 0.625rem;
                align-items: center;
            }

            .detail-avatar {
                width: 48px;
                height: 48px;
                font-size: 1.25rem;
                flex-shrink: 0;
            }

            .detail-title {
                flex: 1;
                min-width: 0;
            }

            .detail-name {
                font-size: 1.1rem;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .detail-company {
                font-size: 0.7rem;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .detail-contact-quick {
                display: none;
            }

            .detail-tags {
                display: none;
            }

            .header-indicators {
                flex-shrink: 0;
                display: flex;
                gap: 0.5rem;
            }

            .header-strength,
            .header-dunbar {
                transform: scale(0.8);
                transform-origin: center;
            }

            .header-indicator-label {
                display: none;
            }

            .detail-contact-link {
                min-height: 44px;
                padding: 0.5rem 0.75rem;
            }

            /* Mobile details drawer */
            .mobile-details-drawer {
                display: block;
                background: var(--bg-secondary);
                border-bottom: 1px solid var(--border);
            }

            .mobile-details-toggle {
                width: 100%;
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 0.5rem 0.75rem;
                background: none;
                border: none;
                color: var(--text-secondary);
                font-size: 0.75rem;
                cursor: pointer;
                min-height: 36px;
            }

            .mobile-details-toggle:active {
                background: var(--bg-tertiary);
            }

            .mobile-details-chevron {
                font-size: 0.625rem;
                transition: transform 0.2s;
            }

            .mobile-details-drawer.expanded .mobile-details-chevron {
                transform: rotate(180deg);
            }

            .mobile-details-content {
                display: none;
                padding: 0 0.75rem 0.75rem;
            }

            .mobile-details-drawer.expanded .mobile-details-content {
                display: block;
            }

            .mobile-details-row {
                padding: 0.375rem 0;
                font-size: 0.8rem;
                color: var(--text-primary);
                display: flex;
                flex-wrap: wrap;
                gap: 0.5rem;
                align-items: center;
            }

            .mobile-details-row:empty {
                display: none;
            }

            .mobile-details-row a {
                color: var(--people);
                text-decoration: none;
                padding: 0.25rem 0.5rem;
                background: var(--bg-tertiary);
                border-radius: 4px;
                min-height: 32px;
                display: inline-flex;
                align-items: center;
            }

            .mobile-details-row .tag-chip {
                font-size: 0.7rem;
                padding: 0.25rem 0.5rem;
                min-height: 28px;
            }

            /* Hide on timeline/graph modes */
            .timeline-mode .mobile-details-drawer,
            .graph-mode .mobile-details-drawer {
                display: none;
            }

            /* Tabs - horizontal scroll */
            .tabs {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
                padding: 0 0.5rem;
            }

            .tabs::-webkit-scrollbar {
                display: none;
            }

            .tab {
                padding: 1rem 1.25rem;
                min-height: 48px;
                white-space: nowrap;
                flex-shrink: 0;
            }

            .tab:active {
                color: var(--people);
            }

            /* Tab content */
            .tab-content {
                padding: 0.75rem;
            }

            /* Hero stats - horizontal scroll */
            .hero-stats {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                flex-wrap: nowrap;
                padding-bottom: 0.5rem;
                scrollbar-width: none;
                gap: 0.5rem;
            }

            .hero-stats::-webkit-scrollbar {
                display: none;
            }

            .hero-stat {
                flex-shrink: 0;
                min-height: 44px;
                min-width: 100px;
                padding: 0.75rem;
            }

            /* Overview grids */
            .overview-content-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .strength-components {
                grid-template-columns: 1fr 1fr;
            }

            /* Heatmap */
            .heatmap-container {
                margin-left: -0.75rem;
                margin-right: -0.75rem;
                padding: 0.75rem;
                border-radius: 0;
            }

            .heatmap-scroll-wrapper {
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
            }

            .heatmap-scroll-wrapper::-webkit-scrollbar {
                display: none;
            }

            .heatmap-day {
                width: 14px;
                height: 14px;
                min-width: 14px;
                min-height: 14px;
            }

            .heatmap-weekday {
                font-size: 0.625rem;
            }

            .heatmap-month-label {
                font-size: 0.625rem;
            }

            .heatmap-tooltip {
                position: fixed;
                left: 50% !important;
                transform: translateX(-50%);
                bottom: calc(20px + var(--safe-bottom));
                top: auto !important;
                max-width: 90vw;
            }

            .heatmap-years-select {
                min-height: 44px;
                font-size: 16px;
            }

            /* Timeline filters */
            .timeline-filters {
                flex-wrap: wrap;
                gap: 0.5rem;
                padding: 0.75rem;
            }

            .timeline-filter-chip {
                padding: 0.625rem 1rem;
                min-height: 44px;
                font-size: 0.875rem;
                display: inline-flex;
                align-items: center;
            }

            .timeline-filter-chip:active {
                background: var(--people);
                color: white;
            }

            /* Timeline date range */
            .timeline-date-range {
                width: 100%;
                flex-wrap: wrap;
                margin-left: 0;
                margin-top: 0.75rem;
                gap: 0.5rem;
            }

            .timeline-date-range input[type="date"] {
                flex: 1;
                min-width: 140px;
                min-height: 44px;
                padding: 0.5rem;
                font-size: 16px;
            }

            .timeline-date-range button {
                min-height: 44px;
                padding: 0.5rem 1rem;
            }

            .timeline-date-range label {
                min-height: 44px;
                display: flex;
                align-items: center;
            }

            /* Timeline items */
            .timeline {
                -webkit-overflow-scrolling: touch;
            }

            .timeline-item {
                padding: 1rem;
            }

            .timeline-title {
                line-height: 1.4;
            }

            .timeline-title a {
                min-height: 44px;
                display: inline-flex;
                align-items: center;
                padding: 0.25rem 0;
            }

            .photo-group-header {
                min-height: 44px;
                display: flex;
                align-items: center;
                cursor: pointer;
            }

            .photo-group-header:active {
                color: var(--people);
            }

            .photo-thumbnail {
                min-width: 60px;
                min-height: 60px;
            }

            .timeline-item-actions {
                opacity: 1;
                position: static;
                margin-top: 0.75rem;
                display: flex;
                gap: 0.5rem;
            }

            .timeline-item-actions button {
                min-height: 40px;
                padding: 0.5rem 0.75rem;
            }

            /* Graph controls */
            .graph-controls {
                flex-direction: column;
                padding: 0.5rem;
                gap: 0.5rem;
            }

            .graph-controls-primary {
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            .graph-btn {
                min-height: 44px;
                padding: 0.5rem 0.75rem;
                flex: 1;
                min-width: 80px;
            }

            .graph-slider-container {
                width: 100%;
                min-height: 44px;
            }

            .graph-slider-container input[type="range"] {
                min-height: 44px;
            }

            .graph-degree-toggle {
                width: 100%;
            }

            .graph-degree-toggle select {
                min-height: 44px;
                font-size: 16px;
            }

            .graph-container {
                touch-action: none;
            }

            .graph-container svg {
                touch-action: none;
            }

            /* Graph fullscreen toggle (mobile only) */
            .graph-fullscreen-toggle {
                display: flex !important;
            }

            /* Source filter dropdown */
            .source-filter-options {
                position: fixed;
                top: auto;
                bottom: 0;
                left: 0;
                right: 0;
                max-height: 70vh;
                border-radius: 16px 16px 0 0;
                padding-bottom: calc(1rem + var(--safe-bottom));
            }

            .source-option {
                min-height: 48px;
                padding: 0.75rem 1rem;
            }

            /* Me widgets */
            .me-widgets-row {
                grid-template-columns: 1fr;
            }

            .insights-grid-3col {
                grid-template-columns: 1fr;
            }

            /* Overview panels */
            .overview-panel {
                padding: 0.75rem;
            }

            .quick-facts-section {
                padding: 0.75rem;
            }

            /* Notes area */
            .notes-area {
                min-height: 100px;
                font-size: 16px;
            }

            /* Contact grid */
            .contact-grid-compact {
                gap: 0.5rem;
            }

            .contact-item-compact {
                min-height: 44px;
                padding: 0.5rem;
            }

            /* Relationship viz */
            .relationship-viz-grid {
                grid-template-columns: 1fr;
            }

            .relationship-viz-card {
                padding: 0.75rem;
            }

            /* Birthday toast */
            .birthday-toast {
                padding-left: calc(0.75rem + var(--safe-left));
                padding-right: calc(0.75rem + var(--safe-right));
            }

            /* Modals as bottom sheets */
            .merge-modal,
            .split-modal {
                align-items: flex-end;
            }

            .merge-modal-content,
            .split-modal-content {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                max-width: 100%;
                width: 100%;
                max-height: 90vh;
                border-radius: 16px 16px 0 0;
                padding: 1.25rem;
                padding-bottom: calc(1.5rem + var(--safe-bottom));
                animation: slideUp 0.3s ease-out;
            }

            @keyframes slideUp {
                from { transform: translateY(100%); }
                to { transform: translateY(0); }
            }

            .merge-modal-header,
            .split-modal-header {
                font-size: 1.1rem;
                text-align: center;
                padding-bottom: 0.75rem;
                border-bottom: 1px solid var(--border);
                margin-bottom: 1rem;
            }

            .merge-modal-actions,
            .split-modal-actions {
                flex-direction: column;
                gap: 0.75rem;
                margin-top: 1rem;
            }

            .merge-modal-actions button,
            .split-modal-actions button {
                width: 100%;
                min-height: 48px;
                font-size: 1rem;
            }

            .merge-person-option,
            .split-source-item {
                min-height: 56px;
                padding: 0.75rem;
            }

            .merge-person-option:active,
            .split-source-item:active {
                background: var(--bg-tertiary);
            }
        }

        /* Graph fullscreen mode */
        .graph-fullscreen-toggle {
            display: none;
        }

        #tabGraph.graph-fullscreen {
            position: fixed !important;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            background: var(--bg-primary);
            padding: 0;
            display: flex;
            flex-direction: column;
        }

        #tabGraph.graph-fullscreen .graph-container {
            flex: 1;
            height: calc(100vh - 120px);
            border-radius: 0;
        }

        #tabGraph.graph-fullscreen .graph-controls {
            position: relative;
            background: var(--bg-secondary);
            z-index: 10;
            border-bottom: 1px solid var(--border);
        }

        /* Small phone adjustments */
        @media (max-width: 480px) {
            .header-brand {
                font-size: 0.85rem;
            }

            .nav-link {
                padding: 0.5rem;
                font-size: 0.75rem;
            }

            .detail-name {
                font-size: 1.1rem;
            }

            .tab {
                padding: 0.875rem 1rem;
                font-size: 0.85rem;
            }

            .hero-stat {
                min-width: 90px;
                padding: 0.625rem;
            }

            .hero-stat-value {
                font-size: 1.25rem;
            }

            .hero-stat-label {
                font-size: 0.65rem;
            }
        }

        /* ===============================
           Skeleton Loading Animations
           =============================== */
        .skeleton {
            background: linear-gradient(90deg, var(--bg-tertiary) 25%, var(--bg-secondary) 50%, var(--bg-tertiary) 75%);
            background-size: 200% 100%;
            animation: skeleton-loading 1.5s infinite;
            border-radius: 4px;
        }

        @keyframes skeleton-loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .skeleton-text {
            height: 1em;
            margin: 0.5em 0;
        }

        .skeleton-text.short { width: 40%; }
        .skeleton-text.medium { width: 70%; }
        .skeleton-text.long { width: 100%; }

        .skeleton-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
        }

        .skeleton-card {
            padding: 1rem;
            margin: 0.5rem 0;
        }

        /* Birthday Toast Notification */
        .birthday-toast {
            position: fixed;
            top: calc(var(--safe-top) + var(--header-height));
            left: 0;
            right: 0;
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
            border-bottom: 1px solid var(--people);
            padding: 0.75rem 1rem;
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .birthday-toast-content {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .birthday-toast-icon {
            font-size: 1.25rem;
        }

        .birthday-toast-message {
            font-size: 0.875rem;
            color: var(--text-primary);
        }

        .birthday-toast-message a {
            color: var(--people);
            text-decoration: none;
        }

        .birthday-toast-message a:hover {
            text-decoration: underline;
        }

        .birthday-toast-dismiss {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.25rem;
            cursor: pointer;
            padding: 0.25rem;
            line-height: 1;
        }

        .birthday-toast-dismiss:hover {
            color: var(--text-primary);
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-left">
            <button class="mobile-menu-btn" id="crmMenuBtn" onclick="togglePeoplePanel()" aria-label="Toggle people list">
                <span class="hamburger-icon"></span>
            </button>
            <a href="/" class="header-brand">LifeOS</a>
            <nav class="header-nav">
                <a href="/chat" class="nav-link">ðŸ’¬ Chat</a>
                <a href="/crm" class="nav-link active">ðŸ‘¥ CRM</a>
            </nav>
        </div>
        <div class="header-right">
            <button class="cleanup-nav-btn" onclick="openCleanupModal()" title="Review entity cleanup queue">
                ðŸ§¹ Cleanup <span class="cleanup-nav-badge" id="cleanupNavBadge" style="display: none;">0</span>
            </button>
            <a href="/birthdays" class="nav-link me-link" data-page="birthdays">ðŸŽ‚ Birthdays</a>
            <a href="/relationship" class="nav-link me-link">ðŸ’• Relationship</a>
            <a href="/family" class="nav-link me-link">ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ Family</a>
            <a href="/me" class="nav-link me-link">ðŸ‘¤ Me</a>
            <div class="stats-display">
                <div class="stat-item">
                    <span>People:</span>
                    <span class="value" id="totalPeople">-</span>
                </div>
            </div>
        </div>
    </header>

    <!-- Mobile sidebar overlay -->
    <div class="sidebar-overlay" id="sidebarOverlayCrm" onclick="closePeoplePanel()"></div>

    <!-- Birthday Toast Notification -->
    <div class="birthday-toast" id="birthdayToast" style="display: none;">
        <div class="birthday-toast-content">
            <span class="birthday-toast-icon">ðŸŽ‚</span>
            <span class="birthday-toast-message" id="birthdayToastMessage"></span>
        </div>
        <button class="birthday-toast-dismiss" onclick="dismissBirthdayToast()" title="Dismiss">Ã—</button>
    </div>

    <!-- Birthdays Page (shown only for /birthdays route) -->
    <div class="birthdays-page" id="birthdaysPage">
        <!-- Header -->
        <div class="birthdays-header">
            <h1>Birthdays</h1>
            <div class="birthdays-stats">
                <span id="birthdaysTotalPeople">0</span> people with birthdays across
                <span id="birthdaysTotalDates">0</span> days
            </div>
        </div>

        <!-- Tabs -->
        <div class="birthdays-tabs">
            <button class="birthdays-tab active" data-tab="heatmap">Calendar</button>
            <button class="birthdays-tab" data-tab="timeline">Timeline</button>
        </div>

        <!-- Heatmap Tab -->
        <div id="birthdaysHeatmapTab" class="birthdays-tab-content">
            <div class="birthday-heatmap-container">
                <div class="birthday-heatmap-months" id="birthdayHeatmapMonths">
                    <!-- 12 month columns rendered by JS -->
                </div>
            </div>
            <div class="birthday-heatmap-legend">
                <div class="legend-box"></div>
                <span class="legend-label">No birthday</span>
                <div class="legend-box has-birthday"></div>
                <span class="legend-label">Birthday</span>
                <div class="legend-box today"></div>
                <span class="legend-label">Today</span>
            </div>
        </div>

        <!-- Timeline Tab -->
        <div id="birthdaysTimelineTab" class="birthdays-tab-content" style="display: none;">
            <div class="birthday-timeline-filter" id="birthdayTimelineFilter" style="display: none;">
                <span>Showing birthdays for <strong id="birthdayFilterDate"></strong></span>
                <button onclick="clearBirthdayFilter()">Show all</button>
            </div>
            <div class="birthday-timeline" id="birthdayTimeline">
                <!-- Timeline entries rendered by JS -->
            </div>
        </div>
    </div>

    <div class="main-container">
        <div class="people-list-panel">
            <div class="search-bar">
                <div class="search-input-wrapper">
                    <input type="text" class="search-input" id="searchInput" placeholder="Search people..." oninput="handleSearch()" onkeydown="handleSearchKeydown(event)">
                    <button type="button" class="search-clear-btn" id="searchClearBtn" onclick="clearSearch()" title="Clear search (Esc)">&times;</button>
                </div>
            </div>
            <div class="filters">
                <div class="people-filter-dropdown" id="peopleCategoryDropdown">
                    <button class="people-filter-btn" onclick="togglePeopleCategoryFilter()">
                        <span id="peopleCategoryLabel">3 Selected</span>
                        <span class="dropdown-arrow">â–¼</span>
                    </button>
                    <div class="people-filter-options" id="peopleCategoryOptions">
                        <div class="people-filter-toggles">
                            <button class="filter-toggle-btn" onclick="selectAllCategories()">All</button>
                            <button class="filter-toggle-btn" onclick="selectNoCategories()">None</button>
                        </div>
                        <label class="people-filter-option">
                            <input type="checkbox" value="self" checked onchange="updatePeopleCategoryFilter()">
                            <span class="category-dot" style="background: #ffffff; border: 1px solid #666;"></span> Self
                        </label>
                        <label class="people-filter-option">
                            <input type="checkbox" value="family" checked onchange="updatePeopleCategoryFilter()">
                            <span class="category-dot" style="background: #daa520;"></span> Family
                        </label>
                        <label class="people-filter-option">
                            <input type="checkbox" value="personal" checked onchange="updatePeopleCategoryFilter()">
                            <span class="category-dot" style="background: #00bcd4;"></span> Personal
                        </label>
                        <label class="people-filter-option">
                            <input type="checkbox" value="work" onchange="updatePeopleCategoryFilter()">
                            <span class="category-dot" style="background: #4f46e5;"></span> Work
                        </label>
                    </div>
                </div>
                <div class="people-filter-dropdown" id="peopleDunbarDropdown">
                    <button class="people-filter-btn" onclick="togglePeopleDunbarFilter()">
                        <span id="peopleDunbarLabel">Circles</span>
                        <span class="dropdown-arrow">â–¼</span>
                    </button>
                    <div class="people-filter-options" id="peopleDunbarOptions">
                        <div class="people-filter-toggles">
                            <button class="filter-toggle-btn" onclick="selectAllDunbar()">All</button>
                            <button class="filter-toggle-btn" onclick="selectNoDunbar()">None</button>
                        </div>
                        <label class="people-filter-option">
                            <input type="checkbox" value="0" checked onchange="updatePeopleDunbarFilter()">
                            <span class="category-dot" style="background: #e94560;"></span> 0: Intimate
                        </label>
                        <label class="people-filter-option">
                            <input type="checkbox" value="1" checked onchange="updatePeopleDunbarFilter()">
                            <span class="category-dot" style="background: #ff6b6b;"></span> 1: Close
                        </label>
                        <label class="people-filter-option">
                            <input type="checkbox" value="2" checked onchange="updatePeopleDunbarFilter()">
                            <span class="category-dot" style="background: #ffa502;"></span> 2: Good Friends
                        </label>
                        <label class="people-filter-option">
                            <input type="checkbox" value="3" checked onchange="updatePeopleDunbarFilter()">
                            <span class="category-dot" style="background: #2ed573;"></span> 3: Friends
                        </label>
                        <label class="people-filter-option">
                            <input type="checkbox" value="4" checked onchange="updatePeopleDunbarFilter()">
                            <span class="category-dot" style="background: #1e90ff;"></span> 4: Acquaintances
                        </label>
                        <label class="people-filter-option">
                            <input type="checkbox" value="5" checked onchange="updatePeopleDunbarFilter()">
                            <span class="category-dot" style="background: #5352ed;"></span> 5: Known
                        </label>
                        <label class="people-filter-option">
                            <input type="checkbox" value="6+" checked onchange="updatePeopleDunbarFilter()">
                            <span class="category-dot" style="background: #747d8c;"></span> 6+: Contacts
                        </label>
                    </div>
                </div>
                <div class="people-filter-dropdown" id="peopleTagDropdown">
                    <button class="people-filter-btn" onclick="togglePeopleTagFilter()">
                        <span id="peopleTagLabel">Tags</span>
                        <span class="dropdown-arrow">â–¼</span>
                    </button>
                    <div class="people-filter-options" id="peopleTagOptions">
                        <!-- Content populated by buildTagFilterOptions() -->
                    </div>
                </div>
            </div>
            <div class="merge-toolbar" id="mergeToolbar">
                <div class="merge-toolbar-info">
                    <strong id="selectedCount">0</strong> <span id="selectedLabel">selected</span>
                </div>
                <div class="merge-toolbar-actions">
                    <button class="clear-selection-btn" onclick="clearSelection()">Clear</button>
                    <button class="bulk-tag-btn" id="bulkTagBtn" onclick="openBulkTagModal()">Tag</button>
                    <button class="merge-btn" id="mergeBtn" onclick="openMergeModal()">Merge</button>
                    <button class="merge-btn hide-btn" id="hideBtn" onclick="hidePerson()" style="display: none;">Hide</button>
                </div>
            </div>
            <div class="people-list" id="peopleList">
                <div class="loading">Loading people...</div>
            </div>
        </div>

        <div class="detail-panel" id="detailPanel">
            <div class="detail-empty" id="detailEmpty">
                <div class="detail-empty-icon">ðŸ‘¤</div>
                <p>Select a person to view details</p>
            </div>
            <div id="detailContent" style="display:none">
                <div class="detail-header">
                    <div class="detail-avatar" id="detailAvatar">JD</div>
                    <div class="detail-title">
                        <div class="detail-name" id="detailName">John Doe</div>
                        <!-- Family Selector (shown only for /family route, below title) -->
                        <div class="family-selector-container" id="familySelectorContainer" style="display: none;"></div>
                        <div class="detail-company" id="detailCompany">Acme Corp Â· Software Engineer</div>
                        <div class="detail-contact-quick" id="detailContactQuick"></div>
                        <div class="detail-tags" id="detailTagsChips"></div>
                    </div>
                    <div class="header-indicators" id="headerIndicators">
                        <div class="header-strength">
                            <div class="header-strength-ring">
                                <svg width="44" height="44" viewBox="0 0 44 44">
                                    <circle class="strength-ring-bg" cx="22" cy="22" r="18"/>
                                    <circle class="strength-ring-fill" id="headerStrengthRingFill" cx="22" cy="22" r="18"
                                            stroke-dasharray="113.1" stroke-dashoffset="113.1"/>
                                </svg>
                                <span class="header-strength-value" id="headerStrengthValue">0</span>
                            </div>
                            <span class="header-indicator-label">Strength</span>
                        </div>
                        <div class="header-dunbar">
                            <div class="header-dunbar-circle" id="headerDunbarCircle" title="Dunbar Circle">0</div>
                            <span class="header-indicator-label" id="headerDunbarLabel">Intimate</span>
                        </div>
                    </div>
                </div>

                <!-- Mobile-only collapsible details (tags, birthday, contact) -->
                <div class="mobile-details-drawer" id="mobileDetailsDrawer">
                    <button class="mobile-details-toggle" id="mobileDetailsToggle" onclick="toggleMobileDetails()">
                        <span class="mobile-details-summary" id="mobileDetailsSummary">Details</span>
                        <span class="mobile-details-chevron" id="mobileDetailsChevron">â–¼</span>
                    </button>
                    <div class="mobile-details-content" id="mobileDetailsContent">
                        <div class="mobile-details-row" id="mobileDetailsBirthday"></div>
                        <div class="mobile-details-row" id="mobileDetailsContact"></div>
                        <div class="mobile-details-row" id="mobileDetailsTags"></div>
                    </div>
                </div>

                <div class="detail-tabs">
                    <div class="tab active" data-tab="overview" onclick="switchTab('overview')">Overview</div>
                    <div class="tab" data-tab="timeline" onclick="switchTab('timeline')">Timeline</div>
                    <div class="tab" data-tab="graph" onclick="switchTab('graph')">Graph</div>
                </div>

                <div class="detail-content">
                    <div id="tabOverview" class="tab-content">
                        <!-- Hero Stats Row -->
                        <div class="hero-stats" id="heroStats">
                            <div class="hero-stat hero-stat-clickable" id="heroStatEmailsContainer" onclick="navigateToTimelineFiltered('gmail')">
                                <span class="hero-stat-icon">ðŸ“§</span>
                                <span class="hero-stat-value" id="heroStatEmails">0</span>
                                <span class="hero-stat-label">emails</span>
                            </div>
                            <div class="hero-stat hero-stat-clickable" id="heroStatEventsContainer" onclick="navigateToTimelineFiltered('calendar')">
                                <span class="hero-stat-icon">ðŸ“…</span>
                                <span class="hero-stat-value" id="heroStatEvents">0</span>
                                <span class="hero-stat-label">events</span>
                            </div>
                            <div class="hero-stat hero-stat-clickable" id="heroStatMessagesContainer" onclick="navigateToTimelineFiltered('messages')">
                                <span class="hero-stat-icon">ðŸ’¬</span>
                                <span class="hero-stat-value" id="heroStatMessages">0</span>
                                <span class="hero-stat-label">messages</span>
                            </div>
                            <div class="hero-stat hero-stat-clickable" id="heroStatPhoneContainer" style="display: none;" onclick="navigateToTimelineFiltered('phone')">
                                <span class="hero-stat-icon">ðŸ“ž</span>
                                <span class="hero-stat-value" id="heroStatPhone">0</span>
                                <span class="hero-stat-label">calls</span>
                            </div>
                            <div class="hero-stat hero-stat-clickable" id="heroStatSlackContainer" style="display: none;" onclick="navigateToTimelineFiltered('slack')">
                                <span class="hero-stat-icon">ðŸ’¼</span>
                                <span class="hero-stat-value" id="heroStatSlack">0</span>
                                <span class="hero-stat-label">slack</span>
                            </div>
                            <div class="hero-stat hero-stat-clickable" id="heroStatNotesContainer" style="display: none;" onclick="navigateToTimelineFiltered('notes')">
                                <span class="hero-stat-icon">ðŸ“</span>
                                <span class="hero-stat-value" id="heroStatNotes">0</span>
                                <span class="hero-stat-label">notes</span>
                            </div>
                            <div class="hero-stat" id="heroStatContactsContainer" style="display: none;">
                                <span class="hero-stat-icon">ðŸ“‡</span>
                                <span class="hero-stat-value" id="heroStatContacts">0</span>
                                <span class="hero-stat-label">contacts</span>
                            </div>
                            <div class="hero-stat" id="heroStatLinkedInContainer" style="display: none;">
                                <span class="hero-stat-icon">ðŸ”—</span>
                                <span class="hero-stat-value" id="heroStatLinkedIn">0</span>
                                <span class="hero-stat-label">linkedin</span>
                            </div>
                            <div class="hero-stat hero-stat-clickable" id="heroStatPhotosContainer" style="display: none;" onclick="navigateToTimelineFiltered('photos')">
                                <span class="hero-stat-icon">ðŸ“·</span>
                                <span class="hero-stat-value" id="heroStatPhotos">0</span>
                                <span class="hero-stat-label">photos</span>
                            </div>
                            <div class="hero-stat-divider"></div>
                            <div class="hero-stat">
                                <span class="hero-stat-icon">ðŸ“</span>
                                <span class="hero-stat-label">Last seen</span>
                                <span class="hero-stat-value" id="heroStatLastSeen">â€”</span>
                            </div>
                        </div>

                        <!-- Family Hero Stats (shown only for /family route, positioned before heatmap) -->
                        <div class="hero-stats" id="familyHeroStats" style="display: none;">
                            <div class="hero-stat hero-stat-clickable" onclick="navigateToTimelineFiltered('gmail')">
                                <span class="hero-stat-icon">ðŸ“§</span>
                                <span class="hero-stat-value" id="familyStatEmails">0</span>
                                <span class="hero-stat-label">emails</span>
                            </div>
                            <div class="hero-stat hero-stat-clickable" onclick="navigateToTimelineFiltered('messages')">
                                <span class="hero-stat-icon">ðŸ’¬</span>
                                <span class="hero-stat-value" id="familyStatMessages">0</span>
                                <span class="hero-stat-label">messages</span>
                            </div>
                            <div class="hero-stat hero-stat-clickable" onclick="navigateToTimelineFiltered('phone')">
                                <span class="hero-stat-icon">ðŸ“ž</span>
                                <span class="hero-stat-value" id="familyStatPhone">0</span>
                                <span class="hero-stat-label">calls</span>
                            </div>
                            <div class="hero-stat hero-stat-clickable" onclick="navigateToTimelineFiltered('calendar')">
                                <span class="hero-stat-icon">ðŸ“…</span>
                                <span class="hero-stat-value" id="familyStatCalendar">0</span>
                                <span class="hero-stat-label">events</span>
                            </div>
                            <div class="hero-stat hero-stat-clickable" id="familyStatPhotosContainer" style="display: none;" onclick="navigateToTimelineFiltered('photos')">
                                <span class="hero-stat-icon">ðŸ“·</span>
                                <span class="hero-stat-value" id="familyStatPhotos">0</span>
                                <span class="hero-stat-label">photos</span>
                            </div>
                        </div>

                        <!-- Heat map calendar -->
                        <div class="heatmap-container">
                            <div class="heatmap-header">
                                <div class="heatmap-title" id="heatmapTitle">365-Day Interaction History</div>
                                <div class="heatmap-legend">
                                    <span>Less</span>
                                    <div class="heatmap-legend-item" style="background: var(--bg-tertiary)"></div>
                                    <div class="heatmap-legend-item" style="background: rgba(0, 188, 212, 0.25)"></div>
                                    <div class="heatmap-legend-item" style="background: rgba(0, 188, 212, 0.45)"></div>
                                    <div class="heatmap-legend-item" style="background: rgba(0, 188, 212, 0.65)"></div>
                                    <div class="heatmap-legend-item" style="background: rgba(0, 188, 212, 0.85)"></div>
                                    <div class="heatmap-legend-item" style="background: var(--people)"></div>
                                    <span>More</span>
                                    <select id="heatmapYearsSelect" class="heatmap-years-select" title="Years of history">
                                        <option value="1">1 yr</option>
                                        <option value="2">2 yrs</option>
                                        <option value="3">3 yrs</option>
                                        <option value="4">4 yrs</option>
                                        <option value="5">5 yrs</option>
                                        <option value="6">6 yrs</option>
                                        <option value="7">7 yrs</option>
                                        <option value="8">8 yrs</option>
                                        <option value="9">9 yrs</option>
                                        <option value="10">10 yrs</option>
                                    </select>
                                </div>
                            </div>
                            <div class="heatmap-scroll-wrapper">
                                <div class="heatmap-inner">
                                    <div class="heatmap-months" id="heatmapMonths"></div>
                                    <div class="heatmap-body">
                                        <div class="heatmap-weekdays">
                                            <div class="heatmap-weekday">Sun</div>
                                            <div class="heatmap-weekday">Mon</div>
                                            <div class="heatmap-weekday">Tue</div>
                                            <div class="heatmap-weekday">Wed</div>
                                            <div class="heatmap-weekday">Thu</div>
                                            <div class="heatmap-weekday">Fri</div>
                                            <div class="heatmap-weekday">Sat</div>
                                        </div>
                                        <div class="heatmap-grid" id="heatmapGrid"></div>
                                    </div>
                                </div>
                            </div>
                            <!-- Volume Line Chart -->
                            <div class="volume-chart-container">
                                <div class="volume-chart-header">
                                    <div class="volume-chart-title">Interaction Volume Over Time</div>
                                </div>
                                <canvas id="volumeChartCanvas" class="volume-chart-canvas"></canvas>
                            </div>
                        </div>
                        <div class="heatmap-tooltip" id="heatmapTooltip"></div>

                        <!-- Me Dashboard (shown only for owner's profile) -->
                        <div class="me-dashboard" id="meDashboard">
                            <!-- Health Score + Neglected Row -->
                            <div class="me-widgets-row">
                                <!-- Relationship Health Score -->
                                <div class="overview-panel me-health-panel">
                                    <div class="overview-panel-header">
                                        <span class="overview-panel-title">
                                            Relationship Health
                                            <span class="health-info-icon">i
                                                <div class="health-info-tooltip">
                                                    <strong>How Relationship Health is calculated</strong>
                                                    Tracks interaction frequency with your top 25 family/personal contacts. Score is relative to your average: 50 = average, 100 = 2Ã— average. Includes messages, calls, meetings, and emails with close contacts.
                                                </div>
                                            </span>
                                        </span>
                                        <span class="health-current-score" id="healthCurrentScore">--</span>
                                    </div>
                                    <div class="health-period-selector">
                                        <button class="health-period-pill" data-period="month" onclick="changeHealthPeriod('month')">Month</button>
                                        <button class="health-period-pill active" data-period="quarter" onclick="changeHealthPeriod('quarter')">Quarter</button>
                                        <button class="health-period-pill" data-period="year" onclick="changeHealthPeriod('year')">Year</button>
                                    </div>
                                    <div class="health-chart-container" id="healthChartContainer"></div>
                                </div>

                                <!-- Neglected Contacts -->
                                <div class="overview-panel me-neglected-panel">
                                    <div class="overview-panel-header">
                                        <span class="overview-panel-title">Need Attention</span>
                                    </div>
                                    <div class="neglected-list" id="neglectedContactsList"></div>
                                </div>
                            </div>

                            <!-- Tracked Relationships Row -->
                            <div class="me-widgets-row">
                                <!-- Parent Relationship (more = healthier) -->
                                <div class="overview-panel me-tracked-panel">
                                    <div class="overview-panel-header">
                                        <span class="overview-panel-title">
                                            Parent Relationship
                                            <span class="health-info-icon">i
                                                <div class="health-info-tooltip">
                                                    <strong>Parent Relationship</strong>
                                                    Tracks interactions with your parents. More frequent contact indicates a healthier relationship.
                                                </div>
                                            </span>
                                        </span>
                                        <span class="tracked-current-count" id="parentCurrentCount">--</span>
                                    </div>
                                    <div class="health-period-selector tracked-period-selector" id="parentPeriodSelector">
                                        <button class="health-period-pill" data-period="month" onclick="changeTrackedPeriod('parent', 'month')">Month</button>
                                        <button class="health-period-pill active" data-period="quarter" onclick="changeTrackedPeriod('parent', 'quarter')">Quarter</button>
                                        <button class="health-period-pill" data-period="year" onclick="changeTrackedPeriod('parent', 'year')">Year</button>
                                    </div>
                                    <div class="health-chart-container" id="parentChartContainer"></div>
                                    <div class="tracked-people-list" id="parentPeopleList"></div>
                                </div>

                                <!-- Parallel Parenting (less = healthier) -->
                                <div class="overview-panel me-tracked-panel">
                                    <div class="overview-panel-header">
                                        <span class="overview-panel-title">
                                            Parallel Parenting
                                            <span class="health-info-icon">i
                                                <div class="health-info-tooltip">
                                                    <strong>Parallel Parenting</strong>
                                                    Tracks interactions with co-parent. Fewer interactions indicate healthier boundaries.
                                                </div>
                                            </span>
                                        </span>
                                        <span class="tracked-current-count tracked-inverse" id="coparentCurrentCount">--</span>
                                    </div>
                                    <div class="health-period-selector tracked-period-selector" id="coparentPeriodSelector">
                                        <button class="health-period-pill" data-period="month" onclick="changeTrackedPeriod('coparent', 'month')">Month</button>
                                        <button class="health-period-pill active" data-period="quarter" onclick="changeTrackedPeriod('coparent', 'quarter')">Quarter</button>
                                        <button class="health-period-pill" data-period="year" onclick="changeTrackedPeriod('coparent', 'year')">Year</button>
                                    </div>
                                    <div class="health-chart-container" id="coparentChartContainer"></div>
                                    <div class="tracked-people-list" id="coparentPeopleList"></div>
                                </div>
                            </div>

                            <!-- Charts Row: Network Growth + Top Contacts (smaller) -->
                            <div class="me-widgets-row">
                                <!-- Network Growth -->
                                <div class="overview-panel me-chart-panel">
                                    <div class="overview-panel-header">
                                        <span class="overview-panel-title">Network Growth</span>
                                    </div>
                                    <div class="chart-container" id="networkGrowthChart"></div>
                                </div>

                                <!-- Top Contacts (smaller) -->
                                <div class="overview-panel me-compact-panel">
                                    <div class="overview-panel-header">
                                        <span class="overview-panel-title">Top Contacts (30 Days)</span>
                                    </div>
                                    <div id="meTopContacts"></div>
                                </div>
                            </div>

                            <!-- Messaging by Circle (double height) + Relationship Trends -->
                            <div class="me-widgets-row me-tall-row">
                                <!-- Messaging Volume by Circle (larger) -->
                                <div class="overview-panel me-messaging-panel">
                                    <div class="overview-panel-header">
                                        <span class="overview-panel-title">Messaging by Circle</span>
                                        <span class="chart-subtitle">iMessage + WhatsApp</span>
                                    </div>
                                    <div class="chart-container chart-container-tall" id="messagingByCircleChart"></div>
                                </div>

                                <!-- Relationship Trends -->
                                <div class="overview-panel">
                                    <div class="overview-panel-header">
                                        <span class="overview-panel-title">Relationship Trends</span>
                                    </div>
                                    <div class="trends-period-selector" id="trendsPeriodSelector">
                                        <button class="trends-period-pill" data-period="week" onclick="changeTrendPeriod('week')">Week</button>
                                        <button class="trends-period-pill" data-period="month" onclick="changeTrendPeriod('month')">Month</button>
                                        <button class="trends-period-pill active" data-period="quarter" onclick="changeTrendPeriod('quarter')">Quarter</button>
                                        <button class="trends-period-pill" data-period="year" onclick="changeTrendPeriod('year')">Year</button>
                                    </div>
                                    <div id="meRelationshipTrends">
                                        <div class="trends-section" id="trendsWarming">
                                            <div class="trends-title">ðŸ”¥ Warming</div>
                                            <div id="trendsWarmingList"></div>
                                        </div>
                                        <div class="trends-section" id="trendsCooling">
                                            <div class="trends-title">â„ï¸ Cooling</div>
                                            <div id="trendsCoolingList"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Family Dashboard (shown only for /family route) -->
                        <div class="family-dashboard" id="familyDashboard" style="display: none;">
                            <!-- Family Selector Row (below title) -->
                            <div class="family-selector-row" id="familySelectorRow"></div>
                            <!-- Family Stats Row -->
                            <div class="me-widgets-row">
                                <!-- Family Health Score -->
                                <div class="overview-panel me-health-panel">
                                    <div class="overview-panel-header">
                                        <span class="overview-panel-title">
                                            Family Contact Health
                                            <span class="health-info-icon">i
                                                <div class="health-info-tooltip">
                                                    <strong>Family Contact Health</strong>
                                                    Tracks interaction frequency with selected family members. Score is relative to your average: 50 = average, 100 = 2Ã— average.
                                                </div>
                                            </span>
                                        </span>
                                        <span class="health-current-score" id="familyHealthCurrentScore">--</span>
                                    </div>
                                    <div class="health-period-selector">
                                        <button class="health-period-pill" data-period="month" onclick="changeFamilyHealthPeriod('month')">Month</button>
                                        <button class="health-period-pill active" data-period="quarter" onclick="changeFamilyHealthPeriod('quarter')">Quarter</button>
                                        <button class="health-period-pill" data-period="year" onclick="changeFamilyHealthPeriod('year')">Year</button>
                                    </div>
                                    <div class="health-chart-container" id="familyHealthChartContainer"></div>
                                </div>

                                <!-- Relationship Trends (replaces Top Contacts) -->
                                <div class="overview-panel family-trends-panel">
                                    <div class="overview-panel-header">
                                        <span class="overview-panel-title">Relationship Trends</span>
                                    </div>
                                    <div class="trends-period-selector" id="familyTrendsPeriodSelector">
                                        <button class="trends-period-pill" data-period="week" onclick="changeFamilyTrendPeriod('week')">Week</button>
                                        <button class="trends-period-pill" data-period="month" onclick="changeFamilyTrendPeriod('month')">Month</button>
                                        <button class="trends-period-pill active" data-period="quarter" onclick="changeFamilyTrendPeriod('quarter')">Quarter</button>
                                        <button class="trends-period-pill" data-period="year" onclick="changeFamilyTrendPeriod('year')">Year</button>
                                    </div>
                                    <div id="familyRelationshipTrends">
                                        <div class="trends-section" id="familyTrendsWarming">
                                            <div class="trends-title">ðŸ”¥ Warming</div>
                                            <div id="familyTrendsWarmingList"></div>
                                        </div>
                                        <div class="trends-section" id="familyTrendsCooling">
                                            <div class="trends-title">â„ï¸ Cooling</div>
                                            <div id="familyTrendsCoolingList"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- NEW: Family Insights Visualizations -->
                            <div class="family-insights-section">
                                <h3 class="family-insights-title">Family Insights</h3>

                                <!-- Row 1: Days Since Contact + Streak Tracker -->
                                <div class="family-insights-row">
                                    <!-- Days Since Last Contact -->
                                    <div class="family-insight-card days-since-card">
                                        <div class="insight-card-header">
                                            <span class="insight-card-title">Days Since Contact</span>
                                            <span class="insight-card-subtitle">Based on Dunbar circle expectations</span>
                                        </div>
                                        <div class="days-since-grid" id="daysSinceGrid">
                                            <div class="insight-loading">Loading...</div>
                                        </div>
                                    </div>

                                    <!-- Streak Tracker -->
                                    <div class="family-insight-card streak-card">
                                        <div class="insight-card-header">
                                            <span class="insight-card-title">Contact Streaks</span>
                                            <span class="insight-card-subtitle">Consecutive weeks in touch</span>
                                        </div>
                                        <div class="streak-grid" id="streakGrid">
                                            <div class="insight-loading">Loading...</div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Row 2: Channel Mix -->
                                <div class="family-insights-row">
                                    <div class="family-insight-card channel-mix-card full-width">
                                        <div class="insight-card-header">
                                            <span class="insight-card-title">Communication Channels</span>
                                            <span class="insight-card-subtitle">How you connect with each person</span>
                                            <select class="insight-period-select" id="channelMixYears" onchange="changeChannelMixYears(this.value)">
                                                <option value="1" selected>1 year</option>
                                                <option value="2">2 years</option>
                                                <option value="3">3 years</option>
                                                <option value="4">4 years</option>
                                                <option value="5">5 years</option>
                                                <option value="6">6 years</option>
                                                <option value="7">7 years</option>
                                                <option value="8">8 years</option>
                                                <option value="9">9 years</option>
                                                <option value="10">10 years</option>
                                            </select>
                                        </div>
                                        <div class="channel-mix-container" id="channelMixContainer">
                                            <div class="insight-loading">Loading...</div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Row 3: Communication Gaps Timeline -->
                                <div class="family-insights-row">
                                    <div class="family-insight-card gaps-card full-width">
                                        <div class="insight-card-header">
                                            <span class="insight-card-title">Communication Gaps</span>
                                            <span class="insight-card-subtitle">Periods of extended silence (14+ days)</span>
                                            <select class="insight-period-select" id="gapsMonths" onchange="changeGapsMonths(this.value)">
                                                <option value="1">1 month</option>
                                                <option value="2">2 months</option>
                                                <option value="3">3 months</option>
                                                <option value="6">6 months</option>
                                                <option value="9">9 months</option>
                                                <option value="12" selected>12 months</option>
                                            </select>
                                        </div>
                                        <div class="gaps-timeline-container" id="gapsTimelineContainer">
                                            <div class="insight-loading">Loading...</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Relationship Dashboard (shown only for /relationship route) -->
                        <div class="relationship-dashboard" id="relationshipDashboard" style="display: none;">
                            <!-- Therapy Insights - Row 1: Actionable Commitments -->
                            <div class="insights-section-label">Therapy Insights - Commitments</div>
                            <div class="insights-grid-3col">
                                <!-- For Me -->
                                <div class="insight-panel insight-panel-user">
                                    <div class="insight-panel-header">
                                        <div class="insight-panel-title-group">
                                            <span class="insight-panel-icon">ðŸŽ¯</span>
                                            <span class="insight-panel-title">For Me</span>
                                        </div>
                                        <button class="insight-panel-refresh" onclick="refreshInsightCategory('for_me')" title="Refresh">â†»</button>
                                    </div>
                                    <div class="insight-panel-subtitle">Things to work on</div>
                                    <div class="insight-panel-content" id="insightsForMe">
                                        <div class="insight-panel-loading">Loading...</div>
                                    </div>
                                </div>

                                <!-- For Partner -->
                                <div class="insight-panel insight-panel-partner">
                                    <div class="insight-panel-header">
                                        <div class="insight-panel-title-group">
                                            <span class="insight-panel-icon">ðŸ’œ</span>
                                            <span class="insight-panel-title">For Partner</span>
                                        </div>
                                        <button class="insight-panel-refresh" onclick="refreshInsightCategory('for_partner')" title="Refresh">â†»</button>
                                    </div>
                                    <div class="insight-panel-subtitle">Things they're working on</div>
                                    <div class="insight-panel-content" id="insightsForPartner">
                                        <div class="insight-panel-loading">Loading...</div>
                                    </div>
                                </div>

                                <!-- Fresh Ideas (AI) -->
                                <div class="insight-panel insight-panel-ai">
                                    <div class="insight-panel-header">
                                        <div class="insight-panel-title-group">
                                            <span class="insight-panel-icon">ðŸ’¡</span>
                                            <span class="insight-panel-title">Fresh Ideas</span>
                                        </div>
                                        <button class="insight-panel-refresh" onclick="refreshInsightCategory('ai_suggestions')" title="Refresh">â†»</button>
                                    </div>
                                    <div class="insight-panel-subtitle">AI therapist suggestions</div>
                                    <div class="insight-panel-content" id="insightsAiSuggestions">
                                        <div class="insight-panel-loading">Loading...</div>
                                    </div>
                                </div>
                            </div>

                            <!-- Therapy Insights - Row 2: Patterns & Strengths -->
                            <div class="insights-section-label">Therapy Insights - Patterns</div>
                            <div class="insights-grid-3col">
                                <!-- Growth Patterns -->
                                <div class="insight-panel insight-panel-growth">
                                    <div class="insight-panel-header">
                                        <div class="insight-panel-title-group">
                                            <span class="insight-panel-icon">ðŸ“ˆ</span>
                                            <span class="insight-panel-title">Growth Patterns</span>
                                        </div>
                                        <button class="insight-panel-refresh" onclick="refreshInsightCategory('growth_patterns')" title="Refresh">â†»</button>
                                    </div>
                                    <div class="insight-panel-subtitle">How you've improved</div>
                                    <div class="insight-panel-content" id="insightsGrowth">
                                        <div class="insight-panel-loading">Loading...</div>
                                    </div>
                                </div>

                                <!-- Recurring Themes -->
                                <div class="insight-panel insight-panel-themes">
                                    <div class="insight-panel-header">
                                        <div class="insight-panel-title-group">
                                            <span class="insight-panel-icon">ðŸ”„</span>
                                            <span class="insight-panel-title">Recurring Themes</span>
                                        </div>
                                        <button class="insight-panel-refresh" onclick="refreshInsightCategory('recurring_themes')" title="Refresh">â†»</button>
                                    </div>
                                    <div class="insight-panel-subtitle">Patterns to watch</div>
                                    <div class="insight-panel-content" id="insightsThemes">
                                        <div class="insight-panel-loading">Loading...</div>
                                    </div>
                                </div>

                                <!-- Strengths -->
                                <div class="insight-panel insight-panel-strengths">
                                    <div class="insight-panel-header">
                                        <div class="insight-panel-title-group">
                                            <span class="insight-panel-icon">ðŸ’ª</span>
                                            <span class="insight-panel-title">Strengths</span>
                                        </div>
                                        <button class="insight-panel-refresh" onclick="refreshInsightCategory('relationship_strengths')" title="Refresh">â†»</button>
                                    </div>
                                    <div class="insight-panel-subtitle">What's working well</div>
                                    <div class="insight-panel-content" id="insightsStrengths">
                                        <div class="insight-panel-loading">Loading...</div>
                                    </div>
                                </div>
                            </div>

                            <!-- Visualization Grid - Row 1 -->
                            <div class="relationship-viz-grid">
                                <!-- iMessage Dynamics -->
                                <div class="relationship-viz-card">
                                    <div class="viz-card-header">
                                        <div class="viz-card-title">iMessage Dynamics</div>
                                        <div class="viz-card-subtitle">Who starts conversations & volume balance</div>
                                    </div>
                                    <div class="viz-card-content" id="imessageBalanceViz">
                                        <div class="viz-loading">Analyzing conversations...</div>
                                    </div>
                                </div>

                                <!-- Tone Evolution Timeline -->
                                <div class="relationship-viz-card">
                                    <div class="viz-card-header" style="display: flex; justify-content: space-between; align-items: flex-start;">
                                        <div>
                                            <div class="viz-card-title">Tone Evolution</div>
                                            <div class="viz-card-subtitle">iMessage emotional warmth over time</div>
                                        </div>
                                        <div class="tone-view-dropdown" style="position: relative;">
                                            <select id="toneViewSelect" onchange="setToneViewMode(this.value)" style="font-size: 0.7rem; padding: 0.25rem 0.5rem; border-radius: 4px; border: 1px solid var(--border-subtle); background: var(--bg-secondary); color: var(--text-primary); cursor: pointer;">
                                                <option value="combined">Shared Tone</option>
                                                <option value="user">My Tone</option>
                                                <option value="partner">Partner's Tone</option>
                                                <option value="both">Both</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div class="viz-card-content" id="toneTimelineViz">
                                        <div class="viz-loading">Analyzing tone...</div>
                                    </div>
                                </div>
                            </div>

                            <!-- Visualization Grid - Row 2 -->
                            <div class="relationship-viz-grid">
                                <!-- Interaction Intensity Waves -->
                                <div class="relationship-viz-card">
                                    <div class="viz-card-header">
                                        <div class="viz-card-title">Interaction Intensity</div>
                                        <div class="viz-card-subtitle">Daily connection rhythm over 12 months</div>
                                    </div>
                                    <div class="viz-card-content" id="intensityWavesViz">
                                        <div class="viz-loading">Loading...</div>
                                    </div>
                                </div>

                                <!-- Weekly Rhythm Pattern -->
                                <div class="relationship-viz-card">
                                    <div class="viz-card-header">
                                        <div class="viz-card-title">Weekly Rhythm</div>
                                        <div class="viz-card-subtitle">Peak connection days</div>
                                    </div>
                                    <div class="viz-card-content" id="weeklyRhythmViz">
                                        <div class="viz-loading">Loading...</div>
                                    </div>
                                </div>
                            </div>

                            <!-- Visualization Grid - Row 3 -->
                            <div class="relationship-viz-grid">
                                <!-- Other Channels -->
                                <div class="relationship-viz-card">
                                    <div class="viz-card-header">
                                        <div class="viz-card-title">Beyond Texting</div>
                                        <div class="viz-card-subtitle">Monthly activity by channel (1 year)</div>
                                    </div>
                                    <div class="viz-card-content" id="channelFlowViz">
                                        <div class="viz-loading">Loading...</div>
                                    </div>
                                </div>

                                <!-- Interaction Depth -->
                                <div class="relationship-viz-card">
                                    <div class="viz-card-header">
                                        <div class="viz-card-title">Interaction Depth</div>
                                        <div class="viz-card-subtitle">Quick texts vs deep conversations by time of day</div>
                                    </div>
                                    <div class="viz-card-content" id="depthBubblesViz">
                                        <div class="viz-loading">Loading...</div>
                                    </div>
                                </div>
                            </div>

                        </div>

                        <!-- Two-column content grid (hidden for Me page) -->
                        <div class="overview-content-grid" id="personContentGrid">
                            <!-- Quick Facts - Left Column -->
                            <div class="quick-facts-section overview-panel">
                                <div class="overview-panel-header">
                                    <span class="overview-panel-title">Quick Facts</span>
                                    <button class="extract-facts-btn" id="extractFactsBtn" onclick="extractFacts('sonnet')">
                                        <span>Extract Facts</span>
                                    </button>
                                </div>
                                <div class="facts-categories" id="factsContainer">
                                    <div class="facts-empty">No facts extracted yet. Click "Extract Facts" to analyze interactions.</div>
                                </div>
                            </div>

                            <!-- Contact & Notes - Right Column -->
                            <div style="display: flex; flex-direction: column; gap: 1rem;">
                                <!-- Contact Info -->
                                <div class="overview-panel">
                                    <div class="overview-panel-header">
                                        <span class="overview-panel-title">Contact</span>
                                    </div>
                                    <div class="contact-grid-compact" id="contactInfoCompact"></div>
                                </div>

                                <!-- Notes -->
                                <div class="notes-panel-compact">
                                    <div class="overview-panel-header" style="display: flex; justify-content: space-between; align-items: center;">
                                        <span class="overview-panel-title">Notes</span>
                                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                                            <span id="notesUnsavedIndicator" style="display: none; color: var(--warning); font-size: 0.75rem;">unsaved</span>
                                            <button id="notesSaveBtn" class="notes-save-btn" onclick="saveNotes()" style="display: none;">Save</button>
                                        </div>
                                    </div>
                                    <textarea class="notes-area" id="notesArea" placeholder="Add notes about this person..." oninput="onNotesInput()"></textarea>
                                </div>
                            </div>
                        </div>

                        <!-- Source entities footer (collapsed) -->
                        <div class="source-entities-footer" id="sourceEntitiesFooter">
                            <div class="source-entities-toggle-bar" onclick="toggleSourceEntities()">
                                <div class="source-entities-info">
                                    <span class="source-entities-label">Source Entities</span>
                                    <span class="source-entities-count-badge" id="sourceEntitiesCount">0</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 0.75rem;">
                                    <button class="split-btn" onclick="event.stopPropagation(); openSplitModal()">Split Sources</button>
                                    <span class="source-entities-chevron" id="sourceEntitiesToggle">â–¼</span>
                                </div>
                            </div>
                            <div class="source-entities-expanded-content">
                                <div class="source-entities-list" id="sourceEntitiesList"></div>
                            </div>
                        </div>

                        <!-- Hidden elements for backwards compatibility -->
                        <div style="display:none">
                            <div id="strengthBarFill"></div>
                            <div id="strengthComponents"></div>
                            <div id="contactInfo"></div>
                            <div id="statEmails"></div>
                            <div id="statMeetings"></div>
                            <div id="statMessages"></div>
                            <div id="statNotes"></div>
                        </div>
                    </div>

                    <div id="tabTimeline" class="tab-content" style="display:none">
                        <div class="timeline-filters" id="timelineFilters">
                            <span class="timeline-count" id="timelineCount" title="Interactions matching current filters">0</span>
                            <div class="timeline-filter-chip active" data-source="all" onclick="filterTimeline('all')">All</div>
                            <div class="timeline-filter-chip" data-source="gmail" id="filterGmail" onclick="filterTimeline('gmail')">ðŸ“§ Emails</div>
                            <div class="timeline-filter-chip" data-source="calendar" id="filterCalendar" onclick="filterTimeline('calendar')">ðŸ“… Events</div>
                            <div class="timeline-filter-chip" data-source="messages" id="filterMessages" onclick="filterTimeline('messages')">ðŸ’¬ Messages</div>
                            <div class="timeline-filter-chip" data-source="phone" id="filterPhone" onclick="filterTimeline('phone')">ðŸ“ž Calls</div>
                            <div class="timeline-filter-chip" data-source="slack" id="filterSlack" onclick="filterTimeline('slack')">ðŸ’¼ Slack</div>
                            <div class="timeline-filter-chip" data-source="notes" id="filterNotes" onclick="filterTimeline('notes')">ðŸ“ Notes</div>
                            <div class="timeline-filter-chip" data-source="photos" id="filterPhotos" onclick="filterTimeline('photos')">ðŸ“· Photos</div>
                            <div class="timeline-date-range">
                                <label>From:</label>
                                <input type="date" id="timelineDateFrom" onchange="applyTimelineDateRange()">
                                <label>To:</label>
                                <input type="date" id="timelineDateTo" onchange="applyTimelineDateRange()">
                                <button onclick="clearTimelineDateRange()" id="clearDateRangeBtn" style="display: none;">Clear</button>
                            </div>
                        </div>
                        <div class="timeline" id="timelineContainer">
                            <div class="loading">Loading timeline...</div>
                        </div>
                    </div>

                    <div id="tabGraph" class="tab-content" style="display:none">
                        <div class="graph-controls">
                            <!-- Primary row: always visible -->
                            <div class="graph-controls-primary">
                                <button class="graph-btn" onclick="resetGraphZoom()">Reset Zoom</button>
                                <div class="graph-slider-container">
                                    <label for="edgeStrengthSlider">1stÂ° Weight:</label>
                                    <input type="range" id="edgeStrengthSlider" min="0" max="100" value="50" oninput="updateEdgeVisibility(this.value)">
                                    <span id="edgeStrengthValue">50%</span>
                                </div>
                                <div class="graph-slider-container" id="secondDegreeSliderContainer" style="display:none">
                                    <label for="secondDegreeSlider">2ndÂ° Weight:</label>
                                    <input type="range" id="secondDegreeSlider" min="0" max="100" value="30" oninput="updateSecondDegreeWeight(this.value)">
                                    <span id="secondDegreeValue">30%</span>
                                </div>
                                <div class="graph-degree-toggle">
                                    <label>Show:</label>
                                    <select id="degreeFilter" onchange="updateDegreeFilter(this.value)">
                                        <option value="all">1st & 2nd Degree</option>
                                        <option value="first" selected>1st Degree Only</option>
                                    </select>
                                </div>
                                <button class="graph-refresh-btn" onclick="refreshGraphLayout()" title="Refresh layout">
                                    â†»
                                </button>
                                <button class="graph-btn graph-fullscreen-toggle" onclick="toggleGraphFullscreen()" title="Fullscreen">
                                    <span class="fullscreen-icon">â›¶</span>
                                </button>
                                <button class="graph-expand-btn" onclick="toggleGraphFiltersExpansion(event)">
                                    More <span class="expand-arrow">â–¼</span>
                                </button>
                            </div>
                            <!-- Expansion row: hidden by default -->
                            <div class="graph-controls-expansion" id="graphControlsExpansion">
                                <div class="graph-source-filter">
                                    <label>Sources:</label>
                                    <div class="source-filter-dropdown" id="sourceFilterDropdown">
                                        <button class="source-filter-btn" onclick="toggleSourceFilter()">
                                            <span id="sourceFilterLabel">All Sources</span>
                                            <span class="dropdown-arrow">â–¼</span>
                                        </button>
                                        <div class="source-filter-options" id="sourceFilterOptions">
                                            <label class="source-option">
                                                <input type="checkbox" value="calendar" checked onchange="updateSourceFilter()">
                                                <span class="source-icon">ðŸ“…</span> Calendar
                                            </label>
                                            <label class="source-option">
                                                <input type="checkbox" value="email" checked onchange="updateSourceFilter()">
                                                <span class="source-icon">ðŸ“§</span> Email
                                            </label>
                                            <label class="source-option">
                                                <input type="checkbox" value="imessage" checked onchange="updateSourceFilter()">
                                                <span class="source-icon">ðŸ’¬</span> iMessage
                                            </label>
                                            <label class="source-option">
                                                <input type="checkbox" value="whatsapp" checked onchange="updateSourceFilter()">
                                                <span class="source-icon">ðŸ“±</span> WhatsApp
                                            </label>
                                            <label class="source-option">
                                                <input type="checkbox" value="slack" checked onchange="updateSourceFilter()">
                                                <span class="source-icon">ðŸ’¼</span> Slack
                                            </label>
                                            <label class="source-option">
                                                <input type="checkbox" value="phone" checked onchange="updateSourceFilter()">
                                                <span class="source-icon">ðŸ“ž</span> Phone
                                            </label>
                                            <label class="source-option">
                                                <input type="checkbox" value="linkedin" checked onchange="updateSourceFilter()">
                                                <span class="source-icon">ðŸ”—</span> LinkedIn
                                            </label>
                                            <label class="source-option">
                                                <input type="checkbox" value="photos" checked onchange="updateSourceFilter()">
                                                <span class="source-icon">ðŸ“·</span> Photos
                                            </label>
                                        </div>
                                    </div>
                                </div>
                                <div class="graph-category-filter">
                                    <label>Category:</label>
                                    <div class="category-filter-dropdown" id="categoryFilterDropdown">
                                        <button class="source-filter-btn" onclick="toggleCategoryFilter()">
                                            <span id="categoryFilterLabel">3 selected</span>
                                            <span class="dropdown-arrow">â–¼</span>
                                        </button>
                                        <div class="source-filter-options" id="categoryFilterOptions">
                                            <label class="source-option">
                                                <input type="checkbox" value="self" checked onchange="updateCategoryFilter()">
                                                <span class="category-dot" style="background: #ffffff; border: 1px solid #666;"></span> Me
                                            </label>
                                            <label class="source-option">
                                                <input type="checkbox" value="family" checked onchange="updateCategoryFilter()">
                                                <span class="category-dot" style="background: #daa520;"></span> Family
                                            </label>
                                            <label class="source-option">
                                                <input type="checkbox" value="work" onchange="updateCategoryFilter()">
                                                <span class="category-dot" style="background: #4f46e5;"></span> Work
                                            </label>
                                            <label class="source-option">
                                                <input type="checkbox" value="personal" checked onchange="updateCategoryFilter()">
                                                <span class="category-dot" style="background: #00bcd4;"></span> Personal
                                            </label>
                                        </div>
                                    </div>
                                </div>
                                <div class="graph-dunbar-filter">
                                    <label>Dunbar:</label>
                                    <div class="dunbar-filter-dropdown" id="dunbarFilterDropdown">
                                        <button class="source-filter-btn" onclick="toggleDunbarFilter()">
                                            <span id="dunbarFilterLabel">All</span>
                                            <span class="dropdown-arrow">â–¼</span>
                                        </button>
                                        <div class="source-filter-options" id="dunbarFilterOptions">
                                            <label class="source-option">
                                                <input type="checkbox" value="0" checked onchange="updateDunbarFilter()">
                                                <span class="category-dot" style="background: #e94560;"></span> 0: Intimate
                                            </label>
                                            <label class="source-option">
                                                <input type="checkbox" value="1" checked onchange="updateDunbarFilter()">
                                                <span class="category-dot" style="background: #ff6b6b;"></span> 1: Close
                                            </label>
                                            <label class="source-option">
                                                <input type="checkbox" value="2" checked onchange="updateDunbarFilter()">
                                                <span class="category-dot" style="background: #ffa502;"></span> 2: Good Friends
                                            </label>
                                            <label class="source-option">
                                                <input type="checkbox" value="3" checked onchange="updateDunbarFilter()">
                                                <span class="category-dot" style="background: #2ed573;"></span> 3: Friends
                                            </label>
                                            <label class="source-option">
                                                <input type="checkbox" value="4" checked onchange="updateDunbarFilter()">
                                                <span class="category-dot" style="background: #1e90ff;"></span> 4: Acquaintances
                                            </label>
                                            <label class="source-option">
                                                <input type="checkbox" value="5" checked onchange="updateDunbarFilter()">
                                                <span class="category-dot" style="background: #5352ed;"></span> 5: Known
                                            </label>
                                            <label class="source-option">
                                                <input type="checkbox" value="6+" checked onchange="updateDunbarFilter()">
                                                <span class="category-dot" style="background: #747d8c;"></span> 6+: Familiar/Contacts
                                            </label>
                                        </div>
                                    </div>
                                </div>
                                <div class="graph-node-sizing">
                                    <label>Node Size:</label>
                                    <div class="node-sizing-toggle">
                                        <button class="sizing-option active" data-mode="strength" onclick="setNodeSizingMode('strength')">Strength</button>
                                        <button class="sizing-option" data-mode="centrality" onclick="setNodeSizingMode('centrality')">Centrality</button>
                                    </div>
                                </div>
                                <div class="graph-layout-tuning">
                                    <button class="tuning-toggle" onclick="toggleLayoutTuning()">âš™ Layout</button>
                                    <div class="tuning-sliders" id="tuningSliders">
                                        <div class="tuning-slider">
                                            <label>Center repel:</label>
                                            <input type="range" id="centerRepelSlider" min="500" max="6000" value="1000" oninput="updateLayoutTuning()">
                                            <span id="centerRepelValue">1000</span>
                                        </div>
                                        <div class="tuning-slider">
                                            <label>1stÂ° repel:</label>
                                            <input type="range" id="firstRepelSlider" min="250" max="3000" value="1300" oninput="updateLayoutTuning()">
                                            <span id="firstRepelValue">1300</span>
                                        </div>
                                        <div class="tuning-slider">
                                            <label>2ndÂ° repel:</label>
                                            <input type="range" id="secondRepelSlider" min="100" max="1500" value="900" oninput="updateLayoutTuning()">
                                            <span id="secondRepelValue">900</span>
                                        </div>
                                        <div class="tuning-slider">
                                            <label>Range:</label>
                                            <input type="range" id="repelRangeSlider" min="400" max="2500" value="900" oninput="updateLayoutTuning()">
                                            <span id="repelRangeValue">900</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="graph-wrapper">
                            <div id="graphContainer" class="graph-container">
                                <div class="loading">Loading graph...</div>
                            </div>
                            <div id="edgePanel" class="edge-panel">
                                <div class="edge-panel-header">
                                    <div class="edge-panel-title">Connection Details</div>
                                    <div class="edge-panel-header-actions">
                                        <button class="edge-panel-copy" onclick="copyEdgeId()" title="Copy edge ID">
                                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                            </svg>
                                        </button>
                                        <button class="edge-panel-close" onclick="closeEdgePanel()">&times;</button>
                                    </div>
                                </div>
                                <div class="edge-panel-people">
                                    <span class="edge-panel-person" id="edgePanelPersonA" onclick="navigateToEdgePerson('a')">Person A</span>
                                    <span class="edge-panel-connector">&harr;</span>
                                    <span class="edge-panel-person" id="edgePanelPersonB" onclick="navigateToEdgePerson('b')">Person B</span>
                                </div>
                                <div class="edge-panel-stat">
                                    <span class="edge-panel-stat-label">Edge Weight</span>
                                    <span class="edge-panel-stat-value" id="edgePanelWeight">0</span>
                                </div>
                                <div class="edge-panel-section-title">Source Breakdown</div>
                                <div class="edge-panel-stat">
                                    <span class="edge-panel-stat-label">ðŸ“… Calendar Events</span>
                                    <span class="edge-panel-stat-value" id="edgePanelEvents">0</span>
                                </div>
                                <div class="edge-panel-stat">
                                    <span class="edge-panel-stat-label">ðŸ“§ Email Threads</span>
                                    <span class="edge-panel-stat-value" id="edgePanelThreads">0</span>
                                </div>
                                <div class="edge-panel-stat">
                                    <span class="edge-panel-stat-label">ðŸ’¬ iMessage</span>
                                    <span class="edge-panel-stat-value" id="edgePanelMessages">0</span>
                                </div>
                                <div class="edge-panel-stat">
                                    <span class="edge-panel-stat-label">ðŸ“± WhatsApp</span>
                                    <span class="edge-panel-stat-value" id="edgePanelWhatsapp">0</span>
                                </div>
                                <div class="edge-panel-stat">
                                    <span class="edge-panel-stat-label">ðŸ’¼ Slack DMs</span>
                                    <span class="edge-panel-stat-value" id="edgePanelSlack">0</span>
                                </div>
                                <div class="edge-panel-stat">
                                    <span class="edge-panel-stat-label">ðŸ“ž Phone Calls</span>
                                    <span class="edge-panel-stat-value" id="edgePanelPhone">0</span>
                                </div>
                                <div class="edge-panel-stat">
                                    <span class="edge-panel-stat-label">ðŸ“· Photos</span>
                                    <span class="edge-panel-stat-value" id="edgePanelPhotos">0</span>
                                </div>
                                <div class="edge-panel-stat">
                                    <span class="edge-panel-stat-label">ðŸ”— LinkedIn</span>
                                    <span class="edge-panel-stat-value" id="edgePanelLinkedin">â€”</span>
                                </div>
                                <div class="edge-panel-section-title">Timing</div>
                                <div class="edge-panel-stat">
                                    <span class="edge-panel-stat-label">First Seen Together</span>
                                    <span class="edge-panel-stat-value" id="edgePanelFirstSeen">â€”</span>
                                </div>
                                <div class="edge-panel-stat">
                                    <span class="edge-panel-stat-label">Last Seen Together</span>
                                    <span class="edge-panel-stat-value" id="edgePanelLastSeen">â€”</span>
                                </div>
                                <div class="edge-panel-contexts" id="edgePanelContexts">
                                    <div class="edge-panel-contexts-title">Shared Contexts</div>
                                    <div class="edge-panel-context-tags" id="edgePanelContextTags"></div>
                                </div>
                            </div>
                            <!-- Node Details Panel (shown on single-click of a node) -->
                            <div id="nodePanel" class="edge-panel node-panel">
                                <div class="edge-panel-header">
                                    <div class="edge-panel-title" id="nodePanelTitle">Person Details</div>
                                    <div class="edge-panel-header-actions">
                                        <button class="edge-panel-copy" onclick="copyPersonId()" title="Copy person ID">
                                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                            </svg>
                                        </button>
                                        <button class="edge-panel-close" onclick="closeNodePanel()">&times;</button>
                                    </div>
                                </div>
                                <div class="node-panel-name" id="nodePanelName">Person Name</div>
                                <div class="node-panel-category" id="nodePanelCategory">Category</div>
                                <!-- Relationship stats - hidden for self -->
                                <div id="nodePanelRelationshipSection">
                                    <div class="edge-panel-stat">
                                        <span class="edge-panel-stat-label">Relationship Strength</span>
                                        <span class="edge-panel-stat-value" id="nodePanelStrength">0%</span>
                                    </div>
                                    <div class="edge-panel-stat">
                                        <span class="edge-panel-stat-label">Dunbar Circle</span>
                                        <span class="edge-panel-stat-value" id="nodePanelDunbar">â€”</span>
                                    </div>
                                </div>
                                <div class="edge-panel-section-title">Interactions</div>
                                <div class="edge-panel-stat clickable-stat" onclick="navigateToFilteredTimeline('gmail')">
                                    <span class="edge-panel-stat-label">ðŸ“§ Emails</span>
                                    <span class="edge-panel-stat-value" id="nodePanelEmails">0</span>
                                </div>
                                <div class="edge-panel-stat clickable-stat" onclick="navigateToFilteredTimeline('calendar')">
                                    <span class="edge-panel-stat-label">ðŸ“… Meetings</span>
                                    <span class="edge-panel-stat-value" id="nodePanelMeetings">0</span>
                                </div>
                                <div class="edge-panel-stat clickable-stat" onclick="navigateToFilteredTimeline('messages')">
                                    <span class="edge-panel-stat-label">ðŸ’¬ Messages</span>
                                    <span class="edge-panel-stat-value" id="nodePanelMsgs">0</span>
                                </div>
                                <div class="edge-panel-stat clickable-stat" onclick="navigateToFilteredTimeline('notes')">
                                    <span class="edge-panel-stat-label">ðŸ“ Note Mentions</span>
                                    <span class="edge-panel-stat-value" id="nodePanelMentions">0</span>
                                </div>
                                <!-- Timing section - hidden for self -->
                                <div id="nodePanelTimingSection">
                                    <div class="edge-panel-section-title">Timing</div>
                                    <div class="edge-panel-stat">
                                        <span class="edge-panel-stat-label">First Seen</span>
                                        <span class="edge-panel-stat-value" id="nodePanelFirstSeen">â€”</span>
                                    </div>
                                    <div class="edge-panel-stat">
                                        <span class="edge-panel-stat-label">Last Seen</span>
                                        <span class="edge-panel-stat-value" id="nodePanelLastSeen">â€”</span>
                                    </div>
                                </div>
                                <button class="node-panel-goto-btn" onclick="navigateFromNodePanel()">
                                    Go to Profile â†’
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Merge Modal -->
    <div class="merge-modal" id="mergeModal">
        <div class="merge-modal-content">
            <div class="merge-modal-header">Merge People</div>
            <div class="merge-modal-section">
                <div class="merge-modal-label">Select the primary record (this person will be kept):</div>
                <div class="merge-primary-select" id="mergePrimarySelect"></div>
            </div>
            <div class="merge-modal-section">
                <div class="merge-modal-label">The following will be merged into the primary:</div>
                <ul id="mergeSecondaryList" style="color: var(--text-secondary); font-size: 0.875rem; padding-left: 1.25rem;"></ul>
            </div>
            <div class="merge-modal-actions">
                <button class="merge-cancel-btn" onclick="closeMergeModal()">Cancel</button>
                <button class="merge-confirm-btn" id="mergeConfirmBtn" onclick="confirmMerge()" disabled>Merge</button>
            </div>
        </div>
    </div>

    <!-- Bulk Tag Modal -->
    <div class="bulk-tag-modal" id="bulkTagModal" style="display: none;">
        <div class="bulk-tag-content">
            <h3>Add Tag to <span id="bulkTagCount">0</span> People</h3>
            <input type="text" class="bulk-tag-input" id="bulkTagInput" placeholder="Enter tag name..." onkeydown="if(event.key==='Enter')applyBulkTag()">
            <div class="tag-suggestions" id="tagSuggestions"></div>
            <div class="bulk-tag-actions">
                <button class="bulk-tag-cancel" onclick="closeBulkTagModal()">Cancel</button>
                <button class="bulk-tag-apply" onclick="applyBulkTag()">Apply Tag</button>
            </div>
        </div>
    </div>

    <!-- Split Modal -->
    <div class="split-modal" id="splitModal">
        <div class="split-modal-content">
            <div class="split-modal-header">Split Sources</div>
            <div class="split-modal-section">
                <div class="split-modal-label">
                    Select sources that don't belong to <strong id="splitFromPersonName"></strong>:
                </div>
                <div class="split-source-list" id="splitSourceList">
                    <div class="loading">Loading sources...</div>
                </div>
            </div>
            <div class="split-target-section">
                <div class="split-modal-label">Move selected sources to:</div>
                <div class="split-target-options">
                    <label class="split-target-option" onclick="setSplitTarget('existing')">
                        <input type="radio" name="splitTarget" value="existing">
                        Existing person
                    </label>
                    <div id="splitExistingSection" style="display: none; margin-left: 1.5rem;">
                        <input type="text" class="split-person-search" id="splitPersonSearch"
                               placeholder="Search for person..." oninput="searchSplitTarget()">
                        <div class="split-person-results" id="splitPersonResults"></div>
                    </div>
                    <label class="split-target-option" onclick="setSplitTarget('new')">
                        <input type="radio" name="splitTarget" value="new">
                        Create new person
                    </label>
                    <div id="splitNewSection" style="display: none; margin-left: 1.5rem;">
                        <input type="text" class="split-new-name-input" id="splitNewPersonName"
                               placeholder="Enter new person's name...">
                    </div>
                </div>
            </div>
            <div class="split-modal-section" style="margin-top: 1rem;">
                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                    <input type="checkbox" id="splitCreateOverrides" checked>
                    <span style="font-size: 0.875rem;">Create disambiguation rules to prevent future mis-linking</span>
                </label>
            </div>
            <div class="split-modal-actions">
                <button class="split-cancel-btn" onclick="closeSplitModal()">Cancel</button>
                <button class="split-confirm-btn" id="splitConfirmBtn" onclick="confirmSplit()" disabled>
                    Split <span id="splitCount">0</span> Sources
                </button>
            </div>
        </div>
    </div>

    <!-- Cleanup Modal -->
    <div class="cleanup-modal" id="cleanupModal">
        <div class="cleanup-modal-content">
            <div class="cleanup-modal-header">
                <span class="cleanup-modal-title">ðŸ§¹ Entity Cleanup Queue</span>
                <button class="cleanup-close-btn" onclick="closeCleanupModal()">&times;</button>
            </div>
            <div class="cleanup-tabs">
                <button class="cleanup-tab active" data-tab="duplicates" onclick="switchCleanupTab('duplicates')">
                    Duplicates <span class="cleanup-tab-badge" id="cleanupDuplicatesBadge">0</span>
                </button>
                <button class="cleanup-tab" data-tab="non_human" onclick="switchCleanupTab('non_human')">
                    Non-Human <span class="cleanup-tab-badge" id="cleanupNonHumanBadge">0</span>
                </button>
                <button class="cleanup-tab" data-tab="over_merged" onclick="switchCleanupTab('over_merged')">
                    Over-Merged <span class="cleanup-tab-badge" id="cleanupOverMergedBadge">0</span>
                </button>
            </div>
            <div class="cleanup-list" id="cleanupList">
                <div class="cleanup-loading">Loading cleanup queue...</div>
            </div>
        </div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // State
        let people = [];
        let selectedPersonId = null;
        let searchQuery = '';
        // People list filters (multi-select)
        let peopleCategoryFilters = new Set(['self', 'family', 'personal']);  // Work excluded by default
        let peopleDunbarFilters = new Set(['0', '1', '2', '3', '4', '5', '6+']);
        let peopleTagFilters = new Set();  // Empty = all tags (no filter)
        let allAvailableTags = [];  // All tags from loaded people
        let selectedForMerge = new Set();  // IDs selected for merge
        let mergePrimaryId = null;  // Primary person for merge
        let dunbarCircleMap = new Map();  // Map person ID to Dunbar circle
        let dunbarCirclesInitialized = false;  // Track if global circles have been calculated
        let meInteractionsCache = null;  // Cache for "Me" page interactions
        let meInteractionsCacheYears = null; // Track which years setting the cache was loaded for
        // Config loaded from API
        let PARTNER_NAME = '';
        let FAMILY_DEFAULT_SELECTED_IDS = [];

        // ===============================
        // Mobile Navigation
        // ===============================

        function isMobileView() {
            return window.innerWidth <= 768;
        }

        function togglePeoplePanel() {
            const panel = document.querySelector('.people-list-panel');
            const overlay = document.getElementById('sidebarOverlayCrm');
            const menuBtn = document.getElementById('crmMenuBtn');

            if (panel && overlay) {
                const isVisible = panel.classList.toggle('visible');
                overlay.classList.toggle('visible', isVisible);
                if (menuBtn) menuBtn.classList.toggle('active', isVisible);
            }
        }

        function closePeoplePanel() {
            const panel = document.querySelector('.people-list-panel');
            const overlay = document.getElementById('sidebarOverlayCrm');
            const menuBtn = document.getElementById('crmMenuBtn');

            if (panel) panel.classList.remove('visible');
            if (overlay) overlay.classList.remove('visible');
            if (menuBtn) menuBtn.classList.remove('active');
        }

        // Handle window resize - close mobile panel when resizing to desktop
        window.addEventListener('resize', () => {
            if (!isMobileView()) {
                closePeoplePanel();
            }
        });

        // Swipe gesture handling for sidebar (swipe left to close only)
        // Note: Swipe from left edge to open is not used because it conflicts
        // with iOS Safari's native back navigation gesture
        let touchStartX = 0;
        let touchStartY = 0;
        let isSwiping = false;
        const SWIPE_THRESHOLD = 50;

        function initSwipeGestures() {
            const panel = document.querySelector('.people-list-panel');
            const overlay = document.getElementById('sidebarOverlayCrm');

            // Only track swipes that start on the panel or overlay (to close)
            const swipeTargets = [panel, overlay].filter(Boolean);

            swipeTargets.forEach(target => {
                target.addEventListener('touchstart', (e) => {
                    if (!isMobileView()) return;
                    if (!panel?.classList.contains('visible')) return;

                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    isSwiping = true;
                }, { passive: true });

                target.addEventListener('touchend', (e) => {
                    if (!isSwiping || !isMobileView()) {
                        isSwiping = false;
                        return;
                    }

                    const touchEndX = e.changedTouches[0].clientX;
                    const touchEndY = e.changedTouches[0].clientY;
                    const deltaX = touchEndX - touchStartX;
                    const deltaY = Math.abs(touchEndY - touchStartY);

                    // Swipe left to close (horizontal swipe must be dominant)
                    if (deltaX < -SWIPE_THRESHOLD && Math.abs(deltaX) > deltaY) {
                        closePeoplePanel();
                    }

                    isSwiping = false;
                }, { passive: true });
            });
        }

        // Initialize swipe gestures when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initSwipeGestures);
        } else {
            initSwipeGestures();
        }

        // Mobile details drawer toggle
        function toggleMobileDetails() {
            const drawer = document.getElementById('mobileDetailsDrawer');
            if (drawer) {
                drawer.classList.toggle('expanded');
            }
        }

        // Update mobile details content when person is loaded
        function updateMobileDetails(person) {
            const birthdayRow = document.getElementById('mobileDetailsBirthday');
            const contactRow = document.getElementById('mobileDetailsContact');
            const tagsRow = document.getElementById('mobileDetailsTags');
            const summary = document.getElementById('mobileDetailsSummary');

            if (!birthdayRow || !contactRow || !tagsRow) return;

            // Birthday (format: "MM-DD")
            if (person.birthday) {
                const [month, day] = person.birthday.split('-').map(Number);
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const formatted = `${monthNames[month - 1]} ${day}`;
                birthdayRow.innerHTML = `<span>ðŸŽ‚ ${formatted}</span>`;
            } else {
                birthdayRow.innerHTML = '';
            }

            // Contact info (arrays: emails, phone_numbers)
            let contactHtml = '';
            const email = person.emails?.[0];
            const phone = person.phone_numbers?.[0];
            if (email) {
                contactHtml += `<a href="mailto:${email}">ðŸ“§ ${email}</a>`;
            }
            if (phone) {
                contactHtml += `<a href="tel:${phone}">ðŸ“± ${phone}</a>`;
            }
            contactRow.innerHTML = contactHtml;

            // Tags
            if (person.tags && person.tags.length > 0) {
                tagsRow.innerHTML = person.tags.map(tag =>
                    `<span class="tag-chip">${tag}</span>`
                ).join('');
            } else {
                tagsRow.innerHTML = '';
            }

            // Update summary text
            const parts = [];
            if (person.birthday) parts.push('Birthday');
            if (email || phone) parts.push('Contact');
            if (person.tags?.length) parts.push(`${person.tags.length} tag${person.tags.length > 1 ? 's' : ''}`);
            summary.textContent = parts.length > 0 ? parts.join(' Â· ') : 'No details';

            // Collapse drawer when switching people
            const drawer = document.getElementById('mobileDetailsDrawer');
            if (drawer) drawer.classList.remove('expanded');
        }

        // ===============================
        // Performance Caching Infrastructure
        // ===============================

        // Person Detail Cache - LRU cache for person data to avoid re-fetching
        const personDetailCache = new Map();
        const PERSON_CACHE_MAX = 50;
        const PERSON_CACHE_TTL = 5 * 60 * 1000; // 5 minutes

        function getCachedPerson(personId) {
            const cached = personDetailCache.get(personId);
            if (cached && Date.now() - cached.timestamp < PERSON_CACHE_TTL) {
                console.log(`[Cache] Person ${personId} hit`);
                return cached.data;
            }
            if (cached) {
                personDetailCache.delete(personId);
                console.log(`[Cache] Person ${personId} expired`);
            }
            return null;
        }

        function setCachedPerson(personId, data) {
            // LRU eviction - remove oldest if at capacity
            if (personDetailCache.size >= PERSON_CACHE_MAX) {
                const oldest = personDetailCache.keys().next().value;
                personDetailCache.delete(oldest);
                console.log(`[Cache] Evicted oldest person ${oldest}`);
            }
            personDetailCache.set(personId, { data: structuredClone(data), timestamp: Date.now() });
        }

        function invalidatePersonCache(personId) {
            if (personDetailCache.delete(personId)) {
                console.log(`[Cache] Person ${personId} invalidated`);
            }
        }

        // Timeline Cache - per-person cache to enable client-side source filtering
        const timelineCache = new Map();
        const TIMELINE_CACHE_TTL = 5 * 60 * 1000; // 5 minutes

        function getCachedTimeline(personId, dateKey) {
            const cacheKey = `${personId}:${dateKey || 'all'}`;
            const cached = timelineCache.get(cacheKey);
            if (cached && Date.now() - cached.timestamp < TIMELINE_CACHE_TTL) {
                console.log(`[Cache] Timeline ${cacheKey} hit`);
                return cached.data;
            }
            if (cached) {
                timelineCache.delete(cacheKey);
                console.log(`[Cache] Timeline ${cacheKey} expired`);
            }
            return null;
        }

        function setCachedTimeline(personId, dateKey, data) {
            const cacheKey = `${personId}:${dateKey || 'all'}`;
            // Keep max 20 timeline caches
            if (timelineCache.size >= 20) {
                const oldest = timelineCache.keys().next().value;
                timelineCache.delete(oldest);
            }
            timelineCache.set(cacheKey, { data: structuredClone(data), timestamp: Date.now() });
        }

        function invalidateTimelineCache(personId) {
            // Remove all timeline entries for this person
            for (const key of timelineCache.keys()) {
                if (key.startsWith(personId + ':')) {
                    timelineCache.delete(key);
                }
            }
        }

        // Search Cache - cache recent search results
        const searchCache = new Map();
        const SEARCH_CACHE_MAX = 10;
        const SEARCH_CACHE_TTL = 2 * 60 * 1000; // 2 minutes

        function getSearchCacheKey(query, dunbarFilters, tagFilters) {
            const dunbarKey = [...dunbarFilters].sort().join(',');
            const tagKey = tagFilters ? [...tagFilters].sort().join(',') : '';
            return `${query}:${dunbarKey}:${tagKey}`;
        }

        function getCachedSearch(cacheKey) {
            const cached = searchCache.get(cacheKey);
            if (cached && Date.now() - cached.timestamp < SEARCH_CACHE_TTL) {
                console.log(`[Cache] Search "${cacheKey}" hit`);
                return cached.data;
            }
            if (cached) {
                searchCache.delete(cacheKey);
            }
            return null;
        }

        function setCachedSearch(cacheKey, data) {
            if (searchCache.size >= SEARCH_CACHE_MAX) {
                const oldest = searchCache.keys().next().value;
                searchCache.delete(oldest);
            }
            searchCache.set(cacheKey, { data: structuredClone(data), timestamp: Date.now() });
        }

        function clearSearchCache() {
            searchCache.clear();
            console.log('[Cache] Search cache cleared');
        }

        // Graph Weight Stats Cache - memoize weight calculations
        let graphWeightStatsCache = null;

        function getGraphWeightStats() {
            // Return cached if graphLinksAll reference hasn't changed
            if (graphWeightStatsCache && graphWeightStatsCache.sourceRef === graphLinksAll) {
                return graphWeightStatsCache;
            }

            if (!graphLinksAll || graphLinksAll.length === 0) {
                return { allWeights: [], maxWeight: 1, minWeight: 0, weightRange: 1 };
            }

            const allWeights = graphLinksAll.map(l => l.weight);
            const maxWeight = allWeights.reduce((a, b) => Math.max(a, b), 1);
            const minWeight = allWeights.reduce((a, b) => Math.min(a, b), Infinity);
            const weightRange = Math.max(1, maxWeight - minWeight);

            graphWeightStatsCache = { sourceRef: graphLinksAll, allWeights, maxWeight, minWeight, weightRange };
            console.log(`[Cache] Graph weight stats computed: ${allWeights.length} edges, range ${minWeight}-${maxWeight}`);
            return graphWeightStatsCache;
        }

        // ===============================
        // End Caching Infrastructure
        // ===============================

        // Dunbar Circle Configuration
        // Circle sizes: 0=3 (manual), 1=5, 2=15, 3=50, 4=150, 5=500, 6=1500, 7+=rest
        // myPersonId is loaded from API via loadCRMConfig()
        const DUNBAR_CONFIG = {
            myPersonId: '',  // Loaded from API
            manualCircleZero: [],  // Configure via relationship_overrides.json on server
            // Cumulative thresholds (excluding circle 0 manual entries and self)
            thresholds: [0, 5, 20, 70, 220, 720, 2220]  // Circle 1-6 boundaries
        };

        // Load CRM config from API (call early in init)
        async function loadCRMConfig() {
            try {
                const config = await api('/config');
                if (config.my_person_id) {
                    DUNBAR_CONFIG.myPersonId = config.my_person_id;
                    console.log('[Config] Loaded my_person_id:', config.my_person_id);
                }
                if (config.partner_person_id) {
                    PARTNER_PERSON_ID = config.partner_person_id;
                    console.log('[Config] Loaded partner_person_id:', config.partner_person_id);
                }
                if (config.partner_name) {
                    PARTNER_NAME = config.partner_name;
                    console.log('[Config] Loaded partner_name:', config.partner_name);
                }
                if (config.family_default_selected_ids && config.family_default_selected_ids.length > 0) {
                    FAMILY_DEFAULT_SELECTED_IDS = config.family_default_selected_ids;
                    console.log('[Config] Loaded family_default_selected_ids:', FAMILY_DEFAULT_SELECTED_IDS.length, 'IDs');
                }
            } catch (error) {
                console.warn('[Config] Failed to load CRM config:', error);
            }
        }

        // Initialize Dunbar circles globally (called once on page load with ALL people)
        async function initializeDunbarCircles() {
            if (dunbarCirclesInitialized) return;

            try {
                // Fetch ALL people sorted by strength to calculate global circles
                const data = await api('/people?sort=strength&limit=10000');
                const allPeople = data.people || [];

                console.log(`[Dunbar] Initializing with ${allPeople.length} people`);

                if (allPeople.length === 0) {
                    console.warn('[Dunbar] No people returned from API');
                    return;
                }

                calculateAndStoreDunbarCircles(allPeople);
                dunbarCirclesInitialized = true;
                console.log(`[Dunbar] Initialized map with ${dunbarCircleMap.size} entries`);
            } catch (error) {
                console.error('[Dunbar] Failed to initialize:', error);
            }
        }

        // Calculate Dunbar circles from a list of people and store in global map
        function calculateAndStoreDunbarCircles(peopleList) {
            // Sort by relationship strength descending
            const sorted = [...peopleList].sort((a, b) =>
                (b.relationship_strength || 0) - (a.relationship_strength || 0)
            );

            // Create a map for quick lookup
            const circleMap = new Map();

            // Assign circle 0 to self and manual entries
            circleMap.set(DUNBAR_CONFIG.myPersonId, 0);
            sorted.forEach(p => {
                if (DUNBAR_CONFIG.manualCircleZero.includes(p.canonical_name)) {
                    circleMap.set(p.id, 0);
                }
            });

            // Assign circles to remaining people based on rank
            let rank = 0;
            for (const person of sorted) {
                if (circleMap.has(person.id)) continue;  // Skip already assigned

                // Find which circle this rank falls into
                let circle = DUNBAR_CONFIG.thresholds.length;  // Default to outer circle
                for (let i = 0; i < DUNBAR_CONFIG.thresholds.length; i++) {
                    if (rank < DUNBAR_CONFIG.thresholds[i]) {
                        circle = i;
                        break;
                    }
                }
                circleMap.set(person.id, circle);
                rank++;
            }

            // Update global map
            dunbarCircleMap = circleMap;
        }

        // Apply pre-calculated Dunbar circles to a list of people
        // Uses pre-computed dunbar_circle from API, falls back to client calculation if missing
        function applyDunbarCircles(peopleList) {
            // Check if API provided pre-computed values
            const hasPrecomputed = peopleList.some(p => p.dunbar_circle !== undefined && p.dunbar_circle !== null);

            if (hasPrecomputed) {
                // Build dunbarCircleMap from API data for any code that still references it
                peopleList.forEach(p => {
                    if (p.dunbar_circle !== undefined && p.dunbar_circle !== null) {
                        dunbarCircleMap.set(p.id, p.dunbar_circle);
                    }
                });
                // Return as-is since circles are already set
                return peopleList;
            }

            // Fallback: calculate client-side if API didn't provide values
            console.warn('[Dunbar] No pre-computed circles from API, calculating client-side');
            if (dunbarCircleMap.size < 10 && peopleList.length > 10) {
                calculateAndStoreDunbarCircles(peopleList);
            }

            return peopleList.map(p => ({
                ...p,
                dunbar_circle: dunbarCircleMap.get(p.id) ?? 7
            }));
        }

        // Get Dunbar circle label for display
        function getDunbarCircleLabel(circle) {
            const labels = ['Intimate', 'Close', 'Good Friends', 'Friends', 'Acquaintances', 'Known', 'Familiar', 'Contacts'];
            return labels[circle] || 'Contacts';
        }

        // Get Dunbar circle size description (e.g., "Top 5")
        function getDunbarCircleSize(circle) {
            const sizes = ['Top 3', 'Top 5', 'Top 20', 'Top 70', 'Top 220', 'Top 720', 'Top 2220', '2220+'];
            return sizes[circle] || '2220+';
        }

        // API helpers
        async function api(path, options = {}) {
            const response = await fetch(`/api/crm${path}`, {
                headers: { 'Content-Type': 'application/json' },
                ...options
            });
            if (!response.ok) {
                throw new Error(`API error: ${response.status}`);
            }
            return response.json();
        }

        // ===============================
        // URL Routing
        // ===============================

        // Parse URL to get person ID and tab
        // Supports: /crm, /crm/{personId}, /crm/{personId}/{tab}, /me, /me/{tab}, /family, /relationship
        function parseUrl() {
            const path = window.location.pathname;

            // Handle /birthdays route
            if (path === '/birthdays' || path === '/birthdays/') {
                const params = new URLSearchParams(window.location.search);
                return {
                    personId: null,
                    tab: null,
                    isMe: false,
                    isFamily: false,
                    isRelationship: false,
                    isBirthdays: true,
                    birthdayFilter: params.get('day'),
                };
            }

            // Handle /relationship route (partner's dedicated page)
            if (path === '/relationship' || path === '/relationship/') {
                return {
                    personId: null,
                    tab: null,
                    isMe: false,
                    isFamily: false,
                    isRelationship: true,
                    isBirthdays: false,
                };
            }

            // Handle /family route
            if (path === '/family' || path === '/family/') {
                return {
                    personId: null,
                    tab: null,
                    isMe: false,
                    isFamily: true,
                    isRelationship: false,
                    isBirthdays: false,
                };
            }

            // Handle /me route (alias for owner's profile)
            const meMatch = path.match(/^\/me(?:\/([^\/]+))?/);
            if (meMatch) {
                return {
                    personId: DUNBAR_CONFIG.myPersonId,
                    tab: meMatch[1] || null,
                    isMe: true,
                    isFamily: false,
                    isRelationship: false,
                    isBirthdays: false,
                };
            }

            // Handle /crm/family route
            if (path === '/crm/family' || path === '/crm/family/') {
                return {
                    personId: null,
                    tab: null,
                    isMe: false,
                    isFamily: true,
                    isRelationship: false,
                    isBirthdays: false,
                };
            }

            // Handle /crm/relationship route
            if (path === '/crm/relationship' || path === '/crm/relationship/') {
                return {
                    personId: null,
                    tab: null,
                    isMe: false,
                    isFamily: false,
                    isRelationship: true,
                    isBirthdays: false,
                };
            }

            // Handle /crm routes
            const match = path.match(/^\/crm(?:\/([^\/]+))?(?:\/([^\/]+))?/);
            if (!match) return { personId: null, tab: null, isMe: false, isFamily: false, isRelationship: false, isBirthdays: false };

            const personId = match[1] || null;
            return {
                personId: personId,
                tab: match[2] || null,
                isMe: personId === DUNBAR_CONFIG.myPersonId,
                isFamily: false,
                isRelationship: false,
                isBirthdays: false,
            };
        }

        // Check if current view is the "Me" page (owner's profile)
        function isMyPage(personId = selectedPersonId) {
            return personId === DUNBAR_CONFIG.myPersonId;
        }

        // Update URL without reloading page
        function updateUrl(personId, tab, replace = false) {
            let path;
            // Use /me route for owner's profile
            if (personId === DUNBAR_CONFIG.myPersonId) {
                path = '/me';
                if (tab && tab !== 'overview') {
                    path += '/' + tab;
                }
            } else {
                path = '/crm';
                if (personId) {
                    path += '/' + personId;
                    if (tab && tab !== 'overview') {
                        path += '/' + tab;
                    }
                }
            }
            const method = replace ? 'replaceState' : 'pushState';
            history[method]({ personId, tab }, '', path);
        }

        // Handle browser back/forward navigation
        window.addEventListener('popstate', async (event) => {
            // Close any open panels when navigating
            closeEdgePanel();
            closeNodePanel();

            const { personId, tab, isFamily, isRelationship, isBirthdays, birthdayFilter } = parseUrl();
            if (isBirthdays) {
                // Show birthdays page
                showBirthdaysPage(birthdayFilter);
            } else if (isRelationship) {
                // Show relationship dashboard
                showRelationshipDashboard();
            } else if (isFamily) {
                // Show family dashboard
                showFamilyDashboard();
            } else if (personId) {
                // Hide birthdays page and show main container
                document.getElementById('birthdaysPage').style.display = 'none';
                document.getElementById('birthdaysPage').classList.remove('visible');
                document.querySelector('.main-container').style.display = 'flex';

                selectedPersonId = personId;
                renderPeopleList();
                await loadPersonDetail(personId, false);
                if (tab) {
                    await switchTab(tab, true); // true = don't update URL
                }
            } else {
                // Hide birthdays page and show main container
                document.getElementById('birthdaysPage').style.display = 'none';
                document.getElementById('birthdaysPage').classList.remove('visible');
                document.querySelector('.main-container').style.display = 'flex';

                // No person selected - show empty state
                selectedPersonId = null;
                renderPeopleList();
                document.getElementById('detailEmpty').style.display = 'flex';
                document.getElementById('detailContent').style.display = 'none';
            }
        });

        // Initialize - uses progressive loading for faster perceived performance
        async function init() {
            // Redirect /crm to /me (Me page is the default landing)
            if (window.location.pathname === '/crm' || window.location.pathname === '/crm/') {
                window.location.replace('/me');
                return;
            }

            // Load CRM config first (needed for myPersonId)
            await loadCRMConfig();

            // Check for birthdays today (non-blocking)
            checkAndShowBirthdayToast();

            // Check URL early to show special dashboards immediately (don't wait for loadPeople)
            const { personId, tab, isFamily, isRelationship, isBirthdays, birthdayFilter } = parseUrl();

            // For birthdays page, show immediately (standalone page, no people list needed)
            if (isBirthdays) {
                await showBirthdaysPage(birthdayFilter);
                return;
            }

            // For relationship page, show dashboard immediately (don't wait for people list)
            if (isRelationship) {
                // Load people/stats in background, show dashboard now
                loadPeople();
                loadStatistics();
                await showRelationshipDashboard();
                return;
            }

            // Progressive loading: start loading people/stats in parallel
            const peoplePromise = loadPeople();
            const statsPromise = loadStatistics();

            if (isFamily) {
                // Family dashboard needs people list
                await peoplePromise;
                await showFamilyDashboard();
            } else if (personId) {
                // Person detail page: load person immediately, don't wait for people list
                // This makes direct links to /crm/{personId} feel much faster
                if (tab) {
                    // Direct navigation to specific tab (e.g., /crm/{id}/timeline)
                    // Must await person load before switching tabs to avoid race condition
                    await selectPerson(personId, false, true);
                    await switchTab(tab, true);
                } else {
                    // Regular person page - non-blocking for faster perceived load
                    selectPerson(personId, false, true);
                }
                // Let people list finish loading in background
                await peoplePromise;
            } else {
                // Default: wait for people list
                await peoplePromise;
            }

            await statsPromise;
        }

        // Load people list (with search result caching)
        async function loadPeople() {
            const listEl = document.getElementById('peopleList');

            // Build cache key from search query and dunbar filters
            const cacheKey = getSearchCacheKey(searchQuery, peopleDunbarFilters, peopleTagFilters);
            const cached = getCachedSearch(cacheKey);

            if (cached) {
                // Cache hit - use cached results
                people = applyDunbarCircles(cached);
                people.sort((a, b) => {
                    const selfA = a.category === 'self' ? 0 : 1;
                    const selfB = b.category === 'self' ? 0 : 1;
                    if (selfA !== selfB) return selfA - selfB;
                    const circleA = a.dunbar_circle ?? 7;
                    const circleB = b.dunbar_circle ?? 7;
                    if (circleA !== circleB) return circleA - circleB;
                    return (b.relationship_strength || 0) - (a.relationship_strength || 0);
                });
                renderPeopleList();
                return;
            }

            listEl.innerHTML = '<div class="loading">Loading people...</div>';

            try {
                // Note: Dunbar circles are now pre-computed server-side
                // No need to fetch all 14k people - each person has dunbar_circle in API response

                let allPeople = [];

                // Check if search query contains OR operator (|)
                const searchTerms = searchQuery ? searchQuery.split('|').map(t => t.trim()).filter(t => t) : [''];

                // Fetch results for each search term in parallel
                // Note: We apply category filter client-side for multi-select flexibility
                // For dunbar circles, if only outer circles (5, 6+) are selected, pass to API
                const onlyOuterCircles = peopleDunbarFilters.size > 0 &&
                    [...peopleDunbarFilters].every(c => c === '5' || c === '6+');

                // If tag filters are active, pass to server for filtering
                const hasTagFilters = peopleTagFilters.size > 0 && peopleTagFilters.size < allAvailableTags.length;

                const fetchPromises = searchTerms.map(term => {
                    const params = new URLSearchParams();
                    if (term) params.set('q', term);
                    params.set('sort', 'strength');
                    params.set('limit', '300');
                    // If only outer circles selected, filter server-side to get relevant results
                    if (onlyOuterCircles) {
                        params.set('dunbar_circles', [...peopleDunbarFilters].join(','));
                    }
                    // If tag filters active, filter server-side to include people outside top 300
                    if (hasTagFilters) {
                        params.set('tags', [...peopleTagFilters].join(','));
                        params.set('limit', '1000');  // Increase limit for tag filtering
                    }
                    return api(`/people?${params}`);
                });

                const results = await Promise.all(fetchPromises);

                // Merge and deduplicate results by person ID
                const seenIds = new Set();
                for (const data of results) {
                    for (const person of data.people) {
                        if (!seenIds.has(person.id)) {
                            seenIds.add(person.id);
                            allPeople.push(person);
                        }
                    }
                }

                // Cache the raw merged results before applying dunbar circles
                setCachedSearch(cacheKey, allPeople);

                people = applyDunbarCircles(allPeople);
                // Sort: self first, then by Dunbar circle, then by relationship strength
                people.sort((a, b) => {
                    const selfA = a.category === 'self' ? 0 : 1;
                    const selfB = b.category === 'self' ? 0 : 1;
                    if (selfA !== selfB) return selfA - selfB;
                    const circleA = a.dunbar_circle ?? 7;
                    const circleB = b.dunbar_circle ?? 7;
                    if (circleA !== circleB) return circleA - circleB;
                    return (b.relationship_strength || 0) - (a.relationship_strength || 0);
                });
                renderPeopleList();
            } catch (error) {
                console.error('Failed to load people:', error);
                listEl.innerHTML = '<div class="empty-state"><div class="empty-state-icon">âš ï¸</div><p>Failed to load people</p></div>';
            }
        }

        // Load statistics
        async function loadStatistics() {
            try {
                const data = await api('/statistics');
                document.getElementById('totalPeople').textContent = data.total_people;
            } catch (error) {
                console.error('Failed to load statistics:', error);
            }
        }

        // Render people list
        function renderPeopleList() {
            const listEl = document.getElementById('peopleList');

            // Collect all tags from people for the filter dropdown
            collectAllTags();

            // Apply category, dunbar, and tag filters
            const allCategoriesSelected = peopleCategoryFilters.size === 4;
            const allDunbarSelected = peopleDunbarFilters.size === 7;
            const noTagFilterActive = peopleTagFilters.size === 0;

            const filteredPeople = people.filter(person => {
                // Category filter
                if (!allCategoriesSelected) {
                    const category = person.category || 'personal';  // Default to personal if no category
                    if (!peopleCategoryFilters.has(category)) return false;
                }

                // Dunbar filter
                if (!allDunbarSelected) {
                    const dunbar = person.dunbar_circle ?? 7;
                    const dunbarKey = dunbar >= 6 ? '6+' : String(dunbar);
                    if (!peopleDunbarFilters.has(dunbarKey)) return false;
                }

                // Tag filter (if any tags selected)
                if (!noTagFilterActive) {
                    const personTags = person.tags || [];
                    // Person must have at least one of the selected tags
                    const hasMatchingTag = personTags.some(tag => peopleTagFilters.has(tag));
                    if (!hasMatchingTag) return false;
                }

                return true;
            });

            if (filteredPeople.length === 0) {
                listEl.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ‘¥</div><p>No people found</p></div>';
                return;
            }

            listEl.innerHTML = filteredPeople.map(person => `
                <div class="person-card ${person.id === selectedPersonId ? 'selected' : ''}"
                     onclick="selectPerson('${person.id}')">
                    <div class="person-checkbox ${selectedForMerge.has(person.id) ? 'checked' : ''}"
                         onclick="event.stopPropagation(); toggleMergeSelection('${person.id}')"></div>
                    <div class="person-avatar" data-person-id="${person.id}" style="${getAvatarStyle(person.category)}">${getInitials(person.canonical_name)}</div>
                    <div class="person-info">
                        <div class="person-name">${escapeHtml(person.canonical_name)}</div>
                        <div class="person-company">${escapeHtml(person.company || '')}</div>
                    </div>
                    <div class="dunbar-badge circle-${person.dunbar_circle ?? 7}" title="Dunbar Circle ${person.dunbar_circle ?? 7} (${getDunbarCircleSize(person.dunbar_circle ?? 7)})">${person.dunbar_circle ?? 7}</div>
                    <div class="person-strength">
                        <div class="person-strength-bar" style="width: ${person.relationship_strength || 0}%"></div>
                    </div>
                </div>
            `).join('');

            updateMergeToolbar();
        }

        // Toggle merge selection for a person
        function toggleMergeSelection(personId) {
            if (selectedForMerge.has(personId)) {
                selectedForMerge.delete(personId);
            } else {
                selectedForMerge.add(personId);
            }
            renderPeopleList();
        }

        // Update merge toolbar visibility and count
        function updateMergeToolbar() {
            const toolbar = document.getElementById('mergeToolbar');
            const countEl = document.getElementById('selectedCount');
            const labelEl = document.getElementById('selectedLabel');
            const mergeBtn = document.getElementById('mergeBtn');
            const hideBtn = document.getElementById('hideBtn');
            const count = selectedForMerge.size;

            countEl.textContent = count;

            if (count >= 2) {
                // Multiple people selected - show both merge and hide buttons
                toolbar.classList.add('visible');
                labelEl.textContent = 'people selected';
                mergeBtn.style.display = '';
                hideBtn.style.display = '';
                hideBtn.textContent = 'Hide Selected';
            } else if (count === 1) {
                // Single person selected - show hide button only
                toolbar.classList.add('visible');
                labelEl.textContent = 'person selected';
                mergeBtn.style.display = 'none';
                hideBtn.style.display = '';
                hideBtn.textContent = 'Hide Person';
            } else {
                toolbar.classList.remove('visible');
            }
        }

        // Clear all merge selections
        function clearSelection() {
            selectedForMerge.clear();
            mergePrimaryId = null;
            renderPeopleList();
        }

        // Hide selected people (soft delete)
        async function hidePerson() {
            if (selectedForMerge.size === 0) return;

            const selectedIds = [...selectedForMerge];
            const selectedPeople = selectedIds.map(id => people.find(p => p.id === id)).filter(Boolean);
            if (selectedPeople.length === 0) return;

            // Build confirmation message
            const isSingle = selectedPeople.length === 1;
            const nameList = selectedPeople.map(p => `â€¢ ${p.canonical_name}`).join('\n');
            const confirmed = confirm(
                `Hide ${isSingle ? `"${selectedPeople[0].canonical_name}"` : `${selectedPeople.length} people`}?\n\n` +
                (isSingle ? '' : `${nameList}\n\n`) +
                `This will:\n` +
                `â€¢ Remove them from the people list\n` +
                `â€¢ Block their email/phone from future syncs\n\n` +
                `Use this for fake personas or spam contacts.`
            );
            if (!confirmed) return;

            try {
                const reason = prompt('Reason for hiding (optional):', 'fake marketing persona');
                let totalEmailsBlocked = 0;
                let hiddenCount = 0;

                // Hide each person
                for (const personId of selectedIds) {
                    try {
                        const response = await api(`/people/${personId}/hide`, {
                            method: 'POST',
                            body: JSON.stringify({ reason: reason || '' }),
                        });
                        totalEmailsBlocked += response.emails_blocked || 0;
                        hiddenCount++;

                        // If this was the selected person, clear it
                        if (selectedPersonId === personId) {
                            selectedPersonId = null;
                        }
                    } catch (err) {
                        console.error(`Failed to hide person ${personId}:`, err);
                    }
                }

                // Clear selection first
                clearSelection();

                // Reload people list and force UI refresh
                await loadPeople();
                renderPeopleList();
                updateMergeToolbar();

                if (isSingle) {
                    showNotification(`Hidden "${selectedPeople[0].canonical_name}" (${totalEmailsBlocked} emails blocked)`, 'success');
                } else {
                    showNotification(`Hidden ${hiddenCount} people (${totalEmailsBlocked} emails blocked)`, 'success');
                }
            } catch (error) {
                console.error('Failed to hide people:', error);
                showNotification(`Failed to hide people: ${error.message}`, 'error');
            }
        }

        // Open merge modal
        function openMergeModal() {
            if (selectedForMerge.size < 2) return;

            const modal = document.getElementById('mergeModal');
            const selectEl = document.getElementById('mergePrimarySelect');
            const secondaryListEl = document.getElementById('mergeSecondaryList');

            // Get selected people details
            const selectedPeople = people.filter(p => selectedForMerge.has(p.id));

            // Render primary selection options
            selectEl.innerHTML = selectedPeople.map(person => `
                <div class="merge-person-option ${mergePrimaryId === person.id ? 'selected' : ''}"
                     onclick="selectMergePrimary('${person.id}')">
                    <div class="person-avatar">${getInitials(person.canonical_name)}</div>
                    <div class="merge-person-details">
                        <div class="merge-person-name">${escapeHtml(person.canonical_name)}</div>
                        <div class="merge-person-meta">
                            ${person.email_count || 0} emails, ${person.meeting_count || 0} meetings, ${person.message_count || 0} messages
                        </div>
                    </div>
                </div>
            `).join('');

            updateMergeSecondaryList();

            modal.classList.add('visible');
        }

        // Select primary person for merge
        function selectMergePrimary(personId) {
            mergePrimaryId = personId;

            // Update selection UI
            document.querySelectorAll('.merge-person-option').forEach(el => {
                el.classList.remove('selected');
            });
            event.currentTarget.classList.add('selected');

            updateMergeSecondaryList();

            // Enable confirm button
            document.getElementById('mergeConfirmBtn').disabled = false;
        }

        // Update secondary list in modal
        function updateMergeSecondaryList() {
            const secondaryListEl = document.getElementById('mergeSecondaryList');
            const selectedPeople = people.filter(p => selectedForMerge.has(p.id) && p.id !== mergePrimaryId);

            if (mergePrimaryId) {
                secondaryListEl.innerHTML = selectedPeople.map(p => `
                    <li>${escapeHtml(p.canonical_name)}</li>
                `).join('');
            } else {
                secondaryListEl.innerHTML = '<li style="color: var(--text-muted);">Select a primary record above</li>';
            }
        }

        // Close merge modal
        function closeMergeModal() {
            document.getElementById('mergeModal').classList.remove('visible');
            mergePrimaryId = null;
            document.getElementById('mergeConfirmBtn').disabled = true;
        }

        // Confirm and execute merge
        async function confirmMerge() {
            if (!mergePrimaryId || selectedForMerge.size < 2) return;

            const secondaryIds = [...selectedForMerge].filter(id => id !== mergePrimaryId);

            try {
                const btn = document.getElementById('mergeConfirmBtn');
                btn.disabled = true;
                btn.textContent = 'Merging...';

                const result = await api('/people/merge', {
                    method: 'POST',
                    body: JSON.stringify({
                        primary_id: mergePrimaryId,
                        secondary_ids: secondaryIds
                    })
                });

                console.log('Merge completed:', result);

                // Invalidate caches for all merged people
                invalidatePersonCache(mergePrimaryId);
                for (const id of secondaryIds) {
                    invalidatePersonCache(id);
                    invalidateTimelineCache(id);
                }
                invalidateTimelineCache(mergePrimaryId);

                // Close modal and refresh
                closeMergeModal();
                clearSelection();
                await loadPeople();

                // Show success (select the merged person)
                selectPerson(mergePrimaryId);

            } catch (error) {
                console.error('Merge failed:', error);
                alert('Merge failed: ' + error.message);
            } finally {
                const btn = document.getElementById('mergeConfirmBtn');
                btn.disabled = false;
                btn.textContent = 'Merge';
            }
        }

        // ===============================
        // Split Modal Functions
        // ===============================

        let splitContactSources = [];  // Aggregated contact sources (emails, phones, etc.)
        let selectedContactSources = new Set();  // Set of identifier keys (e.g., "email:foo@bar.com")
        let splitTargetType = null;  // 'existing' or 'new'
        let splitTargetPersonId = null;
        let splitFromPersonId = null;

        async function openSplitModal() {
            if (!selectedPersonId) return;

            splitFromPersonId = selectedPersonId;
            selectedContactSources.clear();
            splitTargetType = null;
            splitTargetPersonId = null;

            // Get person name
            const person = people.find(p => p.id === selectedPersonId);
            document.getElementById('splitFromPersonName').textContent = person?.canonical_name || 'this person';

            // Show modal
            document.getElementById('splitModal').classList.add('visible');
            document.getElementById('splitSourceList').innerHTML = '<div class="loading">Loading contact sources...</div>';
            updateSplitButton();

            // Load contact sources (aggregated by identifier: email, phone, etc.)
            try {
                const data = await api(`/people/${selectedPersonId}/contact-sources`);
                splitContactSources = data.contact_sources;
                renderSplitSourceList();
            } catch (error) {
                console.error('Failed to load contact sources:', error);
                document.getElementById('splitSourceList').innerHTML =
                    '<div style="padding: 1rem; color: var(--error);">Failed to load contact sources</div>';
            }
        }

        function renderSplitSourceList() {
            const listEl = document.getElementById('splitSourceList');

            if (splitContactSources.length === 0) {
                listEl.innerHTML = '<div style="padding: 1rem; color: var(--text-secondary);">No contact sources found</div>';
                return;
            }

            // Icons for identifier types
            const typeIcons = {
                'email': 'ðŸ“§',
                'phone': 'ðŸ“±',
                'slack_user': 'ðŸ’¬',
                'linkedin_profile': 'ðŸ’¼',
                'name_only': 'ðŸ‘¤'
            };

            // Display names for identifier types
            const typeLabels = {
                'email': 'Email',
                'phone': 'Phone',
                'slack_user': 'Slack',
                'linkedin_profile': 'LinkedIn',
                'name_only': 'Name'
            };

            listEl.innerHTML = splitContactSources.map(cs => {
                const key = `${cs.identifier_type}:${cs.identifier}`;
                const isSelected = selectedContactSources.has(key);
                const icon = typeIcons[cs.identifier_type] || 'ðŸ“„';
                const label = typeLabels[cs.identifier_type] || cs.identifier_type;
                const names = cs.observed_names?.length > 0 ? cs.observed_names.join(', ') : '';
                const sources = cs.source_types?.join(', ') || '';

                return `
                    <div class="split-source-item ${isSelected ? 'selected' : ''}"
                         onclick="toggleContactSource('${escapeHtml(key)}')">
                        <input type="checkbox" class="split-source-checkbox"
                               ${isSelected ? 'checked' : ''}
                               onclick="event.stopPropagation(); toggleContactSource('${escapeHtml(key)}')">
                        <span class="split-source-badge">${icon} ${label}</span>
                        <div class="split-source-info">
                            <div class="split-source-name">${escapeHtml(cs.identifier)}</div>
                            <div class="split-source-meta">
                                ${names ? `Names: ${escapeHtml(names)} Â· ` : ''}
                                Sources: ${escapeHtml(sources)} Â·
                                ${cs.observation_count} observation${cs.observation_count !== 1 ? 's' : ''}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function toggleContactSource(key) {
            if (selectedContactSources.has(key)) {
                selectedContactSources.delete(key);
            } else {
                selectedContactSources.add(key);
            }
            renderSplitSourceList();
            updateSplitButton();
        }

        // Get all source_entity_ids for selected contact sources
        function getSelectedSourceEntityIds() {
            const allIds = [];
            for (const key of selectedContactSources) {
                const cs = splitContactSources.find(c => `${c.identifier_type}:${c.identifier}` === key);
                if (cs && cs.source_entity_ids) {
                    allIds.push(...cs.source_entity_ids);
                }
            }
            return allIds;
        }

        function setSplitTarget(type) {
            splitTargetType = type;
            splitTargetPersonId = null;

            // Update radio button states
            document.querySelectorAll('.split-target-option').forEach(el => {
                el.classList.remove('selected');
            });
            document.querySelector(`.split-target-option input[value="${type}"]`)?.closest('.split-target-option')?.classList.add('selected');

            // Show/hide sections
            document.getElementById('splitExistingSection').style.display = type === 'existing' ? 'block' : 'none';
            document.getElementById('splitNewSection').style.display = type === 'new' ? 'block' : 'none';

            updateSplitButton();
        }

        async function searchSplitTarget() {
            const query = document.getElementById('splitPersonSearch').value.trim();
            const resultsEl = document.getElementById('splitPersonResults');

            if (query.length < 2) {
                resultsEl.innerHTML = '';
                return;
            }

            try {
                const data = await api(`/people?q=${encodeURIComponent(query)}&limit=10`);
                const filtered = data.people.filter(p => p.id !== splitFromPersonId);

                if (filtered.length === 0) {
                    resultsEl.innerHTML = '<div style="padding: 0.5rem; color: var(--text-secondary);">No matching people</div>';
                    return;
                }

                resultsEl.innerHTML = filtered.map(p => `
                    <div class="split-person-result ${splitTargetPersonId === p.id ? 'selected' : ''}"
                         onclick="selectSplitTarget('${p.id}', '${escapeHtml(p.canonical_name)}')">
                        ${escapeHtml(p.canonical_name)}
                        ${p.company ? `<span style="color: var(--text-secondary);"> Â· ${escapeHtml(p.company)}</span>` : ''}
                    </div>
                `).join('');
            } catch (error) {
                console.error('Search failed:', error);
            }
        }

        function selectSplitTarget(personId, personName) {
            splitTargetPersonId = personId;
            document.getElementById('splitPersonSearch').value = personName;
            document.getElementById('splitPersonResults').innerHTML = '';
            updateSplitButton();
        }

        function updateSplitButton() {
            const btn = document.getElementById('splitConfirmBtn');
            const countEl = document.getElementById('splitCount');

            countEl.textContent = selectedContactSources.size;

            // Enable if we have sources selected AND a valid target
            const hasTarget = (splitTargetType === 'existing' && splitTargetPersonId) ||
                              (splitTargetType === 'new' && document.getElementById('splitNewPersonName').value.trim());
            const hasSelection = selectedContactSources.size > 0;

            btn.disabled = !(hasSelection && hasTarget);
        }

        function closeSplitModal() {
            document.getElementById('splitModal').classList.remove('visible');
            splitContactSources = [];
            selectedContactSources.clear();
            splitTargetType = null;
            splitTargetPersonId = null;
            splitFromPersonId = null;
        }

        async function confirmSplit() {
            if (selectedContactSources.size === 0) return;

            const btn = document.getElementById('splitConfirmBtn');
            btn.disabled = true;
            btn.textContent = 'Splitting...';

            try {
                // Get all source entity IDs from selected contact sources
                const sourceEntityIds = getSelectedSourceEntityIds();
                const requestBody = {
                    from_person_id: splitFromPersonId,
                    source_entity_ids: sourceEntityIds,
                    create_overrides: document.getElementById('splitCreateOverrides').checked
                };

                if (splitTargetType === 'existing') {
                    requestBody.to_person_id = splitTargetPersonId;
                } else {
                    requestBody.new_person_name = document.getElementById('splitNewPersonName').value.trim();
                }

                const result = await api('/people/split', {
                    method: 'POST',
                    body: JSON.stringify(requestBody)
                });

                console.log('Split completed:', result);

                // Invalidate caches for both source and target people
                invalidatePersonCache(splitFromPersonId);
                invalidateTimelineCache(splitFromPersonId);
                if (splitTargetPersonId) {
                    invalidatePersonCache(splitTargetPersonId);
                    invalidateTimelineCache(splitTargetPersonId);
                }

                // Close modal and refresh
                closeSplitModal();
                await loadPeople();

                // Reload the current person's details
                await loadPersonDetail(splitFromPersonId || selectedPersonId);

                // Show success message
                alert(`Split complete! Moved ${result.source_entities_moved} sources and ${result.interactions_moved} interactions.` +
                      (result.overrides_created > 0 ? ` Created ${result.overrides_created} disambiguation rules.` : ''));

            } catch (error) {
                console.error('Split failed:', error);
                alert('Split failed: ' + error.message);
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'Split <span id="splitCount">0</span> Sources';
            }
        }

        // ============================================================================
        // Cleanup Modal Functions
        // ============================================================================

        let cleanupItems = [];
        let cleanupCurrentTab = 'duplicates';

        async function loadCleanupStats() {
            try {
                const stats = await api('/cleanup/stats');
                const badge = document.getElementById('cleanupNavBadge');
                if (stats.total_pending > 0) {
                    badge.textContent = stats.total_pending;
                    badge.style.display = 'inline-flex';
                } else {
                    badge.style.display = 'none';
                }
                // Update tab badges
                const pending = stats.pending_by_type || {};
                document.getElementById('cleanupDuplicatesBadge').textContent = pending.duplicate || 0;
                document.getElementById('cleanupNonHumanBadge').textContent = pending.non_human || 0;
                document.getElementById('cleanupOverMergedBadge').textContent = pending.over_merged || 0;
            } catch (error) {
                console.error('Failed to load cleanup stats:', error);
            }
        }

        async function openCleanupModal() {
            document.getElementById('cleanupModal').classList.add('visible');
            await loadCleanupQueue();
        }

        function closeCleanupModal() {
            document.getElementById('cleanupModal').classList.remove('visible');
        }

        function switchCleanupTab(tab) {
            cleanupCurrentTab = tab;
            document.querySelectorAll('.cleanup-tab').forEach(t => {
                t.classList.toggle('active', t.dataset.tab === tab);
            });
            renderCleanupList();
        }

        async function loadCleanupQueue() {
            const list = document.getElementById('cleanupList');
            list.innerHTML = '<div class="cleanup-loading">Loading cleanup queue...</div>';

            try {
                const result = await api('/cleanup/queue');
                cleanupItems = result.items || [];
                await loadCleanupStats();
                renderCleanupList();
            } catch (error) {
                console.error('Failed to load cleanup queue:', error);
                list.innerHTML = '<div class="cleanup-empty"><div class="cleanup-empty-icon">âŒ</div>Failed to load cleanup queue</div>';
            }
        }

        function renderCleanupList() {
            const list = document.getElementById('cleanupList');
            const typeMap = {
                'duplicates': 'duplicate',
                'non_human': 'non_human',
                'over_merged': 'over_merged'
            };
            const targetType = typeMap[cleanupCurrentTab];
            const filtered = cleanupItems.filter(item => item.review_type === targetType);

            if (filtered.length === 0) {
                list.innerHTML = `
                    <div class="cleanup-empty">
                        <div class="cleanup-empty-icon">âœ¨</div>
                        No ${cleanupCurrentTab.replace('_', ' ')} items to review
                    </div>
                `;
                return;
            }

            list.innerHTML = filtered.map(item => renderCleanupItem(item)).join('');
        }

        function renderCleanupItem(item) {
            const confidenceClass = item.confidence >= 0.9 ? 'high' : (item.confidence >= 0.7 ? 'medium' : 'low');
            const confidencePercent = Math.round(item.confidence * 100);

            let namesHtml = '';
            let actionsHtml = '';

            if (item.review_type === 'duplicate') {
                namesHtml = `
                    <div class="cleanup-item-name">${escapeHtml(item.person_a_name)}</div>
                    <div class="cleanup-item-vs">â†” might be same as</div>
                    <div class="cleanup-item-name-secondary">${escapeHtml(item.person_b_name || '')}</div>
                `;
                actionsHtml = `
                    <button class="cleanup-action-btn primary" onclick="cleanupMerge('${item.id}', '${item.person_a_id}')">
                        Merge â†’ ${escapeHtml(item.person_a_name.split(' ')[0])}
                    </button>
                    <button class="cleanup-action-btn" onclick="cleanupMerge('${item.id}', '${item.person_b_id}')">
                        â† Merge ${escapeHtml((item.person_b_name || '').split(' ')[0])}
                    </button>
                    <button class="cleanup-action-btn" onclick="cleanupSkip('${item.id}')">
                        Different People
                    </button>
                `;
            } else if (item.review_type === 'non_human') {
                namesHtml = `
                    <div class="cleanup-item-name">${escapeHtml(item.person_a_name)}</div>
                    <div class="cleanup-merge-search" id="merge-search-${item.id}" style="display: none;">
                        <input type="text" class="cleanup-merge-input" placeholder="Search for person to merge with..."
                               oninput="cleanupSearchPeople('${item.id}', this.value)"
                               onkeydown="if(event.key==='Escape') closeMergeSearch('${item.id}')">
                        <div class="cleanup-merge-results" id="merge-results-${item.id}"></div>
                    </div>
                `;
                actionsHtml = `
                    <button class="cleanup-action-btn primary" onclick="openMergeSearch('${item.id}', '${item.person_a_id}')">
                        Find & Merge
                    </button>
                    <button class="cleanup-action-btn danger" onclick="cleanupHide('${item.id}')">
                        Hide (Not a Person)
                    </button>
                    <button class="cleanup-action-btn" onclick="cleanupKeep('${item.id}')">
                        Keep (Real Person)
                    </button>
                `;
            } else if (item.review_type === 'over_merged') {
                namesHtml = `
                    <div class="cleanup-item-name">${escapeHtml(item.person_a_name)}</div>
                `;
                actionsHtml = `
                    <button class="cleanup-action-btn primary" onclick="selectPerson('${item.person_a_id}'); closeCleanupModal();">
                        Review & Split
                    </button>
                    <button class="cleanup-action-btn" onclick="cleanupSkip('${item.id}')">
                        Looks OK
                    </button>
                `;
            }

            return `
                <div class="cleanup-item" id="cleanup-item-${item.id}">
                    <div class="cleanup-item-header">
                        <div class="cleanup-item-names">
                            ${namesHtml}
                        </div>
                        <span class="cleanup-confidence ${confidenceClass}">${confidencePercent}%</span>
                    </div>
                    <div class="cleanup-item-reason">${escapeHtml(item.reason)}</div>
                    <div class="cleanup-item-actions">
                        ${actionsHtml}
                    </div>
                </div>
            `;
        }

        async function cleanupMerge(itemId, primaryId) {
            const item = document.getElementById(`cleanup-item-${itemId}`);
            if (item) item.style.opacity = '0.5';

            try {
                await api(`/cleanup/${itemId}/merge?primary_id=${primaryId}`, { method: 'POST' });
                cleanupItems = cleanupItems.filter(i => i.id !== itemId);
                renderCleanupList();
                await loadCleanupStats();
                await loadPeople(false);  // Refresh people list
            } catch (error) {
                console.error('Merge failed:', error);
                alert('Merge failed: ' + error.message);
                if (item) item.style.opacity = '1';
            }
        }

        async function cleanupSkip(itemId) {
            const item = document.getElementById(`cleanup-item-${itemId}`);
            if (item) item.style.opacity = '0.5';

            try {
                await api(`/cleanup/${itemId}/skip`, { method: 'POST' });
                cleanupItems = cleanupItems.filter(i => i.id !== itemId);
                renderCleanupList();
                await loadCleanupStats();
            } catch (error) {
                console.error('Skip failed:', error);
                alert('Skip failed: ' + error.message);
                if (item) item.style.opacity = '1';
            }
        }

        async function cleanupHide(itemId) {
            const item = document.getElementById(`cleanup-item-${itemId}`);
            if (item) item.style.opacity = '0.5';

            try {
                await api(`/cleanup/${itemId}/hide`, { method: 'POST' });
                cleanupItems = cleanupItems.filter(i => i.id !== itemId);
                renderCleanupList();
                await loadCleanupStats();
                await loadPeople(false);  // Refresh people list
            } catch (error) {
                console.error('Hide failed:', error);
                alert('Hide failed: ' + error.message);
                if (item) item.style.opacity = '1';
            }
        }

        async function cleanupKeep(itemId) {
            const item = document.getElementById(`cleanup-item-${itemId}`);
            if (item) item.style.opacity = '0.5';

            try {
                await api(`/cleanup/${itemId}/keep`, { method: 'POST' });
                cleanupItems = cleanupItems.filter(i => i.id !== itemId);
                renderCleanupList();
                await loadCleanupStats();
            } catch (error) {
                console.error('Keep failed:', error);
                alert('Keep failed: ' + error.message);
                if (item) item.style.opacity = '1';
            }
        }

        // Merge search state
        let currentMergeItemId = null;
        let currentMergePersonId = null;
        let mergeSearchTimeout = null;

        function openMergeSearch(itemId, personAId) {
            // Close any other open merge searches
            document.querySelectorAll('.cleanup-merge-search').forEach(el => {
                el.style.display = 'none';
            });

            currentMergeItemId = itemId;
            currentMergePersonId = personAId;

            const searchDiv = document.getElementById(`merge-search-${itemId}`);
            if (searchDiv) {
                searchDiv.style.display = 'block';
                const input = searchDiv.querySelector('input');
                if (input) {
                    input.value = '';
                    input.focus();
                }
                const results = document.getElementById(`merge-results-${itemId}`);
                if (results) results.innerHTML = '<div class="cleanup-merge-result-meta">Type to search...</div>';
            }
        }

        function closeMergeSearch(itemId) {
            const searchDiv = document.getElementById(`merge-search-${itemId}`);
            if (searchDiv) {
                searchDiv.style.display = 'none';
            }
            currentMergeItemId = null;
            currentMergePersonId = null;
        }

        function cleanupSearchPeople(itemId, query) {
            clearTimeout(mergeSearchTimeout);

            const resultsDiv = document.getElementById(`merge-results-${itemId}`);
            if (!resultsDiv) return;

            if (!query || query.length < 2) {
                resultsDiv.innerHTML = '<div class="cleanup-merge-result-meta">Type at least 2 characters...</div>';
                return;
            }

            mergeSearchTimeout = setTimeout(() => {
                // Filter from the already loaded people array
                const matches = people.filter(p => {
                    const name = (p.canonical_name || p.display_name || '').toLowerCase();
                    const q = query.toLowerCase();
                    return name.includes(q) && p.id !== currentMergePersonId;
                }).slice(0, 10);

                if (matches.length === 0) {
                    resultsDiv.innerHTML = '<div class="cleanup-merge-result-meta">No matches found</div>';
                    return;
                }

                resultsDiv.innerHTML = matches.map(p => `
                    <div class="cleanup-merge-result" onclick="executeMergeFromSearch('${itemId}', '${p.id}', '${escapeHtml(p.canonical_name || p.display_name)}')">
                        <div>
                            <div class="cleanup-merge-result-name">${escapeHtml(p.canonical_name || p.display_name)}</div>
                            <div class="cleanup-merge-result-meta">${p.category || 'unknown'} â€¢ strength: ${p.relationship_strength || 0}</div>
                        </div>
                    </div>
                `).join('');
            }, 200);
        }

        async function executeMergeFromSearch(itemId, targetPersonId, targetName) {
            if (!confirm(`Merge this entity into "${targetName}"?`)) return;

            const item = document.getElementById(`cleanup-item-${itemId}`);
            if (item) item.style.opacity = '0.5';

            try {
                // Call the cleanup merge endpoint with the target as primary
                await api(`/cleanup/${itemId}/merge?primary_id=${targetPersonId}`, { method: 'POST' });
                cleanupItems = cleanupItems.filter(i => i.id !== itemId);
                renderCleanupList();
                await loadCleanupStats();
                await loadPeople(false);  // Refresh people list
            } catch (error) {
                console.error('Merge failed:', error);
                alert('Merge failed: ' + error.message);
                if (item) item.style.opacity = '1';
            }
        }

        // Load cleanup stats on page load
        document.addEventListener('DOMContentLoaded', () => {
            loadCleanupStats();
        });

        // Listen for input changes on new person name field
        document.addEventListener('DOMContentLoaded', () => {
            const newNameInput = document.getElementById('splitNewPersonName');
            if (newNameInput) {
                newNameInput.addEventListener('input', updateSplitButton);
            }
            // Initialize layout tuning sliders from localStorage
            initLayoutTuningSliders();

            // Heatmap years dropdown
            const yearsSelect = document.getElementById('heatmapYearsSelect');
            if (yearsSelect) {
                yearsSelect.addEventListener('change', (e) => {
                    const years = parseInt(e.target.value, 10);
                    // Clear volume chart state so it fully reinitializes
                    volumeChartPoints = [];
                    volumeChartConfig = null;
                    const canvas = document.getElementById('volumeChartCanvas');
                    if (canvas) {
                        canvas.dataset.hoverSetup = '';
                        // Clear the canvas immediately
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                    }
                    // Check if we're on family view
                    const { isFamily } = parseUrl();
                    if (isFamily) {
                        // For family view, re-fetch with new year range
                        heatmapYears = years;
                        loadFamilyInteractions();
                    } else if (currentHeatmapPersonId) {
                        loadAndRenderHeatMap(currentHeatmapPersonId, years);
                    }
                });
            }

            // Debounced resize handler for volume chart
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    renderVolumeChart();
                }, 150);
            });
        });

        // ===============================
        // End Split Modal Functions
        // ===============================

        // Select a person - IMMEDIATELY updates UI, loads data in background
        function selectPerson(personId, stayOnCurrentTab = false, skipUrlUpdate = false) {
            selectedPersonId = personId;
            hiddenNodeIds.clear(); // Clear hidden nodes when switching people
            closeEdgePanel(); // Close edge panel when switching people
            closeNodePanel(); // Close node panel when switching people

            // Close mobile sidebar when selecting a person
            if (isMobileView()) {
                closePeoplePanel();
            }

            // Clear charts immediately to prevent stale data showing
            clearChartsWithLoading();

            renderPeopleList();

            // Update URL immediately (unless called from popstate or initial load)
            if (!skipUrlUpdate) {
                const currentTab = document.querySelector('.tab.active')?.dataset.tab || 'overview';
                updateUrl(personId, currentTab);
            }

            // Show detail panel with loading state, load data in background
            // Return promise so callers can optionally await (e.g., when switching to specific tab)
            return loadPersonDetail(personId, stayOnCurrentTab);
        }

        // Load person detail - shows skeleton immediately, loads data progressively
        // Uses caching to provide instant display for recently viewed people
        async function loadPersonDetail(personId, stayOnCurrentTab = false) {
            // Clear date range filter when loading a new person
            const fromInput = document.getElementById('timelineDateFrom');
            const toInput = document.getElementById('timelineDateTo');
            const clearBtn = document.getElementById('clearDateRangeBtn');
            if (fromInput) fromInput.value = '';
            if (toInput) toInput.value = '';
            if (clearBtn) clearBtn.style.display = 'none';
            timelineDateRangeFrom = null;
            timelineDateRangeTo = null;

            const emptyEl = document.getElementById('detailEmpty');
            const contentEl = document.getElementById('detailContent');

            emptyEl.style.display = 'none';
            contentEl.style.display = 'flex';
            contentEl.style.flexDirection = 'column';
            contentEl.style.height = '100%';

            // Remember current tab if we should stay on it
            const currentTab = document.querySelector('.tab.active')?.dataset.tab || 'overview';

            // Check cache first - render immediately if available
            const cachedPerson = getCachedPerson(personId);
            if (cachedPerson) {
                // Instant render from cache
                renderPersonDetail(cachedPerson);

                // Load data for the active tab
                const activeTab = stayOnCurrentTab ? currentTab : document.querySelector('.tab.active')?.dataset.tab;
                if (activeTab === 'timeline') {
                    loadTimeline(personId);
                } else if (activeTab === 'graph') {
                    loadGraph(personId);
                }

                // Background refresh: fetch fresh data to update cache
                api(`/people/${personId}`).then(person => {
                    if (selectedPersonId === personId) {
                        setCachedPerson(personId, person);
                        // Only re-render if data changed (compare key fields)
                        if (JSON.stringify(cachedPerson) !== JSON.stringify(person)) {
                            renderPersonDetail(person);
                        }
                    }
                }).catch(err => console.warn('[Cache] Background refresh failed:', err));

                loadRelatedData(personId);
                return;
            }

            // No cache - show loading skeleton and fetch
            showPersonLoadingSkeleton();

            try {
                // First: Load basic person data (fast, no related data)
                const person = await api(`/people/${personId}`);
                setCachedPerson(personId, person);
                renderPersonDetail(person);

                // Background: Load related data (source entities, relationships)
                loadRelatedData(personId);

                // Load data for the active tab
                const activeTab = stayOnCurrentTab ? currentTab : document.querySelector('.tab.active')?.dataset.tab;
                if (activeTab === 'timeline') {
                    loadTimeline(personId); // Don't await
                } else if (activeTab === 'graph') {
                    loadGraph(personId); // Don't await
                }
            } catch (error) {
                console.error('Failed to load person detail:', error);
                hidePersonLoadingSkeleton();
            }
        }

        // Show loading skeleton for person detail
        function showPersonLoadingSkeleton() {
            document.getElementById('detailName').textContent = 'Loading...';
            document.getElementById('detailCompany').textContent = '';
            document.getElementById('detailAvatar').textContent = '...';
            document.getElementById('detailAvatar').style.backgroundImage = '';
            document.getElementById('detailAvatar').classList.remove('has-photo');
            document.getElementById('detailContactQuick').innerHTML = '';

            // Clear tags
            const tagsEl = document.getElementById('detailTagsChips');
            if (tagsEl) tagsEl.innerHTML = '';

            // Clear contact info
            const contactInfoEl = document.getElementById('contactInfoCompact');
            if (contactInfoEl) contactInfoEl.innerHTML = '<div class="loading">Loading...</div>';

            // Clear mobile details (birthday, tags)
            const mobileBirthday = document.getElementById('mobileDetailsBirthday');
            const mobileTags = document.getElementById('mobileDetailsTags');
            if (mobileBirthday) mobileBirthday.innerHTML = '';
            if (mobileTags) mobileTags.innerHTML = '';

            // Clear header indicators (strength, dunbar)
            const strengthValueEl = document.getElementById('headerStrengthValue');
            const dunbarCircleEl = document.getElementById('headerDunbarCircle');
            const dunbarLabelEl = document.getElementById('headerDunbarLabel');
            if (strengthValueEl) strengthValueEl.textContent = '-';
            if (dunbarCircleEl) {
                dunbarCircleEl.textContent = '-';
                dunbarCircleEl.className = 'header-dunbar-circle';
            }
            if (dunbarLabelEl) dunbarLabelEl.textContent = '';

            // Clear and show loading state for charts
            clearChartsWithLoading();

            // Clear hero stats
            document.getElementById('heroStatEmails').textContent = '-';
            document.getElementById('heroStatEvents').textContent = '-';
            document.getElementById('heroStatMessages').textContent = '-';

            // Hide and clear additional hero stats (phone, slack, notes, contacts, linkedin, photos)
            const additionalStats = [
                { container: 'heroStatPhoneContainer', value: 'heroStatPhone' },
                { container: 'heroStatSlackContainer', value: 'heroStatSlack' },
                { container: 'heroStatNotesContainer', value: 'heroStatNotes' },
                { container: 'heroStatContactsContainer', value: 'heroStatContacts' },
                { container: 'heroStatLinkedInContainer', value: 'heroStatLinkedIn' },
                { container: 'heroStatPhotosContainer', value: 'heroStatPhotos' },
            ];
            additionalStats.forEach(({ container, value }) => {
                const containerEl = document.getElementById(container);
                const valueEl = document.getElementById(value);
                if (containerEl) containerEl.style.display = 'none';
                if (valueEl) valueEl.textContent = '0';
            });

            // Clear other dynamic content
            const strengthRing = document.getElementById('strengthRing');
            if (strengthRing) {
                const ctx = strengthRing.getContext('2d');
                ctx.clearRect(0, 0, strengthRing.width, strengthRing.height);
            }

            // Clear strength ring fill (SVG version)
            const ringFill = document.getElementById('headerStrengthRingFill');
            if (ringFill) {
                ringFill.style.strokeDashoffset = '113.1'; // Full circle = empty
            }
        }

        /**
         * Clear charts and show loading state.
         */
        function clearChartsWithLoading() {
            // Clear global chart data
            heatmapData = {};
            sourceTotals = {};
            volumeChartPoints = [];
            volumeChartConfig = null;

            // Clear heatmap grid and show loading
            const heatmapGrid = document.getElementById('heatmapGrid');
            if (heatmapGrid) {
                heatmapGrid.innerHTML = '<div class="chart-loading"><div class="chart-loading-spinner"></div>Loading...</div>';
            }

            // Clear month labels
            const heatmapMonths = document.getElementById('heatmapMonths');
            if (heatmapMonths) {
                heatmapMonths.innerHTML = '';
            }

            // Clear volume chart canvas and show loading
            const volumeCanvas = document.getElementById('volumeChartCanvas');
            if (volumeCanvas) {
                const ctx = volumeCanvas.getContext('2d');
                const dpr = window.devicePixelRatio || 1;
                const rect = volumeCanvas.getBoundingClientRect();
                volumeCanvas.width = rect.width * dpr;
                volumeCanvas.height = rect.height * dpr;
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, volumeCanvas.width, volumeCanvas.height);
                ctx.scale(dpr, dpr);

                // Draw loading text
                ctx.fillStyle = '#888';
                ctx.font = '12px system-ui, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Loading...', rect.width / 2, rect.height / 2);

                // Reset hover setup
                volumeCanvas.dataset.hoverSetup = '';
            }

            // Reset title
            const titleEl = document.getElementById('heatmapTitle');
            if (titleEl) {
                titleEl.textContent = 'Interaction History';
            }

            // Reset dropdown
            const yearsSelect = document.getElementById('heatmapYearsSelect');
            if (yearsSelect) {
                yearsSelect.value = '1';
            }
        }

        // Hide loading skeleton
        function hidePersonLoadingSkeleton() {
            // Called implicitly when renderPersonDetail populates the fields
        }

        // Load related data in background (source entities, relationships)
        async function loadRelatedData(personId) {
            try {
                const person = await api(`/people/${personId}?include_related=true`);
                // Update source entities if still on same person
                if (selectedPersonId === personId) {
                    updateSourceEntities(person.source_entities || [], person.source_entity_count || 0);
                }
            } catch (error) {
                console.error('Failed to load related data:', error);
            }
        }

        // Update source entities section
        function updateSourceEntities(sourceEntities, count) {
            document.getElementById('sourceEntitiesCount').textContent = count.toLocaleString();
            const listEl = document.getElementById('sourceEntitiesList');

            if (sourceEntities.length > 0) {
                listEl.innerHTML = sourceEntities.map(se => `
                    <div class="source-entity-item">
                        <span class="source-entity-badge">${se.source_badge}</span>
                        <div class="source-entity-info">
                            <div class="source-entity-name">${escapeHtml(se.observed_name || se.observed_email || 'Unknown')}</div>
                            <div class="source-entity-meta">${se.source_type} Â· ${formatDate(se.observed_at)}</div>
                        </div>
                        <span class="source-entity-status ${se.link_status}">${se.link_status}</span>
                    </div>
                `).join('');
            } else {
                listEl.innerHTML = '<div class="empty-state"><p>No source entities</p></div>';
            }
        }

        // Render person detail
        function renderPersonDetail(person) {
            const isMePage = isMyPage(person.id);

            // Toggle Me Dashboard vs Person Content Grid visibility
            const meDashboard = document.getElementById('meDashboard');
            const personContentGrid = document.getElementById('personContentGrid');
            const sourceEntitiesFooter = document.getElementById('sourceEntitiesFooter');

            // Header indicators (strength ring, dunbar circle) - hide for Me page
            const headerIndicators = document.querySelector('.header-indicators');
            if (headerIndicators) {
                headerIndicators.style.display = isMePage ? 'none' : 'flex';
            }

            // Last seen stat - hide for Me page
            const lastSeenStat = document.getElementById('heroStatLastSeen')?.closest('.hero-stat');
            if (lastSeenStat) {
                lastSeenStat.style.display = isMePage ? 'none' : 'flex';
            }

            // Hide family dashboard when viewing any person
            const familyDashboard = document.getElementById('familyDashboard');
            if (familyDashboard) {
                familyDashboard.style.display = 'none';
                familyDashboard.classList.remove('visible');
            }

            // Hide relationship dashboard when viewing any person (including /me)
            const relationshipDashboard = document.getElementById('relationshipDashboard');
            if (relationshipDashboard) {
                relationshipDashboard.style.display = 'none';
                relationshipDashboard.classList.remove('visible');
            }

            // Show heatmap for person views (relationship view hides it, so restore it)
            const heatmapContainer = document.querySelector('.heatmap-container');
            if (heatmapContainer) {
                heatmapContainer.style.display = '';
            }

            // Restore elements that family dashboard hides
            // (headerIndicators already declared above)
            const detailTabs = document.querySelector('.detail-tabs');
            // Restore original header indicators content (strength ring, dunbar circle)
            // But keep them hidden for /me page
            if (headerIndicators && originalHeaderIndicatorsHtml !== null) {
                headerIndicators.innerHTML = originalHeaderIndicatorsHtml;
            }
            if (headerIndicators) headerIndicators.style.display = isMePage ? 'none' : '';
            if (detailTabs) {
                detailTabs.style.display = '';
                // Restore Graph tab that family view hides
                const graphTab = detailTabs.querySelector('[data-tab="graph"]');
                if (graphTab) graphTab.style.display = '';
            }
            const heatmapSectionEl = document.getElementById('heatmapSection');
            if (heatmapSectionEl) heatmapSectionEl.style.display = '';
            // Restore hero stats that family dashboard hides
            const heroStats = document.getElementById('heroStats');
            if (heroStats) heroStats.style.display = '';
            // Hide family hero stats and selector when viewing a person
            const familyHeroStats = document.getElementById('familyHeroStats');
            if (familyHeroStats) familyHeroStats.style.display = 'none';
            const familySelectorContainer = document.getElementById('familySelectorContainer');
            if (familySelectorContainer) familySelectorContainer.style.display = 'none';

            if (isMePage) {
                meDashboard.style.display = 'grid';
                personContentGrid.style.display = 'none';
                if (sourceEntitiesFooter) sourceEntitiesFooter.style.display = 'none';
            } else {
                meDashboard.style.display = 'none';
                personContentGrid.style.display = 'grid';
                if (sourceEntitiesFooter) sourceEntitiesFooter.style.display = 'block';
            }

            // For "Me" page, customize the display
            if (isMePage) {
                document.getElementById('detailAvatar').textContent = 'ðŸ‘¤';
                document.getElementById('detailAvatar').style.backgroundImage = '';
                document.getElementById('detailAvatar').classList.remove('has-photo');
                document.getElementById('detailName').textContent = 'My Dashboard';
                document.getElementById('detailCompany').textContent = 'Personal CRM Overview';
            } else {
                document.getElementById('detailAvatar').textContent = getInitials(person.canonical_name);
                document.getElementById('detailName').textContent = person.canonical_name;
                document.getElementById('detailCompany').textContent = [person.company, person.position].filter(Boolean).join(' Â· ');
                // Load profile photo for detail avatar
                loadDetailProfilePhoto(person.id);
            }

            // Quick contact links in header (skip for Me page)
            const quickContactEl = document.getElementById('detailContactQuick');
            if (isMePage) {
                quickContactEl.innerHTML = '';
            } else {
                let quickContactHtml = '';
                if (person.emails && person.emails.length > 0) {
                    quickContactHtml += `<a href="mailto:${person.emails[0]}" class="detail-contact-link">ðŸ“§ ${escapeHtml(person.emails[0])}</a>`;
                }
                if (person.phone_numbers && person.phone_numbers.length > 0) {
                    quickContactHtml += `<a href="tel:${person.phone_numbers[0]}" class="detail-contact-link">ðŸ“ž ${escapeHtml(person.phone_numbers[0])}</a>`;
                }
                quickContactEl.innerHTML = quickContactHtml;
            }

            // Editable tags in header (skip for Me page)
            if (!isMePage) {
                renderEditableTags(person);
            } else {
                document.getElementById('detailTagsChips').innerHTML = '';
            }

            // Update mobile details drawer
            if (!isMePage) {
                updateMobileDetails(person);
            }

            // Load Quick Facts (skip for Me page - has its own dashboard)
            if (!isMePage) {
                loadFacts(person.id);
            } else {
                // Render Me dashboard widgets
                renderMeDashboard();
            }

            // Hero stats row
            renderHeroStats(person);

            // Heat map calendar - load with max years, then auto-select based on actual data
            // Start with 10 years to get all data, will be adjusted after loading
            heatmapYears = 10;
            loadAndRenderHeatMap(person.id, null, true); // true = auto-select years from data

            // Skip individual-specific rendering for Me page
            if (isMePage) {
                return;
            }

            // Relationship strength ring
            renderStrengthRing(person.relationship_strength || 0);

            // Dunbar circle display
            renderDunbarCircle(person.id);

            // Backwards compatibility for old strength breakdown (hidden)
            renderStrengthBreakdown(person);

            // Compact contact info for new layout
            renderCompactContactInfo(person);

            // Legacy contact info (hidden for backwards compatibility)
            const contactEl = document.getElementById('contactInfo');
            let contactHtml = '';

            if (person.emails && person.emails.length > 0) {
                contactHtml += `<div class="info-item"><div class="info-label">Email${person.emails.length > 1 ? 's' : ''}</div><div class="info-value">${person.emails.map(e => `<a href="mailto:${e}">${escapeHtml(e)}</a>`).join('<br>')}</div></div>`;
            }
            if (person.phone_numbers && person.phone_numbers.length > 0) {
                contactHtml += `<div class="info-item"><div class="info-label">Phone${person.phone_numbers.length > 1 ? 's' : ''}</div><div class="info-value">${person.phone_numbers.map(p => `<a href="tel:${p}">${escapeHtml(p)}</a>`).join('<br>')}</div></div>`;
            }
            if (person.linkedin_url) {
                contactHtml += `<div class="info-item"><div class="info-label">LinkedIn</div><div class="info-value"><a href="${person.linkedin_url}" target="_blank">View Profile</a></div></div>`;
            }
            if (person.category) {
                contactHtml += `<div class="info-item"><div class="info-label">Category</div><div class="info-value">${escapeHtml(person.category)}</div></div>`;
            }
            if (person.first_seen) {
                contactHtml += `<div class="info-item"><div class="info-label">First Seen</div><div class="info-value">${formatDate(person.first_seen)}</div></div>`;
            }
            if (person.last_seen) {
                contactHtml += `<div class="info-item"><div class="info-label">Last Seen</div><div class="info-value">${formatDate(person.last_seen)}</div></div>`;
            }

            contactEl.innerHTML = contactHtml || '<div class="info-item"><div class="info-value">No contact info</div></div>';

            // Notes - set value and track original for dirty checking
            const notesValue = person.notes || '';
            document.getElementById('notesArea').value = notesValue;
            originalNotesValue = notesValue;
            document.getElementById('notesSaveBtn').style.display = 'none';
            document.getElementById('notesUnsavedIndicator').style.display = 'none';

            // Source entities - show count if available, loading state for list
            // (full list is loaded in background by loadRelatedData)
            const sourceEntityCount = person.source_entity_count || 0;
            document.getElementById('sourceEntitiesCount').textContent = sourceEntityCount.toLocaleString();
            const listEl = document.getElementById('sourceEntitiesList');

            // If source_entities included (from include_related=true), render them
            // Otherwise show loading state - they'll be loaded by loadRelatedData
            if (person.source_entities && person.source_entities.length > 0) {
                updateSourceEntities(person.source_entities, sourceEntityCount);
            } else if (sourceEntityCount > 0) {
                listEl.innerHTML = '<div class="empty-state"><p>Loading source entities...</p></div>';
            } else {
                listEl.innerHTML = '<div class="empty-state"><p>No source entities</p></div>';
            }
        }

        // Render editable tags (and birthday)
        function renderEditableTags(person) {
            const container = document.getElementById('detailTagsChips');
            let html = '';

            // Birthday display (to the left of tags)
            if (person.birthday) {
                // Birthday is "MM-DD" format - parse and display as "Aug 7"
                const [month, day] = person.birthday.split('-').map(Number);
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const formatted = `${monthNames[month - 1]} ${day}`;
                html += `<span class="detail-birthday-chip" title="Birthday">
                    ðŸŽ‚ ${formatted}
                    <span class="remove-birthday" onclick="removeBirthday()">Ã—</span>
                </span>`;
            } else {
                html += `<span class="detail-tag-add" onclick="addBirthday()">+ Add birthday</span>`;
            }

            // Tags
            html += (person.tags || []).map(tag => `
                <span class="detail-tag-chip">
                    ${escapeHtml(tag)}
                    <span class="remove-tag" onclick="removeTag('${escapeHtml(tag)}')">Ã—</span>
                </span>
            `).join('');

            html += `<span class="detail-tag-add" onclick="addTag()">+ Add tag</span>`;
            html += `<span class="detail-hide-btn" onclick="hideCurrentPerson()" title="Hide this person">Hide</span>`;
            container.innerHTML = html;
        }

        // Hide the currently selected person
        async function hideCurrentPerson() {
            console.log('hideCurrentPerson called, selectedPersonId:', selectedPersonId);
            if (!selectedPersonId) {
                alert('No person selected');
                return;
            }

            const person = allPeople.find(p => p.id === selectedPersonId);
            const name = person?.canonical_name || 'this person';

            if (!confirm(`Hide "${name}"?\n\nThis will remove them from all lists and metrics. Their identifiers will be blocklisted to prevent recreation during syncs.`)) {
                return;
            }

            try {
                console.log('Calling hide API for:', selectedPersonId);
                const result = await api(`/people/${selectedPersonId}/hide`, {
                    method: 'POST',
                    body: JSON.stringify({ reason: 'Hidden from profile page' }),
                });
                console.log('Hide API result:', result);

                // Remove from local list and refresh
                allPeople = allPeople.filter(p => p.id !== selectedPersonId);
                renderPeopleList();

                // Clear detail view
                selectedPersonId = null;
                document.getElementById('detailContent').classList.remove('person-selected');
                updateUrl(null, null);

                // Show confirmation
                alert(`"${name}" has been hidden.`);
            } catch (error) {
                console.error('Failed to hide person:', error);
                alert('Failed to hide person. Please try again.');
            }
        }

        // Format large numbers compactly (e.g., 46049 -> "46K")
        function formatCompactNumber(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
            if (num >= 1000) return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'K';
            return num.toString();
        }

        // Render hero stats row
        async function renderHeroStats(person) {
            // For "Me" page, show aggregate stats across all people
            if (isMyPage(person.id)) {
                await renderMeHeroStats();
                return;
            }

            const emailCount = person.email_count || 0;
            const eventCount = person.meeting_count || 0; // "events" instead of "meetings"
            const messageCount = person.message_count || 0; // iMessage + WhatsApp combined
            const slackMessageCount = person.slack_message_count || 0; // Actual Slack messages

            document.getElementById('heroStatEmails').textContent = formatCompactNumber(emailCount);
            document.getElementById('heroStatEvents').textContent = formatCompactNumber(eventCount);
            document.getElementById('heroStatMessages').textContent = formatCompactNumber(messageCount);

            // Show Slack stat if person has slack messages
            const slackContainer = document.getElementById('heroStatSlackContainer');
            if (slackContainer) {
                if (slackMessageCount > 0) {
                    slackContainer.style.display = '';
                    document.getElementById('heroStatSlack').textContent = formatCompactNumber(slackMessageCount);
                } else {
                    slackContainer.style.display = 'none';
                }
            }

            // Last seen date (capped at today for future calendar events)
            if (person.last_seen) {
                let lastSeenDate = new Date(person.last_seen);
                const now = new Date();
                // Cap future dates at today
                if (lastSeenDate > now) {
                    document.getElementById('heroStatLastSeen').textContent = 'Today';
                } else {
                    const options = { month: 'short', day: 'numeric' };
                    // Add year if not current year
                    if (lastSeenDate.getFullYear() !== now.getFullYear()) {
                        options.year = 'numeric';
                    }
                    document.getElementById('heroStatLastSeen').textContent = lastSeenDate.toLocaleDateString('en-US', options);
                }
            } else {
                document.getElementById('heroStatLastSeen').textContent = 'â€”';
            }

            // Backwards compat for hidden stats
            document.getElementById('statEmails').textContent = emailCount;
            document.getElementById('statMeetings').textContent = eventCount;
            document.getElementById('statMessages').textContent = messageCount;
            document.getElementById('statNotes').textContent = person.notes ? 1 : 0;
        }

        // Render hero stats for "Me" page with aggregate totals
        async function renderMeHeroStats() {
            try {
                const stats = await api('/me/stats');

                // Show aggregate totals
                document.getElementById('heroStatEmails').textContent = formatCompactNumber(stats.total_emails);
                document.getElementById('heroStatEvents').textContent = formatCompactNumber(stats.total_meetings);
                document.getElementById('heroStatMessages').textContent = formatCompactNumber(stats.total_messages);

                // For "Me", show total people instead of last seen
                document.getElementById('heroStatLastSeen').textContent = `${formatCompactNumber(stats.total_people)} people`;

                // Update backwards compat stats
                document.getElementById('statEmails').textContent = stats.total_emails;
                document.getElementById('statMeetings').textContent = stats.total_meetings;
                document.getElementById('statMessages').textContent = stats.total_messages;
            } catch (error) {
                console.error('Failed to load Me stats:', error);
            }
        }

        // Load all interactions for "Me" page (for client-side processing)
        async function loadMeInteractions(forceRefresh = false) {
            // Use cache only if it matches current heatmapYears setting
            if (meInteractionsCache && meInteractionsCacheYears === heatmapYears && !forceRefresh) {
                return meInteractionsCache;
            }
            try {
                // Fetch data for the selected number of years
                const daysBack = (heatmapYears * 365) + 7;
                const data = await api(`/me/interactions?days_back=${daysBack}&trend_period=${currentTrendPeriod}`);
                meInteractionsCache = data; // Store the whole aggregated response
                meInteractionsCacheYears = heatmapYears; // Remember which setting this was for
                return meInteractionsCache;
            } catch (error) {
                console.error('Failed to load Me interactions:', error);
                return null;
            }
        }

        // Update hero stats from aggregated source totals (called after heatmap loads)
        function updateHeroStatsFromSources() {
            // Combined counts from source totals
            const emailCount = (sourceTotals['gmail'] || 0);
            const eventCount = (sourceTotals['calendar'] || 0);
            const messageCount = (sourceTotals['imessage'] || 0) + (sourceTotals['whatsapp'] || 0);
            const phoneCount = (sourceTotals['phone'] || 0);
            const slackCount = (sourceTotals['slack'] || 0);
            const notesCount = (sourceTotals['vault'] || 0) + (sourceTotals['granola'] || 0);
            const contactsCount = (sourceTotals['contacts'] || 0);
            const linkedinCount = (sourceTotals['linkedin'] || 0);
            const photosCount = (sourceTotals['photos'] || 0);

            // Update main stats (always shown)
            document.getElementById('heroStatEmails').textContent = formatCompactNumber(emailCount);
            document.getElementById('heroStatEvents').textContent = formatCompactNumber(eventCount);
            document.getElementById('heroStatMessages').textContent = formatCompactNumber(messageCount);

            // Show/hide and update additional stats based on whether they have data
            const updateStat = (containerId, valueId, count) => {
                const container = document.getElementById(containerId);
                const value = document.getElementById(valueId);
                if (container && value) {
                    if (count > 0) {
                        container.style.display = '';
                        value.textContent = formatCompactNumber(count);
                    } else {
                        container.style.display = 'none';
                    }
                }
            };

            updateStat('heroStatPhoneContainer', 'heroStatPhone', phoneCount);
            updateStat('heroStatSlackContainer', 'heroStatSlack', slackCount);
            updateStat('heroStatNotesContainer', 'heroStatNotes', notesCount);
            updateStat('heroStatContactsContainer', 'heroStatContacts', contactsCount);
            updateStat('heroStatLinkedInContainer', 'heroStatLinkedIn', linkedinCount);
            updateStat('heroStatPhotosContainer', 'heroStatPhotos', photosCount);

            // Also update backwards compat stats
            document.getElementById('statEmails').textContent = emailCount;
            document.getElementById('statMeetings').textContent = eventCount;
            document.getElementById('statMessages').textContent = messageCount;
            document.getElementById('statNotes').textContent = notesCount;

            // Update timeline filter visibility based on available data
            updateTimelineFilterVisibility();
        }

        // Update secondary hero stats (stats not on PersonEntity) from sourceTotals
        // Called after heatmap loads to show phone, slack, notes, contacts, linkedin, photos
        function updateSecondaryHeroStats() {
            const phoneCount = (sourceTotals['phone'] || 0);
            const slackCount = (sourceTotals['slack'] || 0);
            const notesCount = (sourceTotals['vault'] || 0) + (sourceTotals['granola'] || 0);
            const contactsCount = (sourceTotals['contacts'] || 0);
            const linkedinCount = (sourceTotals['linkedin'] || 0);
            const photosCount = (sourceTotals['photos'] || 0);

            const updateStat = (containerId, valueId, count) => {
                const container = document.getElementById(containerId);
                const value = document.getElementById(valueId);
                if (container && value) {
                    if (count > 0) {
                        container.style.display = '';
                        value.textContent = formatCompactNumber(count);
                    } else {
                        container.style.display = 'none';
                    }
                }
            };

            updateStat('heroStatPhoneContainer', 'heroStatPhone', phoneCount);
            updateStat('heroStatSlackContainer', 'heroStatSlack', slackCount);
            updateStat('heroStatNotesContainer', 'heroStatNotes', notesCount);
            updateStat('heroStatContactsContainer', 'heroStatContacts', contactsCount);
            updateStat('heroStatLinkedInContainer', 'heroStatLinkedIn', linkedinCount);
            updateStat('heroStatPhotosContainer', 'heroStatPhotos', photosCount);
        }

        /**
         * Update timeline filter chip visibility based on available data.
         *
         * When no date filter is active, uses sourceTotals (full counts for the person).
         * When a date filter is active, uses counts from the actual timeline data.
         *
         * This ensures filter chips only show for source types that have data
         * in the current view, preventing users from clicking filters that
         * would show empty results.
         */
        function updateTimelineFilterVisibility() {
            // Check if a date filter is active
            const hasDateFilter = timelineDateRangeFrom || timelineDateRangeTo;

            let emailCount, eventCount, messageCount, phoneCount, slackCount, notesCount, photosCount;

            if (hasDateFilter && timelineData && timelineData.length >= 0) {
                // When date filter is active, count from actual timeline data
                // This ensures we only show filters for types present in the filtered data
                const counts = {};
                for (const item of timelineData) {
                    const sourceType = (item.source_type || '').toLowerCase();
                    counts[sourceType] = (counts[sourceType] || 0) + 1;
                }
                emailCount = counts['gmail'] || 0;
                eventCount = counts['calendar'] || 0;
                messageCount = (counts['imessage'] || 0) + (counts['whatsapp'] || 0);
                phoneCount = counts['phone'] || 0;
                slackCount = counts['slack'] || 0;
                notesCount = (counts['vault'] || 0) + (counts['granola'] || 0);
                photosCount = counts['photos'] || 0;
            } else {
                // No date filter - use global sourceTotals
                emailCount = (sourceTotals['gmail'] || 0);
                eventCount = (sourceTotals['calendar'] || 0);
                messageCount = (sourceTotals['imessage'] || 0) + (sourceTotals['whatsapp'] || 0);
                phoneCount = (sourceTotals['phone'] || 0);
                slackCount = (sourceTotals['slack'] || 0);
                notesCount = (sourceTotals['vault'] || 0) + (sourceTotals['granola'] || 0);
                photosCount = (sourceTotals['photos'] || 0);
            }

            // Show/hide filter chips based on whether there's data
            const updateFilter = (id, count) => {
                const el = document.getElementById(id);
                if (el) el.style.display = count > 0 ? '' : 'none';
            };

            updateFilter('filterGmail', emailCount);
            updateFilter('filterCalendar', eventCount);
            updateFilter('filterMessages', messageCount);
            updateFilter('filterPhone', phoneCount);
            updateFilter('filterSlack', slackCount);
            updateFilter('filterNotes', notesCount);
            updateFilter('filterPhotos', photosCount);
        }

        // Birthday toast - check and show once per day
        async function checkAndShowBirthdayToast() {
            // Check if already dismissed today
            const today = new Date().toISOString().split('T')[0];
            if (localStorage.getItem(`birthdayToastDismissed_${today}`)) {
                return;
            }

            try {
                const data = await api('/birthdays/today');
                if (data.birthdays && data.birthdays.length > 0) {
                    showBirthdayToast(data.birthdays);
                }
            } catch (error) {
                console.warn('Failed to check birthdays:', error);
            }
        }

        function showBirthdayToast(birthdays) {
            const toast = document.getElementById('birthdayToast');
            const message = document.getElementById('birthdayToastMessage');

            // Build message with clickable names
            const names = birthdays.map(p =>
                `<a href="/crm?person=${p.id}">${escapeHtml(p.canonical_name)}</a>`
            );

            let text;
            if (names.length === 1) {
                text = `Happy birthday to ${names[0]}!`;
            } else if (names.length === 2) {
                text = `Happy birthday to ${names[0]} and ${names[1]}!`;
            } else {
                const last = names.pop();
                text = `Happy birthday to ${names.join(', ')}, and ${last}!`;
            }

            message.innerHTML = text;
            toast.style.display = 'flex';
        }

        function dismissBirthdayToast() {
            const toast = document.getElementById('birthdayToast');
            toast.style.display = 'none';

            // Mark as dismissed for today
            const today = new Date().toISOString().split('T')[0];
            localStorage.setItem(`birthdayToastDismissed_${today}`, 'true');
        }

        // Render strength ring (circular progress indicator in header)
        function renderStrengthRing(strength) {
            const strengthValue = Math.round(strength);
            const ringFill = document.getElementById('headerStrengthRingFill');
            const ringValueEl = document.getElementById('headerStrengthValue');
            if (!ringFill || !ringValueEl) return;

            // Circle circumference = 2 * PI * r = 2 * 3.14159 * 18 = 113.1
            const circumference = 113.1;
            const offset = circumference - (circumference * strengthValue / 100);

            ringFill.style.strokeDashoffset = offset;
            ringValueEl.textContent = strengthValue;
        }

        // Render Dunbar circle indicator (in header)
        function renderDunbarCircle(personId) {
            const circleEl = document.getElementById('headerDunbarCircle');
            const labelEl = document.getElementById('headerDunbarLabel');
            if (!circleEl || !labelEl) return;

            const circle = dunbarCircleMap.get(personId) ?? 7;
            circleEl.textContent = circle;
            circleEl.className = `header-dunbar-circle circle-${circle}`;
            circleEl.title = `Dunbar Circle ${circle} (${getDunbarCircleSize(circle)})`;
            labelEl.textContent = getDunbarCircleLabel(circle);
        }

        // Render compact contact info for new two-column layout
        function renderCompactContactInfo(person) {
            const container = document.getElementById('contactInfoCompact');
            if (!container) return;

            let html = '';

            // Emails
            if (person.emails && person.emails.length > 0) {
                html += `
                    <div class="contact-row">
                        <div class="contact-icon-box">ðŸ“§</div>
                        <div class="contact-values">
                            ${person.emails.map(e => `<a href="mailto:${e}" class="contact-value-link">${escapeHtml(e)}</a>`).join('')}
                        </div>
                    </div>
                `;
            }

            // Phone numbers
            if (person.phone_numbers && person.phone_numbers.length > 0) {
                html += `
                    <div class="contact-row">
                        <div class="contact-icon-box">ðŸ“ž</div>
                        <div class="contact-values">
                            ${person.phone_numbers.map(p => `<a href="tel:${p}" class="contact-value-link">${escapeHtml(p)}</a>`).join('')}
                        </div>
                    </div>
                `;
            }

            // LinkedIn
            if (person.linkedin_url) {
                html += `
                    <div class="contact-row">
                        <div class="contact-icon-box">ðŸ”—</div>
                        <div class="contact-values">
                            <a href="${person.linkedin_url}" target="_blank" class="contact-value-link">LinkedIn Profile</a>
                        </div>
                    </div>
                `;
            }

            // Meta info (First Seen, Last Seen, Category)
            const metaItems = [];
            if (person.first_seen) {
                metaItems.push(`
                    <div class="contact-meta-item">
                        <span class="contact-meta-label">First seen</span>
                        <span class="contact-meta-value">${formatDate(person.first_seen)}</span>
                    </div>
                `);
            }
            if (person.last_seen) {
                metaItems.push(`
                    <div class="contact-meta-item">
                        <span class="contact-meta-label">Last seen</span>
                        <span class="contact-meta-value">${formatDate(person.last_seen)}</span>
                    </div>
                `);
            }
            if (person.category) {
                metaItems.push(`
                    <div class="contact-meta-item">
                        <span class="contact-meta-label">Category</span>
                        <span class="contact-meta-value">${escapeHtml(person.category)}</span>
                    </div>
                `);
            }

            if (metaItems.length > 0) {
                html += `<div class="contact-meta-row">${metaItems.join('')}</div>`;
            }

            container.innerHTML = html || '<div style="color: var(--text-muted); font-size: 0.8125rem;">No contact info</div>';
        }

        // Add tag
        async function addTag() {
            const tag = prompt('Enter tag name:');
            if (!tag || !selectedPersonId) return;

            try {
                const person = await api(`/people/${selectedPersonId}`);
                const tags = person.tags || [];
                if (!tags.includes(tag)) {
                    tags.push(tag);
                    await api(`/people/${selectedPersonId}`, {
                        method: 'PATCH',
                        body: JSON.stringify({ tags })
                    });
                    // Update local people array for filtering
                    const localPerson = people.find(p => p.id === selectedPersonId);
                    if (localPerson) localPerson.tags = tags;
                    // Clear search cache so tag changes are reflected in filters
                    clearSearchCache();
                    collectAllTags();
                    await loadPersonDetail(selectedPersonId);
                }
            } catch (error) {
                console.error('Failed to add tag:', error);
            }
        }

        // Remove tag
        async function removeTag(tag) {
            if (!selectedPersonId) return;

            try {
                const person = await api(`/people/${selectedPersonId}`);
                const tags = (person.tags || []).filter(t => t !== tag);
                await api(`/people/${selectedPersonId}`, {
                    method: 'PATCH',
                    body: JSON.stringify({ tags })
                });
                // Update local people array for filtering
                const localPerson = people.find(p => p.id === selectedPersonId);
                if (localPerson) localPerson.tags = tags;
                // Clear search cache so tag changes are reflected in filters
                clearSearchCache();
                collectAllTags();
                await loadPersonDetail(selectedPersonId);
            } catch (error) {
                console.error('Failed to remove tag:', error);
            }
        }

        // Add birthday
        async function addBirthday() {
            const input = prompt('Enter birthday (MM/DD):');
            if (!input || !selectedPersonId) return;

            try {
                // Send as-is - API will parse MM/DD or MM-DD format
                await api(`/people/${selectedPersonId}`, {
                    method: 'PATCH',
                    body: JSON.stringify({ birthday: input.trim() })
                });
                await loadPersonDetail(selectedPersonId);
            } catch (error) {
                console.error('Failed to add birthday:', error);
                alert('Failed to add birthday. Please use format MM/DD (e.g., 08/07 for August 7)');
            }
        }

        // Remove birthday
        async function removeBirthday() {
            if (!selectedPersonId) return;
            if (!confirm('Remove birthday?')) return;

            try {
                await api(`/people/${selectedPersonId}`, {
                    method: 'PATCH',
                    body: JSON.stringify({ birthday: '' })
                });
                await loadPersonDetail(selectedPersonId);
            } catch (error) {
                console.error('Failed to remove birthday:', error);
            }
        }

        // Render relationship strength breakdown
        function renderStrengthBreakdown(person) {
            const strength = person.relationship_strength || 0;
            document.getElementById('strengthBarFill').style.width = `${strength}%`;

            // Calculate components (mock calculation based on available data)
            const components = [
                { icon: 'ðŸ“§', label: 'Emails', value: Math.min(1, (person.email_count || 0) / 50).toFixed(2) },
                { icon: 'ðŸ“…', label: 'Meetings', value: Math.min(1, (person.meeting_count || 0) / 20).toFixed(2) },
                { icon: 'ðŸ•', label: 'Recency', value: calculateRecencyScore(person.last_seen) },
                { icon: 'ðŸ“Š', label: 'Frequency', value: Math.min(1, (person.email_count + person.meeting_count) / 100).toFixed(2) }
            ];

            const componentsEl = document.getElementById('strengthComponents');
            componentsEl.innerHTML = components.map(c => `
                <div class="strength-component">
                    <div class="strength-component-icon">${c.icon}</div>
                    <div class="strength-component-info">
                        <div class="strength-component-label">${c.label}</div>
                        <div class="strength-component-value">${c.value}</div>
                    </div>
                </div>
            `).join('');
        }

        // Calculate recency score (future dates capped at today)
        function calculateRecencyScore(lastSeen) {
            if (!lastSeen) return '0.00';
            const now = new Date();
            let last = new Date(lastSeen);
            // Cap future dates at today
            if (last > now) last = now;
            const daysDiff = (now - last) / (1000 * 60 * 60 * 24);

            if (daysDiff < 7) return '1.00';
            if (daysDiff < 30) return '0.75';
            if (daysDiff < 90) return '0.50';
            if (daysDiff < 180) return '0.25';
            return '0.10';
        }

        // Heatmap data store for tooltips
        let heatmapData = {};
        let sourceTotals = {}; // Total counts per source type from aggregated data
        let heatmapYears = 1; // Number of years to show in heatmap
        let currentHeatmapPersonId = null; // Track current person for heatmap reload

        // Calculate years needed to show all interactions (based on first_seen)
        function calculateHeatmapYearsFromFirstSeen(firstSeen) {
            if (!firstSeen) return 1;

            const firstSeenDate = new Date(firstSeen);
            const now = new Date();

            // Future dates should show 1 year
            if (firstSeenDate > now) return 1;

            const daysSince = Math.floor((now - firstSeenDate) / (1000 * 60 * 60 * 24));

            // Calculate years needed (round up)
            const yearsNeeded = Math.ceil(daysSince / 365);

            // Clamp between 1 and 10
            return Math.max(1, Math.min(10, yearsNeeded));
        }

        // Source type badges mapping
        const SOURCE_BADGES = {
            'imessage': { badge: String.fromCodePoint(0x1F4AC), label: 'iMessages' },
            'gmail': { badge: String.fromCodePoint(0x1F4E7), label: 'Emails' },
            'calendar': { badge: String.fromCodePoint(0x1F4C5), label: 'Events' },
            'slack': { badge: String.fromCodePoint(0x1F4BC), label: 'Slack' },
            'linkedin': { badge: String.fromCodePoint(0x1F517), label: 'LinkedIn' },
            'vault': { badge: String.fromCodePoint(0x1F4DD), label: 'Notes' },
            'granola': { badge: String.fromCodePoint(0x1F4DD), label: 'Notes' },
            'whatsapp': { badge: String.fromCodePoint(0x1F4F1), label: 'WhatsApp' },
            'signal': { badge: String.fromCodePoint(0x1F510), label: 'Signal' },
            'phone': { badge: String.fromCodePoint(0x1F4DE), label: 'Calls' },
            'contacts': { badge: String.fromCodePoint(0x1F4C7), label: 'Contacts' },
            'photos': { badge: String.fromCodePoint(0x1F4F7), label: 'Photos' }
        };

        // Load and render heat map
        async function loadAndRenderHeatMap(personId, years = null, autoSelectYears = false) {
            const grid = document.getElementById('heatmapGrid');
            const monthsContainer = document.getElementById('heatmapMonths');

            // Track if this is a new person (for logging/debugging)
            const isNewPerson = currentHeatmapPersonId !== personId;
            if (isNewPerson) {
                // Data already cleared by clearChartsWithLoading() in selectPerson
                // Just reset hover setup
                const canvas = document.getElementById('volumeChartCanvas');
                if (canvas) {
                    canvas.dataset.hoverSetup = '';
                }
            }

            // Use provided years or current setting
            if (years !== null) {
                heatmapYears = years;
            }
            currentHeatmapPersonId = personId;

            try {
                // For "Me" page, aggregate interactions across all people
                if (isMyPage(personId)) {
                    await loadMeHeatMap();
                    return;
                }

                // Calculate days_back based on years (add buffer for week alignment)
                const daysBack = (heatmapYears * 365) + 7;

                // Use aggregated timeline endpoint for efficient data loading
                const data = await api(`/people/${personId}/timeline/aggregated?days_back=${daysBack}`);
                const days = data.days || [];

                // Build interaction history with source breakdown and calculate totals
                heatmapData = {};
                sourceTotals = {};
                days.forEach(day => {
                    const dateKey = day.date;
                    heatmapData[dateKey] = { total: day.total_count, sources: {} };
                    (day.groups || []).forEach(group => {
                        const sourceType = (group.source_type || 'unknown').toLowerCase();
                        heatmapData[dateKey].sources[sourceType] = group.count;
                        // Accumulate totals
                        sourceTotals[sourceType] = (sourceTotals[sourceType] || 0) + group.count;
                    });
                });

                // Auto-select years based on actual interaction data
                if (autoSelectYears) {
                    const yearsFromData = calculateYearsFromHeatmapData();
                    heatmapYears = yearsFromData;
                    const yearsSelect = document.getElementById('heatmapYearsSelect');
                    if (yearsSelect) yearsSelect.value = yearsFromData.toString();
                }

                // Update title based on years
                const titleEl = document.getElementById('heatmapTitle');
                if (titleEl) {
                    titleEl.textContent = heatmapYears === 1
                        ? '365-Day Interaction History'
                        : `${heatmapYears}-Year Interaction History`;
                }

                renderHeatMap();
                // Update secondary stats (phone, slack, notes, photos, etc.) from heatmap data
                // Main stats (emails, events, messages) already set from PersonEntity lifetime totals
                updateSecondaryHeroStats();
            } catch (error) {
                console.error('Failed to load heat map:', error);
                heatmapData = {};
                sourceTotals = {};
                renderHeatMap();
            }
        }

        // Load and render heatmap for "Me" page (aggregate across all people)
        async function loadMeHeatMap() {
            try {
                const data = await loadMeInteractions();
                if (!data) {
                    heatmapData = {};
                    sourceTotals = {};
                    renderHeatMap();
                    return;
                }

                // Use pre-aggregated daily data from server
                heatmapData = {};
                sourceTotals = data.by_source || {};

                (data.daily || []).forEach(day => {
                    heatmapData[day.date] = { total: day.total, sources: day.sources };
                });

                // For /me page, calculate years from actual interaction data
                const yearsFromData = calculateYearsFromHeatmapData();
                heatmapYears = yearsFromData;
                const yearsSelect = document.getElementById('heatmapYearsSelect');
                if (yearsSelect) yearsSelect.value = yearsFromData.toString();

                // Update title based on calculated years
                const titleEl = document.getElementById('heatmapTitle');
                if (titleEl) {
                    titleEl.textContent = heatmapYears === 1
                        ? '365-Day Interaction History'
                        : `${heatmapYears}-Year Interaction History`;
                }

                renderHeatMap();
                // Don't call updateHeroStatsFromSources for Me page - we already set aggregate stats
            } catch (error) {
                console.error('Failed to load Me heat map:', error);
                heatmapData = {};
                sourceTotals = {};
                renderHeatMap();
            }
        }

        /**
         * Calculate years needed from actual heatmapData dates.
         */
        function calculateYearsFromHeatmapData() {
            const dates = Object.keys(heatmapData).sort();
            if (dates.length === 0) return 1;

            const earliestDate = new Date(dates[0] + 'T12:00:00');
            const now = new Date();
            const daysSince = Math.floor((now - earliestDate) / (1000 * 60 * 60 * 24));
            const yearsNeeded = Math.ceil(daysSince / 365);

            return Math.max(1, Math.min(10, yearsNeeded));
        }

        // Render Me dashboard widgets
        async function renderMeDashboard() {
            const data = await loadMeInteractions();
            if (!data) return;

            // Update hero stats with phone/slack counts from interactions data
            updateMeHeroStatsFromInteractions(data);

            // New widgets
            renderHealthScore(data);
            renderNeglectedContacts(data);
            renderNetworkGrowth(data);
            renderMessagingByCircle(data);
            renderTrackedRelationships(data);

            // Existing widgets
            renderTopContacts(data);
            renderRelationshipTrends(data);
        }

        // ===============================
        // Family Dashboard
        // ===============================

        // Global helper to get dot color based on score relative to average (50)
        function getDotColor(score) {
            if (score >= 80) return '#22c55e';      // Bright green - excellent
            if (score >= 60) return '#86efac';      // Light green - above avg
            if (score >= 40) return '#9ca3af';      // Light gray - around avg
            if (score >= 25) return '#f97316';      // Orange - below avg
            return '#ef4444';                        // Red - poor
        }

        // Family dashboard state
        let familyMembers = [];
        let originalHeaderIndicatorsHtml = null;  // Save original header content for restore
        // Default family members - loaded from API via loadFamilyMembers()
        const DEFAULT_FAMILY_IDS = [];
        let selectedFamilyIds = [];
        let familyHealthPeriod = 'quarter';
        let familyTrendPeriod = 'quarter';
        let familyData = null;

        // Load family members from API
        async function loadFamilyMembers() {
            try {
                const data = await api('/family/members');
                familyMembers = data.members || [];
                return familyMembers;
            } catch (error) {
                console.error('Failed to load family members:', error);
                familyMembers = [];
                return [];
            }
        }

        // Show family dashboard
        async function showFamilyDashboard() {
            // Hide birthdays page and show main container
            document.getElementById('birthdaysPage').style.display = 'none';
            document.getElementById('birthdaysPage').classList.remove('visible');
            document.querySelector('.main-container').style.display = 'flex';

            // Hide other views
            document.getElementById('detailEmpty').style.display = 'none';
            document.getElementById('detailContent').style.display = 'flex';
            document.getElementById('meDashboard').style.display = 'none';
            document.getElementById('meDashboard').classList.remove('visible');
            document.getElementById('personContentGrid').style.display = 'none';

            // Hide the person-level hero stats (they're in tabOverview which stays visible)
            const personHeroStats = document.getElementById('heroStats');
            if (personHeroStats) personHeroStats.style.display = 'none';

            // Show family hero stats (positioned above heatmap)
            const familyHeroStats = document.getElementById('familyHeroStats');
            if (familyHeroStats) familyHeroStats.style.display = '';

            // Show family dashboard
            const familyDashboard = document.getElementById('familyDashboard');
            familyDashboard.style.display = 'block';
            familyDashboard.classList.add('visible');

            // Show heatmap for family view (it will be populated with family data)
            const heatmapContainer = document.querySelector('.heatmap-container');
            if (heatmapContainer) heatmapContainer.style.display = '';

            // Hide source entities footer
            const sourceEntitiesFooter = document.getElementById('sourceEntitiesFooter');
            if (sourceEntitiesFooter) sourceEntitiesFooter.style.display = 'none';

            // Customize header for family (like /me page does)
            const detailAvatar = document.getElementById('detailAvatar');
            const detailName = document.getElementById('detailName');
            const detailCompany = document.getElementById('detailCompany');
            const detailContactQuick = document.getElementById('detailContactQuick');
            const detailTagsChips = document.getElementById('detailTagsChips');
            if (detailAvatar) detailAvatar.textContent = 'ðŸ‘¨â€ðŸ‘©â€ðŸ‘§';
            if (detailName) detailName.textContent = 'Family Dashboard';
            if (detailCompany) detailCompany.textContent = '';
            if (detailContactQuick) detailContactQuick.innerHTML = '';
            if (detailTagsChips) detailTagsChips.innerHTML = '';

            // Hide header indicators for family view (dropdown goes below title now)
            const headerIndicators = document.querySelector('.header-indicators');
            if (headerIndicators) {
                if (originalHeaderIndicatorsHtml === null) {
                    originalHeaderIndicatorsHtml = headerIndicators.innerHTML;
                }
                headerIndicators.style.display = 'none';
            }

            // Put the family selector in the container above hero stats
            const familySelectorContainer = document.getElementById('familySelectorContainer');
            if (familySelectorContainer) {
                familySelectorContainer.style.display = 'block';
                familySelectorContainer.innerHTML = `
                    <div class="family-member-selector">
                        <button class="family-selector-btn" onclick="toggleFamilyDropdown()">
                            <span id="familySelectorLabel">Select family members...</span>
                            <span class="family-selector-arrow">â–¼</span>
                        </button>
                        <div class="family-dropdown" id="familyDropdown" style="display: none;">
                            <div class="family-dropdown-actions">
                                <button class="family-action-btn" onclick="selectAllFamily()">Select All</button>
                                <button class="family-action-btn" onclick="clearAllFamily()">Clear All</button>
                            </div>
                            <div class="family-dropdown-list" id="familyDropdownList"></div>
                        </div>
                    </div>
                `;
            }

            // Show tabs but hide Graph tab (family only has Overview and Timeline)
            const detailTabs = document.querySelector('.detail-tabs');
            if (detailTabs) {
                detailTabs.style.display = '';
                // Hide the Graph tab for family view
                const graphTab = detailTabs.querySelector('[data-tab="graph"]');
                if (graphTab) graphTab.style.display = 'none';
            }

            // Load family members if not already loaded
            if (familyMembers.length === 0) {
                await loadFamilyMembers();
            }

            // Use configured default IDs if available, otherwise all family members
            if (selectedFamilyIds.length === 0 && familyMembers.length > 0) {
                if (FAMILY_DEFAULT_SELECTED_IDS.length > 0) {
                    // Filter to only valid IDs that exist in familyMembers
                    const validIds = FAMILY_DEFAULT_SELECTED_IDS.filter(id =>
                        familyMembers.some(m => m.id === id)
                    );
                    selectedFamilyIds = validIds.length > 0 ? validIds : familyMembers.map(m => m.id);
                } else {
                    selectedFamilyIds = familyMembers.map(m => m.id);
                }
            }

            // Render dropdown AFTER defaults are set so checkboxes reflect selection
            renderFamilyDropdown();
            updateFamilySelectorLabel();

            // Fetch up to 10 years of data initially (like person/me pages)
            // The actual years will be auto-calculated from the data
            heatmapYears = 10;

            // Set years dropdown to 10 years on initial load
            const yearsSelect = document.getElementById('heatmapYearsSelect');
            if (yearsSelect) yearsSelect.value = '10';

            // Load lifetime stats (hero stats) - these are independent of year selection
            await loadFamilyStats();

            // Load time-bounded interaction data for heatmap/charts
            await loadFamilyInteractions();
        }

        // ============================================
        // RELATIONSHIP DASHBOARD (Partner)
        // ============================================

        // Partner's person ID (loaded from API config)
        let PARTNER_PERSON_ID = '';

        // =============================================================================
        // Birthdays Page
        // =============================================================================

        let birthdaysData = null;
        let birthdayFilter = null;

        async function showBirthdaysPage(filterDay = null) {
            // Hide other views - hide the main-container entirely since birthdays is a standalone page
            document.querySelector('.main-container').style.display = 'none';

            birthdayFilter = filterDay;

            // Show birthdays page
            const page = document.getElementById('birthdaysPage');
            page.style.display = 'block';
            page.classList.add('visible');

            // Load data
            await loadBirthdaysData();

            // If filter provided, switch to timeline tab
            if (filterDay) {
                switchBirthdaysTab('timeline');
            }
        }

        async function loadBirthdaysData() {
            try {
                birthdaysData = await api('/birthdays/all');

                // Update stats
                document.getElementById('birthdaysTotalPeople').textContent = birthdaysData.total_people;
                document.getElementById('birthdaysTotalDates').textContent = birthdaysData.total_dates;

                // Render both views
                renderBirthdayHeatmap();
                renderBirthdayTimeline();
            } catch (error) {
                console.error('Failed to load birthdays:', error);
            }
        }

        function renderBirthdayHeatmap() {
            const container = document.getElementById('birthdayHeatmapMonths');
            container.innerHTML = '';

            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                            'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const daysInMonth = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

            // Get today's MM-DD for highlighting
            const now = new Date();
            const todayMmdd = `${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;

            months.forEach((monthName, monthIndex) => {
                const monthDiv = document.createElement('div');
                monthDiv.className = 'birthday-heatmap-month';

                const label = document.createElement('div');
                label.className = 'birthday-heatmap-month-label';
                label.textContent = monthName;
                monthDiv.appendChild(label);

                const daysDiv = document.createElement('div');
                daysDiv.className = 'birthday-heatmap-days';

                for (let day = 1; day <= daysInMonth[monthIndex]; day++) {
                    const mmdd = `${String(monthIndex + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                    const people = birthdaysData.birthdays[mmdd] || [];
                    const count = people.length;

                    const dayDiv = document.createElement('div');
                    dayDiv.className = 'birthday-heatmap-day';
                    dayDiv.dataset.date = mmdd;

                    // Mark today
                    if (mmdd === todayMmdd) {
                        dayDiv.classList.add('today');
                    }

                    // Mark days with birthdays
                    if (count > 0) {
                        dayDiv.classList.add('has-birthday');
                    }

                    if (count > 0) {
                        dayDiv.addEventListener('mouseenter', showBirthdayHeatmapTooltip);
                        dayDiv.addEventListener('mouseleave', hideBirthdayHeatmapTooltip);
                        dayDiv.addEventListener('click', () => {
                            filterBirthdaysByDate(mmdd);
                        });
                    }

                    daysDiv.appendChild(dayDiv);
                }

                monthDiv.appendChild(daysDiv);
                container.appendChild(monthDiv);
            });
        }

        function showBirthdayHeatmapTooltip(e) {
            const day = e.target;
            const date = day.dataset.date;
            const people = birthdaysData.birthdays[date] || [];

            if (people.length === 0) return;

            // Remove existing tooltip
            hideBirthdayHeatmapTooltip();

            const tooltip = document.createElement('div');
            tooltip.className = 'birthday-heatmap-tooltip';
            tooltip.id = 'birthdayHeatmapTooltip';

            // Format date nicely
            const [month, dayNum] = date.split('-');
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                                'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const dateStr = `${monthNames[parseInt(month) - 1]} ${parseInt(dayNum)}`;

            tooltip.innerHTML = `
                <div class="birthday-heatmap-tooltip-date">${dateStr}</div>
                <div class="birthday-heatmap-tooltip-names">${people.map(p => escapeHtml(p.name)).join(', ')}</div>
            `;

            document.body.appendChild(tooltip);

            // Position tooltip
            const rect = day.getBoundingClientRect();
            tooltip.style.left = `${rect.left + rect.width / 2}px`;
            tooltip.style.top = `${rect.bottom + 8}px`;
            tooltip.style.transform = 'translateX(-50%)';
        }

        function hideBirthdayHeatmapTooltip() {
            const tooltip = document.getElementById('birthdayHeatmapTooltip');
            if (tooltip) tooltip.remove();
        }

        function filterBirthdaysByDate(mmdd) {
            birthdayFilter = mmdd;
            switchBirthdaysTab('timeline');
            renderBirthdayTimeline();

            // Update URL
            const url = new URL(window.location);
            url.searchParams.set('day', mmdd);
            history.pushState({}, '', url);
        }

        function clearBirthdayFilter() {
            birthdayFilter = null;
            renderBirthdayTimeline();

            // Update URL
            const url = new URL(window.location);
            url.searchParams.delete('day');
            history.pushState({}, '', url);
        }

        function renderBirthdayTimeline() {
            const container = document.getElementById('birthdayTimeline');
            const filterDiv = document.getElementById('birthdayTimelineFilter');
            const filterDateSpan = document.getElementById('birthdayFilterDate');

            container.innerHTML = '';

            // Get sorted dates
            let dates = Object.keys(birthdaysData.birthdays).sort();

            // Apply filter if set
            if (birthdayFilter) {
                dates = dates.filter(d => d === birthdayFilter);
                filterDiv.style.display = 'flex';

                // Format filter date
                const [month, day] = birthdayFilter.split('-');
                const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                                    'July', 'August', 'September', 'October', 'November', 'December'];
                filterDateSpan.textContent = `${monthNames[parseInt(month) - 1]} ${parseInt(day)}`;
            } else {
                filterDiv.style.display = 'none';
            }

            if (dates.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 2rem;">No birthdays found</div>';
                return;
            }

            dates.forEach(date => {
                const people = birthdaysData.birthdays[date];
                const entry = document.createElement('div');
                entry.className = 'birthday-timeline-entry';
                if (people.length === 1) {
                    entry.classList.add('single', 'expanded');
                }

                // Format date
                const [month, day] = date.split('-');
                const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                                    'July', 'August', 'September', 'October', 'November', 'December'];
                const dateStr = `${monthNames[parseInt(month) - 1]} ${parseInt(day)}`;

                entry.innerHTML = `
                    <div class="birthday-timeline-header" onclick="toggleBirthdayEntry(this.parentElement)">
                        <span class="birthday-timeline-date">${dateStr}</span>
                        ${people.length > 1 ? `<span class="birthday-timeline-count">${people.length} people</span>` : ''}
                    </div>
                    <div class="birthday-timeline-people">
                        ${people.map(p => `
                            <div class="birthday-timeline-person" onclick="navigateToPerson('${p.id}')">
                                <div class="birthday-timeline-avatar">
                                    ${getBirthdayInitials(p.name)}
                                </div>
                                <span class="birthday-timeline-name">${escapeHtml(p.name)}</span>
                            </div>
                        `).join('')}
                    </div>
                `;

                container.appendChild(entry);
            });
        }

        function toggleBirthdayEntry(entry) {
            if (entry.classList.contains('single')) {
                // Single person - navigate directly
                const personDiv = entry.querySelector('.birthday-timeline-person');
                if (personDiv) personDiv.click();
                return;
            }
            entry.classList.toggle('expanded');
        }

        function switchBirthdaysTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.birthdays-tab').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tab);
            });

            // Update tab content
            document.getElementById('birthdaysHeatmapTab').style.display = tab === 'heatmap' ? 'block' : 'none';
            document.getElementById('birthdaysTimelineTab').style.display = tab === 'timeline' ? 'block' : 'none';
        }

        function getBirthdayInitials(name) {
            if (!name) return '?';
            const parts = name.split(' ').filter(Boolean);
            if (parts.length >= 2) {
                return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
            }
            return name.substring(0, 2).toUpperCase();
        }

        function navigateToPerson(personId) {
            // Navigate to the person's profile page
            window.location.href = `/crm/${personId}`;
        }

        // Tab click handler for birthdays page
        document.querySelectorAll('.birthdays-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                switchBirthdaysTab(tab.dataset.tab);
            });
        });

        // Cache for relationship data
        let relationshipInsightsCache = null;
        let relationshipTimelineCache = null;
        let relationshipToneCache = null;

        // Show relationship dashboard for configured partner
        async function showRelationshipDashboard() {
            // Hide birthdays page and show main container
            document.getElementById('birthdaysPage').style.display = 'none';
            document.getElementById('birthdaysPage').classList.remove('visible');
            document.querySelector('.main-container').style.display = 'flex';

            // Hide other views
            document.getElementById('detailEmpty').style.display = 'none';
            document.getElementById('detailContent').style.display = 'flex';
            document.getElementById('meDashboard').style.display = 'none';
            document.getElementById('meDashboard').classList.remove('visible');
            document.getElementById('familyDashboard').style.display = 'none';
            document.getElementById('familyDashboard').classList.remove('visible');
            document.getElementById('personContentGrid').style.display = 'none';

            // Hide person-level hero stats
            const personHeroStats = document.getElementById('heroStats');
            if (personHeroStats) personHeroStats.style.display = 'none';

            // Hide family hero stats and selector
            const familyHeroStats = document.getElementById('familyHeroStats');
            if (familyHeroStats) familyHeroStats.style.display = 'none';
            const familySelectorContainer = document.getElementById('familySelectorContainer');
            if (familySelectorContainer) familySelectorContainer.style.display = 'none';

            // Show relationship dashboard
            const relationshipDashboard = document.getElementById('relationshipDashboard');
            relationshipDashboard.style.display = 'block';
            relationshipDashboard.classList.add('visible');

            // Hide heatmap for relationship view (not needed here)
            const heatmapContainer = document.querySelector('.heatmap-container');
            if (heatmapContainer) heatmapContainer.style.display = 'none';

            // Hide source entities footer
            const sourceEntitiesFooter = document.getElementById('sourceEntitiesFooter');
            if (sourceEntitiesFooter) sourceEntitiesFooter.style.display = 'none';

            // Customize header for relationship view
            const detailAvatar = document.getElementById('detailAvatar');
            const detailName = document.getElementById('detailName');
            const detailCompany = document.getElementById('detailCompany');
            const detailContactQuick = document.getElementById('detailContactQuick');
            const detailTagsChips = document.getElementById('detailTagsChips');
            if (detailName) detailName.textContent = 'Relationship Dashboard';
            if (detailCompany) detailCompany.textContent = PARTNER_NAME || 'Partner';
            if (detailContactQuick) detailContactQuick.innerHTML = '';
            if (detailTagsChips) detailTagsChips.innerHTML = '';

            // Load partner photo if available, otherwise show heart emoji
            if (detailAvatar) {
                detailAvatar.textContent = 'ðŸ’•';  // Default fallback
                loadRelationshipPartnerPhoto(PARTNER_PERSON_ID);
            }

            // Hide header indicators
            const headerIndicators = document.querySelector('.header-indicators');
            if (headerIndicators) {
                if (originalHeaderIndicatorsHtml === null) {
                    originalHeaderIndicatorsHtml = headerIndicators.innerHTML;
                }
                headerIndicators.style.display = 'none';
            }

            // Hide tabs (relationship page is single-view)
            const detailTabs = document.querySelector('.detail-tabs');
            if (detailTabs) {
                detailTabs.style.display = 'none';
            }

            // Load all data
            await Promise.all([
                loadRelationshipInsights(),
                loadRelationshipTimeline(),
                loadToneAnalysis(),
            ]);

            // Render visualizations
            renderIMessageBalance();
            renderIntensityWaves();
            renderWeeklyRhythm();
            renderChannelFlow();
            renderDepthBubbles();
        }

        // Category to container ID mapping
        const INSIGHT_PANEL_IDS = {
            'for_me': 'insightsForMe',
            'for_partner': 'insightsForPartner',
            'ai_suggestions': 'insightsAiSuggestions',
            'growth_patterns': 'insightsGrowth',
            'recurring_themes': 'insightsThemes',
            'relationship_strengths': 'insightsStrengths',
            // Legacy mappings - merge into new categories for display
            'focus_areas': 'insightsForMe',
            'action_items': 'insightsForMe',
            'for_taylor': 'insightsForPartner',  // Legacy support
        };

        // Load relationship insights from therapy notes
        async function loadRelationshipInsights() {
            try {
                const data = await api('/relationship/insights');
                relationshipInsightsCache = data;
                renderRelationshipInsights(data);
            } catch (error) {
                console.error('Failed to load relationship insights:', error);
                // Show empty state in all panels
                Object.values(INSIGHT_PANEL_IDS).forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.innerHTML = '<div class="insight-panel-empty"><div class="insight-panel-empty-icon">ðŸ“</div>Click â†» to generate</div>';
                });
            }
        }

        // Render a single insight item
        function renderInsightItem(insight) {
            const confirmedClass = insight.confirmed ? 'insight-confirmed' : '';
            const sourceLink = insight.source_link
                ? `<a href="${insight.source_link}" class="insight-source-link" target="_blank">${escapeHtml(insight.source_title || 'Source')}</a>`
                : (insight.source_title ? `<span class="insight-source-text">${escapeHtml(insight.source_title)}</span>` : '');

            return `
                <div class="insight-item ${confirmedClass}" data-id="${insight.id}">
                    <div class="insight-content">
                        <div class="insight-text">${escapeHtml(insight.text)}</div>
                        ${sourceLink}
                    </div>
                    <div class="insight-actions">
                        ${!insight.confirmed ? `<button class="insight-btn confirm" onclick="confirmInsight('${insight.id}')" title="Confirm">âœ“</button>` : ''}
                        <button class="insight-btn dismiss" onclick="dismissInsight('${insight.id}')" title="${insight.confirmed ? 'Delete' : 'Dismiss'}">âœ•</button>
                    </div>
                </div>
            `;
        }

        // Render insights into their respective panels
        function renderRelationshipInsights(data) {
            // Clear all panels first
            const panelIds = new Set(Object.values(INSIGHT_PANEL_IDS));
            panelIds.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.innerHTML = '';
            });

            if (!data || !data.insights || data.insights.length === 0) {
                panelIds.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.innerHTML = '<div class="insight-panel-empty"><div class="insight-panel-empty-icon">ðŸ“</div>Click â†» to generate</div>';
                });
                return;
            }

            // Group by category
            const byCategory = {};
            data.insights.forEach(insight => {
                const cat = insight.category;
                if (!byCategory[cat]) byCategory[cat] = [];
                byCategory[cat].push(insight);
            });

            // Render each category into its panel
            const mainCategories = ['for_me', 'for_partner', 'ai_suggestions', 'growth_patterns', 'recurring_themes', 'relationship_strengths'];

            mainCategories.forEach(category => {
                const containerId = INSIGHT_PANEL_IDS[category];
                const container = document.getElementById(containerId);
                if (!container) return;

                const insights = byCategory[category] || [];

                if (insights.length === 0) {
                    container.innerHTML = '<div class="insight-panel-empty"><div class="insight-panel-empty-icon">ðŸ“</div>Click â†» to generate</div>';
                } else {
                    container.innerHTML = insights.map(renderInsightItem).join('');
                }
            });

            // Handle legacy categories - merge into For Me panel
            const legacyCategories = ['focus_areas', 'action_items'];
            const forMeContainer = document.getElementById('insightsForMe');
            if (forMeContainer) {
                legacyCategories.forEach(category => {
                    const insights = byCategory[category] || [];
                    if (insights.length > 0) {
                        // Append to existing content
                        forMeContainer.innerHTML += insights.map(renderInsightItem).join('');
                    }
                });
            }
        }

        // Refresh a specific insight category
        async function refreshInsightCategory(category) {
            const containerId = INSIGHT_PANEL_IDS[category];
            const container = document.getElementById(containerId);
            const btn = event?.target?.closest('.insight-panel-refresh');

            if (btn) {
                btn.classList.add('loading');
                btn.disabled = true;
            }
            if (container) {
                container.innerHTML = '<div class="insight-panel-loading">Generating with Claude...</div>';
            }

            try {
                const data = await api(`/relationship/insights/generate?category=${category}`, { method: 'POST' });

                // Update cache
                if (relationshipInsightsCache && data.insights) {
                    // Remove old insights of this category from cache
                    relationshipInsightsCache.insights = relationshipInsightsCache.insights.filter(i => i.category !== category);
                    // Add new ones
                    relationshipInsightsCache.insights.push(...data.insights);
                } else {
                    relationshipInsightsCache = data;
                }

                // Re-render just this panel
                const insights = data.insights?.filter(i => i.category === category) || [];
                if (container) {
                    if (insights.length === 0) {
                        container.innerHTML = '<div class="insight-panel-empty"><div class="insight-panel-empty-icon">ðŸ“</div>No insights found</div>';
                    } else {
                        container.innerHTML = insights.map(renderInsightItem).join('');
                    }
                }
            } catch (error) {
                console.error(`Failed to refresh ${category}:`, error);
                if (container) {
                    container.innerHTML = '<div class="insight-panel-empty"><div class="insight-panel-empty-icon">âš ï¸</div>Failed to generate</div>';
                }
            } finally {
                if (btn) {
                    btn.classList.remove('loading');
                    btn.disabled = false;
                }
            }
        }

        // Confirm an insight
        async function confirmInsight(insightId) {
            try {
                await api(`/relationship/insights/${insightId}/confirm`, { method: 'POST' });
                // Update local cache
                if (relationshipInsightsCache) {
                    const insight = relationshipInsightsCache.insights.find(i => i.id === insightId);
                    if (insight) insight.confirmed = true;
                    renderRelationshipInsights(relationshipInsightsCache);
                }
            } catch (error) {
                console.error('Failed to confirm insight:', error);
            }
        }

        // Dismiss an insight
        async function dismissInsight(insightId) {
            try {
                await api(`/relationship/insights/${insightId}`, { method: 'DELETE' });
                // Update local cache
                if (relationshipInsightsCache) {
                    relationshipInsightsCache.insights = relationshipInsightsCache.insights.filter(i => i.id !== insightId);
                    renderRelationshipInsights(relationshipInsightsCache);
                }
            } catch (error) {
                console.error('Failed to dismiss insight:', error);
            }
        }

        // Load relationship timeline for visualizations
        async function loadRelationshipTimeline() {
            try {
                // Get data for visualizations (API max limit is 2000)
                const data = await api(`/people/${PARTNER_PERSON_ID}/timeline?limit=2000`);
                relationshipTimelineCache = data.items || [];
            } catch (error) {
                console.error('Failed to load relationship timeline:', error);
                relationshipTimelineCache = [];
            }
        }

        // Tone view mode: 'user', 'partner', 'combined', 'both'
        let toneViewMode = 'combined';

        // Load tone analysis (detailed version with separate user/partner scores)
        async function loadToneAnalysis() {
            const container = document.getElementById('toneTimelineViz');
            try {
                const data = await api('/relationship/tone-analysis-detailed', { method: 'POST' });
                relationshipToneCache = data;
                renderToneTimeline(data);
            } catch (error) {
                console.error('Failed to load tone analysis:', error);
                container.innerHTML = '<div class="viz-loading">Unable to analyze tone</div>';
            }
        }

        // Handle tone view mode change
        function setToneViewMode(mode) {
            toneViewMode = mode;
            if (relationshipToneCache) {
                renderToneTimeline(relationshipToneCache);
            }
            // Update active state on dropdown items
            document.querySelectorAll('.tone-view-option').forEach(el => {
                el.classList.toggle('active', el.dataset.mode === mode);
            });
        }

        // Render iMessage dynamics (merged balance + flow with nuanced initiation detection)
        function renderIMessageBalance() {
            const container = document.getElementById('imessageBalanceViz');
            const timeline = relationshipTimelineCache || [];

            // Filter to iMessage only and sort by timestamp
            const iMessages = timeline
                .filter(i => i.source_type === 'imessage')
                .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            if (iMessages.length === 0) {
                container.innerHTML = '<div class="viz-loading">No iMessage data available</div>';
                return;
            }

            // Calculate nuanced metrics
            let sentByMe = 0;
            let sentByPartner = 0;
            let conversationsStartedByMe = 0;
            let conversationsStartedByPartner = 0;
            let myResponseCount = 0;
            let partnerResponseCount = 0;

            // Gap threshold for "new conversation" (4 hours in ms)
            const CONVERSATION_GAP = 4 * 60 * 60 * 1000;

            let lastTimestamp = null;
            let lastSender = null;

            iMessages.forEach((msg, idx) => {
                const isFromMe = msg.title && msg.title.startsWith('â†’');
                const isFromPartner = msg.title && msg.title.startsWith('â†');
                const timestamp = new Date(msg.timestamp);

                if (isFromMe) {
                    sentByMe++;
                } else if (isFromPartner) {
                    sentByPartner++;
                }

                // Detect conversation starts (first message after gap or first ever)
                if (lastTimestamp === null || (timestamp - lastTimestamp) > CONVERSATION_GAP) {
                    // New conversation
                    if (isFromMe) {
                        conversationsStartedByMe++;
                    } else if (isFromPartner) {
                        conversationsStartedByPartner++;
                    }
                } else {
                    // Same conversation - track responses (sender changed)
                    if (lastSender !== null) {
                        if (isFromMe && lastSender === 'partner') {
                            myResponseCount++;
                        } else if (isFromPartner && lastSender === 'me') {
                            partnerResponseCount++;
                        }
                    }
                }

                lastTimestamp = timestamp;
                lastSender = isFromMe ? 'me' : (isFromPartner ? 'partner' : lastSender);
            });

            const totalMessages = sentByMe + sentByPartner;
            const totalConversations = conversationsStartedByMe + conversationsStartedByPartner;

            const meMessagePercent = totalMessages > 0 ? Math.round((sentByMe / totalMessages) * 100) : 50;
            const meInitiatePercent = totalConversations > 0 ? Math.round((conversationsStartedByMe / totalConversations) * 100) : 50;

            // Color based on balance (green = balanced, orange = skewed)
            const messageBalanceColor = Math.abs(meMessagePercent - 50) <= 15 ? '#2a9d8f' : '#f4a261';
            const initiateBalanceColor = Math.abs(meInitiatePercent - 50) <= 15 ? '#2a9d8f' : '#f4a261';

            container.innerHTML = `
                <div class="imessage-dynamics-container">
                    <div class="dynamics-row">
                        <div class="dynamics-metric">
                            <div class="dynamics-label">Conversation Starters</div>
                            <div class="dynamics-bar-container">
                                <div class="dynamics-bar-label">You</div>
                                <div class="dynamics-bar">
                                    <div class="dynamics-bar-fill" style="width: ${meInitiatePercent}%; background: ${initiateBalanceColor};"></div>
                                </div>
                                <div class="dynamics-bar-value">${conversationsStartedByMe}</div>
                            </div>
                            <div class="dynamics-bar-container">
                                <div class="dynamics-bar-label">Partner</div>
                                <div class="dynamics-bar">
                                    <div class="dynamics-bar-fill" style="width: ${100 - meInitiatePercent}%; background: ${initiateBalanceColor}; opacity: 0.6;"></div>
                                </div>
                                <div class="dynamics-bar-value">${conversationsStartedByPartner}</div>
                            </div>
                            <div class="dynamics-insight">${meInitiatePercent > 55 ? 'You reach out more often' : meInitiatePercent < 45 ? 'Partner reaches out more often' : 'Balanced initiation'}</div>
                        </div>
                        <div class="dynamics-metric">
                            <div class="dynamics-label">Message Volume</div>
                            <div class="dynamics-bar-container">
                                <div class="dynamics-bar-label">You</div>
                                <div class="dynamics-bar">
                                    <div class="dynamics-bar-fill" style="width: ${meMessagePercent}%; background: ${messageBalanceColor};"></div>
                                </div>
                                <div class="dynamics-bar-value">${sentByMe.toLocaleString()}</div>
                            </div>
                            <div class="dynamics-bar-container">
                                <div class="dynamics-bar-label">Partner</div>
                                <div class="dynamics-bar">
                                    <div class="dynamics-bar-fill" style="width: ${100 - meMessagePercent}%; background: ${messageBalanceColor}; opacity: 0.6;"></div>
                                </div>
                                <div class="dynamics-bar-value">${sentByPartner.toLocaleString()}</div>
                            </div>
                            <div class="dynamics-insight">${Math.abs(meMessagePercent - 50) <= 10 ? 'Well balanced conversation' : meMessagePercent > 50 ? 'You send more messages' : 'Partner sends more messages'}</div>
                        </div>
                    </div>
                    <div class="dynamics-summary">
                        <span class="dynamics-summary-stat">${totalConversations} conversations</span>
                        <span class="dynamics-summary-divider">â€¢</span>
                        <span class="dynamics-summary-stat">${totalMessages.toLocaleString()} messages</span>
                    </div>
                </div>
            `;
        }

        // Render tone evolution timeline with view mode support
        function renderToneTimeline(data) {
            const container = document.getElementById('toneTimelineViz');

            if (!data || !data.monthly_tones || data.monthly_tones.length === 0) {
                container.innerHTML = '<div class="viz-loading">No tone data available</div>';
                return;
            }

            const tones = data.monthly_tones;

            // Chart dimensions
            const width = 420;
            const height = 200;
            const leftMargin = 70;
            const rightMargin = 15;
            const topMargin = 20;
            const bottomMargin = 35;
            const chartWidth = width - leftMargin - rightMargin;
            const chartHeight = height - topMargin - bottomMargin;

            // Helper to get score based on view mode
            const getScore = (t) => {
                if (toneViewMode === 'user') return t.user_score ?? t.score ?? 50;
                if (toneViewMode === 'partner') return t.partner_score ?? t.score ?? 50;
                if (toneViewMode === 'combined') return t.combined_score ?? t.score ?? 50;
                return t.combined_score ?? t.score ?? 50;
            };

            // Build points for a given score function
            const buildPoints = (scoreFn) => {
                return tones.map((t, i) => {
                    const score = scoreFn(t);
                    const x = leftMargin + (i / Math.max(1, tones.length - 1)) * chartWidth;
                    const y = topMargin + chartHeight - (score / 100) * chartHeight;
                    return { x, y, score, month: t.month };
                });
            };

            // Build smooth line path
            const buildLinePath = (points) => {
                if (points.length === 0) return '';
                let path = `M ${points[0].x} ${points[0].y}`;
                for (let i = 1; i < points.length; i++) {
                    const p0 = points[i - 1];
                    const p1 = points[i];
                    const cpX = (p0.x + p1.x) / 2;
                    path += ` C ${cpX} ${p0.y}, ${cpX} ${p1.y}, ${p1.x} ${p1.y}`;
                }
                return path;
            };

            // Colors
            const userColor = '#3b82f6';  // Blue
            const partnerColor = '#ec4899';  // Pink
            const combinedColor = '#8b5cf6'; // Purple

            // Build lines based on view mode
            let lines = [];
            let legendItems = [];

            if (toneViewMode === 'both') {
                lines.push({ points: buildPoints(t => t.user_score ?? 50), color: userColor, label: 'Me' });
                lines.push({ points: buildPoints(t => t.partner_score ?? 50), color: partnerColor, label: 'Partner' });
                legendItems = [{ color: userColor, label: 'Me' }, { color: partnerColor, label: 'Partner' }];
            } else {
                const color = toneViewMode === 'user' ? userColor : toneViewMode === 'partner' ? partnerColor : combinedColor;
                lines.push({ points: buildPoints(getScore), color, label: toneViewMode });
            }

            // Averages
            const userAvg = data.user_average ?? 50;
            const partnerAvg = data.partner_average ?? 50;
            const combinedAvg = (userAvg + partnerAvg) / 2;

            // Grid lines
            const gridLines = [0, 25, 50, 75, 100].map(val => {
                const y = topMargin + chartHeight - (val / 100) * chartHeight;
                return `<line x1="${leftMargin}" y1="${y}" x2="${width - rightMargin}" y2="${y}" stroke="var(--border-subtle)" stroke-width="1" stroke-dasharray="${val === 50 ? '0' : '3,3'}" opacity="${val === 50 ? 0.5 : 0.3}" />`;
            }).join('');

            // Y-axis labels
            const yAxisLabels = `
                <text x="${leftMargin - 8}" y="${topMargin + 4}" text-anchor="end" style="font-size: 0.55rem; fill: #2a9d8f;">Warm &</text>
                <text x="${leftMargin - 8}" y="${topMargin + 11}" text-anchor="end" style="font-size: 0.55rem; fill: #2a9d8f;">Supportive</text>
                <text x="${leftMargin - 8}" y="${topMargin + chartHeight / 2 + 3}" text-anchor="end" style="font-size: 0.55rem; fill: var(--text-muted);">Neutral</text>
                <text x="${leftMargin - 8}" y="${topMargin + chartHeight - 6}" text-anchor="end" style="font-size: 0.55rem; fill: #e94560;">Cold &</text>
                <text x="${leftMargin - 8}" y="${topMargin + chartHeight + 1}" text-anchor="end" style="font-size: 0.55rem; fill: #e94560;">Dismissive</text>
            `;

            // X-axis month labels
            const showEvery = tones.length > 8 ? 2 : 1;
            const monthLabels = tones.map((t, i) => {
                if (i % showEvery !== 0 && i !== tones.length - 1) return '';
                const x = leftMargin + (i / Math.max(1, tones.length - 1)) * chartWidth;
                const monthName = new Date(t.month + '-01').toLocaleDateString('en-US', { month: 'short' });
                return `<text x="${x}" y="${height - 8}" text-anchor="middle" style="font-size: 0.55rem; fill: var(--text-muted);">${monthName}</text>`;
            }).join('');

            // Build SVG paths and points
            let pathsSvg = '';
            let pointsSvg = '';
            lines.forEach(line => {
                const path = buildLinePath(line.points);
                pathsSvg += `<path d="${path}" fill="none" stroke="${line.color}" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" opacity="0.9" />`;
                line.points.forEach((p, i) => {
                    pointsSvg += `<circle cx="${p.x}" cy="${p.y}" r="4" fill="${line.color}" class="tone-data-point"><title>${tones[i].month} (${line.label}): ${Math.round(p.score)}</title></circle>`;
                });
            });

            // Legend for "both" mode
            const legendHtml = legendItems.length > 0 ? `
                <div style="display: flex; justify-content: center; gap: 1rem; margin-top: 0.25rem;">
                    ${legendItems.map(item => `<div style="display: flex; align-items: center; gap: 0.25rem; font-size: 0.65rem; color: var(--text-muted);"><span style="width: 10px; height: 3px; background: ${item.color}; border-radius: 2px;"></span>${item.label}</div>`).join('')}
                </div>` : '';

            // Summary
            let summaryText = '';
            if (toneViewMode === 'user') summaryText = `My avg: ${Math.round(userAvg)} Â· Trend: ${data.user_trend?.replace('-', ' ') || 'variable'}`;
            else if (toneViewMode === 'partner') summaryText = `Partner avg: ${Math.round(partnerAvg)} Â· Trend: ${data.partner_trend?.replace('-', ' ') || 'variable'}`;
            else if (toneViewMode === 'both') summaryText = `Me: ${Math.round(userAvg)} Â· Partner: ${Math.round(partnerAvg)}`;
            else summaryText = `Shared avg: ${Math.round(combinedAvg)} Â· Trend: ${data.combined_trend?.replace('-', ' ') || 'variable'}`;

            container.innerHTML = `
                <div class="tone-timeline-container">
                    <svg class="tone-timeline-svg" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">
                        ${gridLines}
                        ${yAxisLabels}
                        ${monthLabels}
                        ${pathsSvg}
                        ${pointsSvg}
                    </svg>
                    ${legendHtml}
                    <div style="text-align: center; font-size: 0.65rem; color: var(--text-muted); margin-top: 0.25rem;">${summaryText}</div>
                </div>
            `;
        }

        // Render intensity waves (EKG-style)
        function renderIntensityWaves() {
            const container = document.getElementById('intensityWavesViz');
            const timeline = relationshipTimelineCache || [];

            if (timeline.length === 0) {
                container.innerHTML = '<div class="viz-loading">No data available</div>';
                return;
            }

            // Find actual date range in the data
            const dates = timeline.map(item => new Date(item.timestamp));
            const minDate = new Date(Math.min(...dates));
            const maxDate = new Date(Math.max(...dates));

            // Aggregate by day within the actual data range
            const dayMs = 24 * 60 * 60 * 1000;
            const totalDays = Math.ceil((maxDate - minDate) / dayMs) + 1;
            const dayCounts = new Array(totalDays).fill(0);

            timeline.forEach(item => {
                const date = new Date(item.timestamp);
                const dayIndex = Math.floor((date - minDate) / dayMs);
                if (dayIndex >= 0 && dayIndex < totalDays) {
                    dayCounts[dayIndex]++;
                }
            });

            // Smooth by using 3-day rolling average for cleaner waves
            const smoothedCounts = dayCounts.map((count, i) => {
                const start = Math.max(0, i - 1);
                const end = Math.min(dayCounts.length - 1, i + 1);
                let sum = 0, n = 0;
                for (let j = start; j <= end; j++) {
                    sum += dayCounts[j];
                    n++;
                }
                return sum / n;
            });

            const maxCount = Math.max(...smoothedCounts, 1);
            const width = 400;
            const height = 120;

            // Build SVG path for wave with actual data points
            // Sample to ~60 points for smooth rendering
            const sampleRate = Math.max(1, Math.floor(totalDays / 60));
            const sampledCounts = [];
            for (let i = 0; i < totalDays; i += sampleRate) {
                const end = Math.min(i + sampleRate, totalDays);
                let sum = 0;
                for (let j = i; j < end; j++) {
                    sum += smoothedCounts[j];
                }
                sampledCounts.push(sum / (end - i));
            }

            let pathD = `M 0 ${height - 10}`;
            sampledCounts.forEach((count, i) => {
                const x = (i / (sampledCounts.length - 1)) * width;
                const y = height - 10 - (count / maxCount) * 90;
                if (i === 0) {
                    pathD += ` L ${x} ${y}`;
                } else {
                    const prevX = ((i - 1) / (sampledCounts.length - 1)) * width;
                    const cpX = (prevX + x) / 2;
                    pathD += ` Q ${cpX} ${y}, ${x} ${y}`;
                }
            });
            pathD += ` L ${width} ${height - 10} Z`;

            // Format date range label
            const formatDate = (d) => d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            const dateRangeLabel = `${formatDate(minDate)} - ${formatDate(maxDate)}`;

            container.innerHTML = `
                <div class="intensity-waves-container">
                    <svg class="intensity-waves-svg" viewBox="0 0 ${width} ${height}">
                        <defs>
                            <linearGradient id="intensityGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" style="stop-color:#e94560;stop-opacity:0.8" />
                                <stop offset="100%" style="stop-color:#e94560;stop-opacity:0.1" />
                            </linearGradient>
                        </defs>
                        <path class="intensity-wave-path" d="${pathD}" />
                    </svg>
                    <div class="intensity-date-range">${dateRangeLabel} (${timeline.length.toLocaleString()} interactions)</div>
                </div>
            `;
        }

        // Render weekly rhythm polar chart
        function renderWeeklyRhythm() {
            const container = document.getElementById('weeklyRhythmViz');
            const timeline = relationshipTimelineCache || [];

            if (timeline.length === 0) {
                container.innerHTML = '<div class="viz-loading">No data available</div>';
                return;
            }

            // Count by day of week
            const dayCounts = [0, 0, 0, 0, 0, 0, 0]; // Sun-Sat
            timeline.forEach(item => {
                const date = new Date(item.timestamp);
                dayCounts[date.getDay()]++;
            });

            const maxCount = Math.max(...dayCounts, 1);
            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

            // Build polar chart
            const cx = 80;
            const cy = 80;
            const maxRadius = 60;

            // Calculate polygon points
            let polygonPoints = '';
            dayCounts.forEach((count, i) => {
                const angle = (i * 2 * Math.PI / 7) - Math.PI / 2;
                const radius = 15 + (count / maxCount) * (maxRadius - 15);
                const x = cx + Math.cos(angle) * radius;
                const y = cy + Math.sin(angle) * radius;
                polygonPoints += `${x},${y} `;
            });

            // Build labels and spokes
            let labels = '';
            let spokes = '';
            dayNames.forEach((name, i) => {
                const angle = (i * 2 * Math.PI / 7) - Math.PI / 2;
                const labelRadius = maxRadius + 15;
                const x = cx + Math.cos(angle) * labelRadius;
                const y = cy + Math.sin(angle) * labelRadius;
                labels += `<text class="polar-label" x="${x}" y="${y}" text-anchor="middle" dominant-baseline="middle">${name}</text>`;

                const spokeEnd = cx + Math.cos(angle) * maxRadius;
                const spokeEndY = cy + Math.sin(angle) * maxRadius;
                spokes += `<line class="polar-spoke" x1="${cx}" y1="${cy}" x2="${spokeEnd}" y2="${spokeEndY}" />`;
            });

            container.innerHTML = `
                <div class="weekly-rhythm-container">
                    <div class="polar-chart">
                        <svg viewBox="0 0 160 160">
                            ${spokes}
                            <polygon class="polar-fill" points="${polygonPoints}" />
                            ${labels}
                        </svg>
                    </div>
                </div>
            `;
        }

        // Render "Beyond Texting" - 12-month line graph of non-iMessage channels
        function renderChannelFlow() {
            const container = document.getElementById('channelFlowViz');
            const timeline = relationshipTimelineCache || [];

            if (timeline.length === 0) {
                container.innerHTML = '<div class="viz-loading">No data available</div>';
                return;
            }

            const channelConfig = {
                'phone': { name: 'Phone', icon: 'ðŸ“ž', color: '#007AFF' },
                'calendar': { name: 'Calendar', icon: 'ðŸ“…', color: '#5856D6' },
                'gmail': { name: 'Email', icon: 'ðŸ“§', color: '#EA4335' },
                'whatsapp': { name: 'WhatsApp', icon: 'ðŸ’¬', color: '#25D366' },
                'slack': { name: 'Slack', icon: 'ðŸ’¼', color: '#4A154B' },
            };

            // Generate last 12 months
            const now = new Date();
            const months = [];
            for (let i = 11; i >= 0; i--) {
                const d = new Date(now.getFullYear(), now.getMonth() - i, 1);
                months.push(d.toISOString().slice(0, 7)); // YYYY-MM
            }

            // Group by month and channel (excluding iMessage)
            const monthlyByChannel = {};
            timeline.forEach(item => {
                const channel = item.source_type;
                if (channel === 'imessage') return;

                const month = item.timestamp?.slice(0, 7);
                if (!month || !months.includes(month)) return;

                if (!monthlyByChannel[channel]) {
                    monthlyByChannel[channel] = {};
                    months.forEach(m => monthlyByChannel[channel][m] = 0);
                }
                monthlyByChannel[channel][month]++;
            });

            // Get channels with data, sorted by total
            const channelsWithData = Object.entries(monthlyByChannel)
                .map(([channel, data]) => ({
                    channel,
                    total: Object.values(data).reduce((a, b) => a + b, 0),
                    data
                }))
                .filter(c => c.total > 0)
                .sort((a, b) => b.total - a.total);

            if (channelsWithData.length === 0) {
                container.innerHTML = '<div class="viz-empty">No non-text interactions found</div>';
                return;
            }

            // Chart dimensions
            const width = 380;
            const height = 160;
            const leftMargin = 30;
            const rightMargin = 10;
            const topMargin = 15;
            const bottomMargin = 25;
            const chartWidth = width - leftMargin - rightMargin;
            const chartHeight = height - topMargin - bottomMargin;

            // Find max for Y scale
            let maxCount = 0;
            channelsWithData.forEach(c => {
                Object.values(c.data).forEach(v => { if (v > maxCount) maxCount = v; });
            });
            maxCount = Math.max(maxCount, 1);

            // Build line paths for each channel
            const buildLinePath = (data) => {
                const values = months.map(m => data[m] || 0);
                let path = '';
                values.forEach((v, i) => {
                    const x = leftMargin + (i / (months.length - 1)) * chartWidth;
                    const y = topMargin + chartHeight - (v / maxCount) * chartHeight;
                    path += i === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`;
                });
                return path;
            };

            // Grid lines
            const gridCount = 4;
            let gridLines = '';
            for (let i = 0; i <= gridCount; i++) {
                const y = topMargin + (i / gridCount) * chartHeight;
                const val = Math.round(maxCount * (1 - i / gridCount));
                gridLines += `<line x1="${leftMargin}" y1="${y}" x2="${width - rightMargin}" y2="${y}" stroke="var(--border-subtle)" stroke-width="1" opacity="0.3" />`;
                if (i === 0 || i === gridCount) {
                    gridLines += `<text x="${leftMargin - 5}" y="${y + 3}" text-anchor="end" style="font-size: 0.5rem; fill: var(--text-muted);">${val}</text>`;
                }
            }

            // X-axis month labels (show every 2nd or 3rd)
            const showEvery = months.length > 8 ? 3 : 2;
            const monthLabels = months.map((m, i) => {
                if (i % showEvery !== 0 && i !== months.length - 1) return '';
                const x = leftMargin + (i / (months.length - 1)) * chartWidth;
                const label = new Date(m + '-01').toLocaleDateString('en-US', { month: 'short' });
                return `<text x="${x}" y="${height - 5}" text-anchor="middle" style="font-size: 0.5rem; fill: var(--text-muted);">${label}</text>`;
            }).join('');

            // Build SVG paths
            let pathsSvg = '';
            channelsWithData.forEach(c => {
                const config = channelConfig[c.channel] || { color: '#6c757d' };
                const path = buildLinePath(c.data);
                pathsSvg += `<path d="${path}" fill="none" stroke="${config.color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" opacity="0.85" />`;
            });

            // Legend
            const legendHtml = channelsWithData.map(c => {
                const config = channelConfig[c.channel] || { name: c.channel, color: '#6c757d' };
                return `<div style="display: flex; align-items: center; gap: 0.25rem; font-size: 0.6rem; color: var(--text-muted);"><span style="width: 12px; height: 3px; background: ${config.color}; border-radius: 2px;"></span>${config.name} (${c.total})</div>`;
            }).join('');

            container.innerHTML = `
                <div style="width: 100%;">
                    <svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet" style="width: 100%; height: auto;">
                        ${gridLines}
                        ${monthLabels}
                        ${pathsSvg}
                    </svg>
                    <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 0.75rem; margin-top: 0.25rem;">
                        ${legendHtml}
                    </div>
                </div>
            `;
        }

        // Render depth bubbles with nuanced interaction classification
        function renderDepthBubbles() {
            const container = document.getElementById('depthBubblesViz');
            const timeline = relationshipTimelineCache || [];

            if (timeline.length === 0) {
                container.innerHTML = '<div class="viz-loading">No data available</div>';
                return;
            }

            // Sort by timestamp to detect conversation bursts
            const sorted = [...timeline].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            // Time slots
            const timeSlots = [
                { label: 'Morning', start: 6, end: 12, icon: 'ðŸŒ…' },
                { label: 'Afternoon', start: 12, end: 18, icon: 'â˜€ï¸' },
                { label: 'Evening', start: 18, end: 24, icon: 'ðŸŒ†' },
                { label: 'Night', start: 0, end: 6, icon: 'ðŸŒ™' },
            ];

            // Classify each interaction with nuance
            const classifyDepth = (item, idx, arr) => {
                const channel = item.source_type;

                // Calendar events are deep (scheduled time together)
                if (channel === 'calendar') return 'Deep';

                // Phone/FaceTime: parse duration from title
                if (channel === 'phone') {
                    const title = item.title || '';
                    const durationMatch = title.match(/(\d+)m\s*(\d+)?s?/);
                    if (durationMatch) {
                        const minutes = parseInt(durationMatch[1]) || 0;
                        if (minutes >= 15) return 'Deep';
                        if (minutes >= 5) return 'Medium';
                    }
                    return 'Quick';
                }

                // Gmail: longer snippets indicate deeper content
                if (channel === 'gmail') {
                    const snippet = item.snippet || '';
                    if (snippet.length > 200) return 'Deep';
                    if (snippet.length > 50) return 'Medium';
                    return 'Quick';
                }

                // iMessage/WhatsApp: detect conversation bursts
                if (channel === 'imessage' || channel === 'whatsapp') {
                    const itemTime = new Date(item.timestamp).getTime();
                    const burstWindow = 5 * 60 * 1000; // 5 minutes

                    // Count messages in burst around this message
                    let burstCount = 1;
                    for (let i = idx - 1; i >= 0 && i >= idx - 20; i--) {
                        const prevTime = new Date(arr[i].timestamp).getTime();
                        if (itemTime - prevTime <= burstWindow && arr[i].source_type === channel) {
                            burstCount++;
                        } else break;
                    }
                    for (let i = idx + 1; i < arr.length && i <= idx + 20; i++) {
                        const nextTime = new Date(arr[i].timestamp).getTime();
                        if (nextTime - itemTime <= burstWindow && arr[i].source_type === channel) {
                            burstCount++;
                        } else break;
                    }

                    // Deeper engagement if part of active back-and-forth
                    if (burstCount >= 10) return 'Deep';
                    if (burstCount >= 4) return 'Medium';
                    return 'Quick';
                }

                return 'Quick';
            };

            const bubbleData = {};
            const depthCounts = { Quick: 0, Medium: 0, Deep: 0 };

            sorted.forEach((item, idx) => {
                const date = new Date(item.timestamp);
                const hour = date.getHours();
                const depth = classifyDepth(item, idx, sorted);

                depthCounts[depth]++;

                const slot = timeSlots.find(s =>
                    (s.start <= s.end ? (hour >= s.start && hour < s.end) : (hour >= s.start || hour < s.end))
                );
                const slotLabel = slot?.label || 'Other';

                const key = `${slotLabel}-${depth}`;
                bubbleData[key] = (bubbleData[key] || 0) + 1;
            });

            const maxBubble = Math.max(...Object.values(bubbleData), 1);
            const total = sorted.length;

            // Depth colors
            const depthColors = {
                'Quick': '#64b5f6',
                'Medium': '#f4a261',
                'Deep': '#e94560'
            };

            // Render as enhanced grid
            let html = `
                <div class="depth-grid">
                    <div class="depth-header-row">
                        <div></div>
                        <div class="depth-col-header">Quick<br><span class="depth-subtext">${Math.round(depthCounts.Quick/total*100)}%</span></div>
                        <div class="depth-col-header">Medium<br><span class="depth-subtext">${Math.round(depthCounts.Medium/total*100)}%</span></div>
                        <div class="depth-col-header">Deep<br><span class="depth-subtext">${Math.round(depthCounts.Deep/total*100)}%</span></div>
                    </div>
            `;

            timeSlots.forEach(slot => {
                html += `<div class="depth-row-label">${slot.icon} ${slot.label}</div>`;
                ['Quick', 'Medium', 'Deep'].forEach(depth => {
                    const count = bubbleData[`${slot.label}-${depth}`] || 0;
                    const size = count > 0 ? Math.max(12, (count / maxBubble) * 45) : 0;
                    const color = depthColors[depth];
                    html += `
                        <div class="depth-cell">
                            ${count > 0 ? `<div class="depth-bubble" style="width: ${size}px; height: ${size}px; background: ${color};" title="${count} ${depth.toLowerCase()} interactions in ${slot.label.toLowerCase()}"></div>` : '<div class="depth-empty">-</div>'}
                        </div>
                    `;
                });
            });

            html += `
                </div>
                <div class="depth-legend">
                    <span>Quick: texts, brief calls</span>
                    <span>Medium: 5-15min calls, email threads</span>
                    <span>Deep: 15min+ calls, meetings, active convos</span>
                </div>
            `;
            container.innerHTML = html;
        }

        // Render family member dropdown
        function renderFamilyDropdown() {
            const listEl = document.getElementById('familyDropdownList');
            if (!listEl) return;

            if (familyMembers.length === 0) {
                listEl.innerHTML = '<div style="padding: 1rem; color: var(--text-muted); text-align: center;">No family members found</div>';
                return;
            }

            let html = '';
            familyMembers.forEach(member => {
                const isSelected = selectedFamilyIds.includes(member.id);
                html += `
                    <label class="family-member-option">
                        <input type="checkbox" ${isSelected ? 'checked' : ''} onchange="toggleFamilyMember('${member.id}')">
                        <span class="family-member-name">${escapeHtml(member.name)}</span>
                        <span class="family-member-strength">${Math.round(member.relationship_strength)}</span>
                    </label>
                `;
            });

            listEl.innerHTML = html;
        }

        // Toggle family dropdown visibility
        function toggleFamilyDropdown() {
            const dropdown = document.getElementById('familyDropdown');
            const btn = document.querySelector('.family-selector-btn');
            if (!dropdown || !btn) return;

            if (dropdown.style.display === 'none') {
                // Position dropdown below button (for fixed positioning in selector row)
                const rect = btn.getBoundingClientRect();
                dropdown.style.top = (rect.bottom + 4) + 'px';
                dropdown.style.left = rect.left + 'px';
                dropdown.style.display = 'block';
            } else {
                dropdown.style.display = 'none';
            }
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('familyDropdown');
            const selector = document.querySelector('.family-member-selector');
            if (dropdown && selector && !selector.contains(e.target)) {
                dropdown.style.display = 'none';
            }
        });

        // Toggle individual family member selection
        async function toggleFamilyMember(memberId) {
            if (selectedFamilyIds.includes(memberId)) {
                selectedFamilyIds = selectedFamilyIds.filter(id => id !== memberId);
            } else {
                selectedFamilyIds.push(memberId);
            }
            updateFamilySelectorLabel();
            // Load both stats and interactions when family selection changes
            await loadFamilyStats();
            await loadFamilyInteractions();
        }

        // Select all family members
        async function selectAllFamily() {
            selectedFamilyIds = familyMembers.map(m => m.id);
            renderFamilyDropdown();
            updateFamilySelectorLabel();
            await loadFamilyStats();
            await loadFamilyInteractions();
        }

        // Clear all family member selections
        async function clearAllFamily() {
            selectedFamilyIds = [];
            renderFamilyDropdown();
            updateFamilySelectorLabel();
            await loadFamilyStats();  // Reset stats to 0
            renderEmptyFamilyDashboard();
        }

        // Update the selector label with count
        function updateFamilySelectorLabel() {
            const label = document.getElementById('familySelectorLabel');
            if (!label) return;

            if (selectedFamilyIds.length === 0) {
                label.textContent = 'Select family members...';
            } else if (selectedFamilyIds.length === familyMembers.length) {
                label.textContent = `All family (${familyMembers.length})`;
            } else {
                label.textContent = `${selectedFamilyIds.length} selected`;
            }
        }

        // Load family lifetime stats (hero stats - independent of year selection)
        async function loadFamilyStats() {
            if (selectedFamilyIds.length === 0) {
                document.getElementById('familyStatEmails').textContent = '0';
                document.getElementById('familyStatMessages').textContent = '0';
                document.getElementById('familyStatPhone').textContent = '0';
                document.getElementById('familyStatCalendar').textContent = '0';
                document.getElementById('familyStatPhotosContainer').style.display = 'none';
                return;
            }

            try {
                const idsParam = selectedFamilyIds.join(',');
                const stats = await api(`/family/stats?person_ids=${encodeURIComponent(idsParam)}`);
                document.getElementById('familyStatEmails').textContent = formatCompactNumber(stats.total_emails || 0);
                document.getElementById('familyStatMessages').textContent = formatCompactNumber(stats.total_messages || 0);
                // Note: phone and calendar aren't in PersonEntity lifetime counts yet
                // For now, use 0 or we could add them to the endpoint later
                document.getElementById('familyStatPhone').textContent = '0';
                document.getElementById('familyStatCalendar').textContent = formatCompactNumber(stats.total_meetings || 0);
                // Note: Photos stat is updated by loadFamilyHeatMap from sourceTotals
            } catch (error) {
                console.error('Failed to load family stats:', error);
            }
        }

        // Load family interactions from API
        async function loadFamilyInteractions() {
            if (selectedFamilyIds.length === 0) {
                renderEmptyFamilyDashboard();
                return;
            }

            try {
                const idsParam = selectedFamilyIds.join(',');
                // Fetch up to 10 years of data (like person/me pages do)
                const daysBack = (heatmapYears * 365) + 7;
                familyData = await api(`/family/interactions?person_ids=${encodeURIComponent(idsParam)}&days_back=${daysBack}&health_period=${familyHealthPeriod}&trend_period=${familyTrendPeriod}`);
                renderFamilyDashboard(familyData);
            } catch (error) {
                console.error('Failed to load family interactions:', error);
                renderEmptyFamilyDashboard();
            }
        }

        // Render empty family dashboard
        function renderEmptyFamilyDashboard() {
            document.getElementById('familyHealthCurrentScore').textContent = '--';
            document.getElementById('familyHealthChartContainer').innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-muted);">Select family members to see data</div>';
            document.getElementById('familyTrendsWarmingList').innerHTML = '<div style="color: var(--text-muted); font-size: 0.75rem;">No data</div>';
            document.getElementById('familyTrendsCoolingList').innerHTML = '<div style="color: var(--text-muted); font-size: 0.75rem;">No data</div>';
            // Reset hero stats
            document.getElementById('familyStatEmails').textContent = '0';
            document.getElementById('familyStatMessages').textContent = '0';
            document.getElementById('familyStatPhone').textContent = '0';
            document.getElementById('familyStatCalendar').textContent = '0';
            document.getElementById('familyStatPhotosContainer').style.display = 'none';
            // Reset family insights
            const emptyMessage = '<div class="insight-empty"><span class="insight-empty-icon">ðŸ“Š</span>Select family members to see data</div>';
            const daysSince = document.getElementById('daysSinceGrid');
            const streakGrid = document.getElementById('streakGrid');
            const channelMix = document.getElementById('channelMixContainer');
            const gapsTimeline = document.getElementById('gapsTimelineContainer');
            if (daysSince) daysSince.innerHTML = emptyMessage;
            if (streakGrid) streakGrid.innerHTML = emptyMessage;
            if (channelMix) channelMix.innerHTML = emptyMessage;
            if (gapsTimeline) gapsTimeline.innerHTML = emptyMessage;
        }

        // Render family dashboard with data
        function renderFamilyDashboard(data) {
            if (!data) {
                renderEmptyFamilyDashboard();
                return;
            }

            // Note: Hero stats are loaded separately via loadFamilyStats()
            // They use lifetime totals from PersonEntity, not time-bounded data

            // Render heatmap and volume chart with family data
            loadFamilyHeatMap(data);

            // Render health score chart
            renderFamilyHealthScore(data);

            // Render trends
            renderFamilyTrends(data);

            // Render family insights visualizations
            renderFamilyInsights();
        }

        // Load and render heatmap for family view (aggregate across selected family members)
        function loadFamilyHeatMap(data) {
            if (!data || !data.daily) {
                heatmapData = {};
                sourceTotals = {};
                renderHeatMap();
                return;
            }

            // Use pre-aggregated daily data from family API
            heatmapData = {};
            sourceTotals = data.by_source || {};

            (data.daily || []).forEach(day => {
                heatmapData[day.date] = { total: day.total, sources: day.sources };
            });

            // Update title based on current heatmapYears
            const titleEl = document.getElementById('heatmapTitle');
            if (titleEl) {
                titleEl.textContent = heatmapYears === 1
                    ? '365-Day Interaction History'
                    : `${heatmapYears}-Year Interaction History`;
            }

            renderHeatMap();

            // Update photos stat from sourceTotals (since family stats endpoint doesn't include photos)
            const photosCount = sourceTotals['photos'] || 0;
            const photosContainer = document.getElementById('familyStatPhotosContainer');
            if (photosContainer) {
                if (photosCount > 0) {
                    photosContainer.style.display = '';
                    document.getElementById('familyStatPhotos').textContent = formatCompactNumber(photosCount);
                } else {
                    photosContainer.style.display = 'none';
                }
            }
        }

        // Render family health score chart
        function renderFamilyHealthScore(data) {
            const container = document.getElementById('familyHealthChartContainer');
            const scoreEl = document.getElementById('familyHealthCurrentScore');

            if (!container || !scoreEl) {
                return;
            }

            const history = data.health_score_history || [];
            const currentScore = data.relationship_health_score || 0;
            const avgCount = data.health_score_average || 0;

            // Update current score with color
            scoreEl.textContent = currentScore;
            let color = '#ef4444';
            if (currentScore >= 80) color = '#22c55e';
            else if (currentScore >= 60) color = '#86efac';
            else if (currentScore >= 40) color = '#9ca3af';
            else if (currentScore >= 25) color = '#f97316';
            scoreEl.style.color = color;

            if (history.length === 0) {
                container.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-muted);">No health data available</div>';
                return;
            }

            // Reuse the same SVG rendering as renderHealthScore
            const width = 600;
            const height = 120;
            const padding = { top: 10, right: 10, bottom: 25, left: 35 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            const xScale = (i) => padding.left + (i / (history.length - 1)) * chartWidth;
            const yScale = (score) => padding.top + (1 - score / 100) * chartHeight;

            // Build path
            let pathD = '';
            history.forEach((point, i) => {
                const x = xScale(i);
                const y = yScale(point.score);
                if (i === 0) {
                    pathD += `M ${x} ${y}`;
                } else {
                    pathD += ` L ${x} ${y}`;
                }
            });

            // Build area
            let areaD = pathD + ` L ${xScale(history.length - 1)} ${yScale(0)} L ${xScale(0)} ${yScale(0)} Z`;

            // Build dots
            const dots = history.map((point, i) => {
                const x = xScale(i);
                const y = yScale(point.score);
                const dotColor = getDotColor(point.score);
                const count = point.count || 0;
                return `<circle class="health-chart-dot" cx="${x}" cy="${y}" r="4" data-index="${i}" data-score="${point.score}" data-count="${count}" data-avg="${avgCount}" data-date="${point.date}" style="fill: ${dotColor};"/>`;
            }).join('');

            // X-axis labels
            const xLabels = [];
            const labelCount = Math.min(5, history.length);
            for (let i = 0; i < labelCount; i++) {
                const idx = Math.floor(i * (history.length - 1) / (labelCount - 1));
                const point = history[idx];
                const date = new Date(point.date);
                const label = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                xLabels.push(`<text x="${xScale(idx)}" y="${height - 5}" text-anchor="middle" fill="var(--text-muted)" font-size="10">${label}</text>`);
            }

            const svgHtml = `
                <svg class="health-chart-svg" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">
                    <!-- Grid lines -->
                    <line x1="${padding.left}" y1="${yScale(100)}" x2="${width - padding.right}" y2="${yScale(100)}" stroke="var(--border-color)" stroke-dasharray="2,2"/>
                    <line x1="${padding.left}" y1="${yScale(50)}" x2="${width - padding.right}" y2="${yScale(50)}" stroke="var(--border-color)" stroke-dasharray="2,2"/>
                    <line x1="${padding.left}" y1="${yScale(0)}" x2="${width - padding.right}" y2="${yScale(0)}" stroke="var(--border-color)" stroke-dasharray="2,2"/>

                    <!-- Y-axis labels -->
                    <text x="${padding.left - 5}" y="${yScale(100) + 4}" text-anchor="end" fill="var(--text-muted)" font-size="10">100</text>
                    <text x="${padding.left - 5}" y="${yScale(50) + 4}" text-anchor="end" fill="var(--text-muted)" font-size="10">Avg</text>
                    <text x="${padding.left - 5}" y="${yScale(0) + 4}" text-anchor="end" fill="var(--text-muted)" font-size="10">0</text>

                    <!-- Area fill -->
                    <path d="${areaD}" fill="var(--text-muted)" fill-opacity="0.1"/>

                    <!-- Line -->
                    <path d="${pathD}" fill="none" stroke="var(--text-muted)" stroke-width="2" stroke-opacity="0.4"/>

                    <!-- Dots -->
                    ${dots}

                    <!-- X-axis labels -->
                    ${xLabels.join('')}
                </svg>
                <div class="health-chart-tooltip" id="familyHealthTooltip"></div>
            `;
            container.innerHTML = svgHtml;
            setupFamilyHealthChartTooltips();
        }

        // Setup tooltips for family health chart
        function setupFamilyHealthChartTooltips() {
            const container = document.getElementById('familyHealthChartContainer');
            const tooltip = document.getElementById('familyHealthTooltip');
            if (!container || !tooltip) return;

            const dots = container.querySelectorAll('.health-chart-dot');
            dots.forEach(dot => {
                dot.addEventListener('mouseenter', (e) => {
                    const score = dot.getAttribute('data-score');
                    const count = dot.getAttribute('data-count');
                    const avg = dot.getAttribute('data-avg');
                    const date = dot.getAttribute('data-date');
                    const formattedDate = new Date(date).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

                    tooltip.innerHTML = `
                        <div class="health-chart-tooltip-date">${formattedDate}</div>
                        <div class="health-chart-tooltip-score">Score: ${score}</div>
                        <div style="font-size: 0.6rem; color: var(--text-muted);">Interactions: ${count}</div>
                        <div style="font-size: 0.6rem; color: var(--text-muted);">Avg. for Period: ${avg}</div>
                    `;

                    const rect = container.getBoundingClientRect();
                    const dotRect = dot.getBoundingClientRect();
                    tooltip.style.left = (dotRect.left - rect.left + dotRect.width / 2) + 'px';
                    tooltip.style.top = (dotRect.top - rect.top - 8) + 'px';
                    tooltip.style.transform = 'translate(-50%, -100%)';
                    tooltip.classList.add('visible');
                });

                dot.addEventListener('mouseleave', () => {
                    tooltip.classList.remove('visible');
                });
            });
        }

        // Render family top contacts
        // Render family trends
        function renderFamilyTrends(data) {
            const warmingList = document.getElementById('familyTrendsWarmingList');
            const coolingList = document.getElementById('familyTrendsCoolingList');

            if (!warmingList || !coolingList) return;

            const warming = data.warming || [];
            const cooling = data.cooling || [];

            // Render trend item (matching Me page style)
            const renderTrend = (item, isWarming) => {
                const pctChange = item.previous_count > 0
                    ? Math.round(((item.recent_count - item.previous_count) / item.previous_count) * 100)
                    : (item.recent_count > 0 ? 100 : 0);
                const pctDisplay = pctChange >= 0 ? `+${pctChange}%` : `${pctChange}%`;
                const pctClass = isWarming ? 'trend-pct-warming' : 'trend-pct-cooling';
                return `
                    <div class="trend-item ${isWarming ? 'trend-warming' : 'trend-cooling'}" onclick="selectPerson('${item.person_id}')">
                        <span class="trend-indicator">${isWarming ? 'â†‘' : 'â†“'}</span>
                        <span class="trend-pct ${pctClass}">${pctDisplay}</span>
                        <span class="trend-name">${escapeHtml(item.person_name)}</span>
                        <span class="trend-change">${item.previous_count}â†’${item.recent_count}</span>
                    </div>
                `;
            };

            warmingList.innerHTML = warming.length > 0
                ? warming.slice(0, 5).map(w => renderTrend(w, true)).join('')
                : '<div style="color: var(--text-muted); font-size: 0.75rem; padding: 0.25rem;">No warming trends</div>';

            coolingList.innerHTML = cooling.length > 0
                ? cooling.slice(0, 5).map(c => renderTrend(c, false)).join('')
                : '<div style="color: var(--text-muted); font-size: 0.75rem; padding: 0.25rem;">No cooling trends</div>';
        }

        // ================================================
        // FAMILY INSIGHTS VISUALIZATIONS
        // ================================================

        // Dunbar circle contact expectations (in days)
        const DUNBAR_CONTACT_EXPECTATIONS = {
            0: 7,    // Circle 0 (Intimate): every week
            1: 7,    // Circle 1 (Close): every week
            2: 14,   // Circle 2 (Good Friends): every 2 weeks
            3: 30,   // Circle 3 (Friends): every month
            4: 90,   // Circle 4 (Acquaintances): every quarter
            5: 365,  // Circle 5 (Known): every year
            6: 365,  // Circle 6+: every year
            7: 365,  // Peripheral: every year
        };

        // Get expected contact frequency label
        function getExpectedContactLabel(circle) {
            const days = DUNBAR_CONTACT_EXPECTATIONS[circle] || 365;
            if (days <= 7) return 'weekly';
            if (days <= 14) return 'bi-weekly';
            if (days <= 30) return 'monthly';
            if (days <= 90) return 'quarterly';
            return 'yearly';
        }

        // Get initials from name
        function getInitials(name) {
            return name.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
        }

        // Cache for profile photo availability
        const profilePhotoCache = new Map();

        // Load profile photos for visible avatars
        async function loadProfilePhotos() {
            const avatars = document.querySelectorAll('.person-avatar[data-person-id]');
            for (const avatar of avatars) {
                const personId = avatar.dataset.personId;
                if (!personId) continue;

                // Skip if already processed
                if (avatar.classList.contains('has-photo') || avatar.classList.contains('no-photo')) continue;

                // Check cache first
                if (profilePhotoCache.has(personId)) {
                    const hasPhoto = profilePhotoCache.get(personId);
                    if (hasPhoto) {
                        avatar.style.backgroundImage = `url(/api/photos/profile/${personId})`;
                        avatar.classList.add('has-photo');
                    } else {
                        avatar.classList.add('no-photo');
                    }
                    continue;
                }

                // Try to load the photo
                try {
                    const response = await fetch(`/api/photos/profile/${personId}`, { method: 'HEAD' });
                    if (response.ok) {
                        avatar.style.backgroundImage = `url(/api/photos/profile/${personId})`;
                        avatar.classList.add('has-photo');
                        profilePhotoCache.set(personId, true);
                    } else {
                        avatar.classList.add('no-photo');
                        profilePhotoCache.set(personId, false);
                    }
                } catch {
                    avatar.classList.add('no-photo');
                    profilePhotoCache.set(personId, false);
                }
            }
        }

        // Load profile photo for detail avatar
        async function loadDetailProfilePhoto(personId) {
            const avatar = document.getElementById('detailAvatar');
            if (!avatar || !personId) return;

            // Reset classes
            avatar.classList.remove('has-photo', 'no-photo');

            // Check cache first
            if (profilePhotoCache.has(personId)) {
                const hasPhoto = profilePhotoCache.get(personId);
                if (hasPhoto) {
                    avatar.style.backgroundImage = `url(/api/photos/profile/${personId})`;
                    avatar.classList.add('has-photo');
                } else {
                    avatar.style.backgroundImage = '';
                    avatar.classList.add('no-photo');
                }
                return;
            }

            // Try to load the photo using Image preload (HEAD returns 405 for FileResponse)
            const photoUrl = `/api/photos/profile/${personId}`;
            const img = new Image();
            img.onload = () => {
                avatar.style.backgroundImage = `url(${photoUrl})`;
                avatar.classList.add('has-photo');
                profilePhotoCache.set(personId, true);
            };
            img.onerror = () => {
                avatar.style.backgroundImage = '';
                avatar.classList.add('no-photo');
                profilePhotoCache.set(personId, false);
            };
            img.src = photoUrl;
        }

        // Load partner's profile photo for relationship dashboard
        async function loadRelationshipPartnerPhoto(personId) {
            const avatar = document.getElementById('detailAvatar');
            if (!avatar || !personId) return;

            // Check cache first
            if (profilePhotoCache.has(personId)) {
                const hasPhoto = profilePhotoCache.get(personId);
                if (hasPhoto) {
                    avatar.style.backgroundImage = `url(/api/photos/profile/${personId})`;
                    avatar.classList.add('has-photo');
                    avatar.textContent = '';  // Clear emoji
                }
                // If no photo, keep default emoji
                return;
            }

            // Try to load the photo
            const photoUrl = `/api/photos/profile/${personId}`;
            const img = new Image();
            img.onload = () => {
                avatar.style.backgroundImage = `url(${photoUrl})`;
                avatar.classList.add('has-photo');
                avatar.textContent = '';  // Clear emoji
                profilePhotoCache.set(personId, true);
            };
            img.onerror = () => {
                // Keep default emoji, no photo available
                profilePhotoCache.set(personId, false);
            };
            img.src = photoUrl;
        }

        // Render Days Since Contact visualization
        function renderDaysSinceContact() {
            const container = document.getElementById('daysSinceGrid');
            if (!container || familyMembers.length === 0) {
                if (container) container.innerHTML = '<div class="insight-empty"><span class="insight-empty-icon">ðŸ“…</span>No family members selected</div>';
                return;
            }

            const now = new Date();
            const selectedMembers = familyMembers.filter(m => selectedFamilyIds.includes(m.id));

            if (selectedMembers.length === 0) {
                container.innerHTML = '<div class="insight-empty"><span class="insight-empty-icon">ðŸ“…</span>No family members selected</div>';
                return;
            }

            // Calculate days since contact for each member
            const membersWithDays = selectedMembers.map(member => {
                const lastSeen = member.last_seen ? new Date(member.last_seen) : null;
                const daysSince = lastSeen ? Math.floor((now - lastSeen) / (1000 * 60 * 60 * 24)) : null;
                const circle = member.dunbar_circle ?? 5;
                const expectedDays = DUNBAR_CONTACT_EXPECTATIONS[circle] || 365;

                let status = 'on-track';
                if (daysSince === null) {
                    status = 'warning';
                } else if (daysSince <= 2) {
                    status = 'recent';
                } else if (daysSince > expectedDays * 1.5) {
                    status = 'overdue';
                } else if (daysSince > expectedDays) {
                    status = 'warning';
                }

                return { ...member, daysSince, expectedDays, status, circle };
            });

            // Sort alphabetically by name for consistency across all visualizations
            membersWithDays.sort((a, b) => a.name.localeCompare(b.name));

            container.innerHTML = membersWithDays.map(member => {
                const daysText = member.daysSince === null ? '?' :
                    member.daysSince === 0 ? 'Today' :
                    member.daysSince === 1 ? '1 day' :
                    `${member.daysSince}d`;
                const expectedLabel = getExpectedContactLabel(member.circle);

                return `
                    <div class="days-since-item" onclick="selectPerson('${member.id}')">
                        <div class="days-since-avatar">${getInitials(member.name)}</div>
                        <div class="days-since-info">
                            <div class="days-since-name">${escapeHtml(member.name)}</div>
                            <div class="days-since-expected">Target: ${expectedLabel}</div>
                        </div>
                        <div class="days-since-badge ${member.status}">${daysText}</div>
                    </div>
                `;
            }).join('');
        }

        // Render Streak Tracker visualization (weeks-based)
        function renderStreakTracker() {
            const container = document.getElementById('streakGrid');
            if (!container || familyMembers.length === 0) {
                if (container) container.innerHTML = '<div class="insight-empty"><span class="insight-empty-icon">ðŸ”¥</span>No family members selected</div>';
                return;
            }

            const selectedMembers = familyMembers.filter(m => selectedFamilyIds.includes(m.id));

            if (selectedMembers.length === 0) {
                container.innerHTML = '<div class="insight-empty"><span class="insight-empty-icon">ðŸ”¥</span>No family members selected</div>';
                return;
            }

            // Sort alphabetically by name for consistency across all visualizations
            const sorted = [...selectedMembers].sort((a, b) => a.name.localeCompare(b.name));

            container.innerHTML = sorted.map(member => {
                const streakWeeks = member.current_streak || 0;  // API returns weeks directly
                const streakClass = streakWeeks >= 4 ? 'hot' : streakWeeks >= 2 ? 'warm' : 'cold';
                const flame = streakWeeks >= 4 ? 'ðŸ”¥' : streakWeeks >= 2 ? 'ðŸŒ¡ï¸' : 'â„ï¸';

                // Show last 8 weeks as dots
                const dots = [];
                for (let i = 0; i < 8; i++) {
                    dots.push(`<div class="streak-day ${i < streakWeeks ? 'active' : ''}"></div>`);
                }

                return `
                    <div class="streak-item" onclick="selectPerson('${member.id}')">
                        <div class="streak-avatar">${getInitials(member.name)}</div>
                        <div class="streak-info">
                            <div class="streak-name">${escapeHtml(member.name)}</div>
                            <div class="streak-visual">
                                <span class="streak-flame">${flame}</span>
                                <div class="streak-days">${dots.join('')}</div>
                            </div>
                        </div>
                        <div class="streak-count ${streakClass}">${streakWeeks}w</div>
                    </div>
                `;
            }).join('');
        }

        // Channel colors for the mix visualization
        const CHANNEL_COLORS = {
            imessage: 'channel-imessage',
            whatsapp: 'channel-whatsapp',
            gmail: 'channel-gmail',
            calendar: 'channel-calendar',
            phone: 'channel-phone',
            slack: 'channel-slack',
            vault: 'channel-vault',
            granola: 'channel-granola',
            linkedin: 'channel-linkedin',
            photos: 'channel-photos',
        };

        const CHANNEL_LABELS = {
            imessage: 'ðŸ’¬ iMessage',
            whatsapp: 'ðŸ“± WhatsApp',
            gmail: 'ðŸ“§ Email',
            calendar: 'ðŸ“… Calendar',
            phone: 'ðŸ“ž Phone',
            slack: 'ðŸ’¼ Slack',
            vault: 'ðŸ“ Notes',
            granola: 'ðŸ¥£ Granola',
            linkedin: 'ðŸ”— LinkedIn',
            photos: 'ðŸ“· Photos',
        };

        // Render Channel Mix visualization
        function renderChannelMix() {
            const container = document.getElementById('channelMixContainer');
            if (!container || familyMembers.length === 0) {
                if (container) container.innerHTML = '<div class="insight-empty"><span class="insight-empty-icon">ðŸ“Š</span>No family members selected</div>';
                return;
            }

            const selectedMembers = familyMembers.filter(m => selectedFamilyIds.includes(m.id));

            if (selectedMembers.length === 0) {
                container.innerHTML = '<div class="insight-empty"><span class="insight-empty-icon">ðŸ“Š</span>No family members selected</div>';
                return;
            }

            // Sort alphabetically by name for consistency across all visualizations
            selectedMembers.sort((a, b) => a.name.localeCompare(b.name));

            // Collect all unique channels
            const allChannels = new Set();
            selectedMembers.forEach(m => {
                Object.keys(m.by_source || {}).forEach(ch => allChannels.add(ch));
            });

            // Build HTML for each member
            let html = selectedMembers.map(member => {
                const sources = member.by_source || {};
                const total = Object.values(sources).reduce((a, b) => a + b, 0);

                if (total === 0) {
                    return `
                        <div class="channel-mix-item">
                            <div class="channel-mix-header">
                                <span class="channel-mix-name">${escapeHtml(member.name)}</span>
                                <span class="channel-mix-total">No interactions</span>
                            </div>
                            <div class="channel-mix-bar">
                                <div class="channel-segment channel-other" style="width: 100%">
                                    <span class="channel-segment-label">No data</span>
                                </div>
                            </div>
                        </div>
                    `;
                }

                // Sort channels by count
                const sortedChannels = Object.entries(sources)
                    .sort((a, b) => b[1] - a[1]);

                const segments = sortedChannels.map(([channel, count]) => {
                    const pct = (count / total) * 100;
                    const colorClass = CHANNEL_COLORS[channel] || 'channel-other';
                    const label = pct >= 15 ? CHANNEL_LABELS[channel]?.split(' ')[0] || channel : '';

                    const tooltipLabel = CHANNEL_LABELS[channel] || channel;
                    return `<div class="channel-segment ${colorClass}" style="width: ${pct}%">
                        <span class="channel-segment-label">${label}</span>
                        <div class="channel-segment-tooltip"><strong>${tooltipLabel}</strong><br>${count.toLocaleString()} (${Math.round(pct)}%)</div>
                    </div>`;
                }).join('');

                return `
                    <div class="channel-mix-item">
                        <div class="channel-mix-header">
                            <span class="channel-mix-name">${escapeHtml(member.name)}</span>
                            <span class="channel-mix-total">${total.toLocaleString()} interactions</span>
                        </div>
                        <div class="channel-mix-bar">${segments}</div>
                    </div>
                `;
            }).join('');

            // Add legend
            const usedChannels = [...allChannels].filter(ch => CHANNEL_LABELS[ch]);
            if (usedChannels.length > 0) {
                html += `
                    <div class="channel-legend">
                        ${usedChannels.map(ch => `
                            <div class="channel-legend-item">
                                <div class="channel-legend-dot ${CHANNEL_COLORS[ch] || 'channel-other'}"></div>
                                <span>${CHANNEL_LABELS[ch] || ch}</span>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        // Cache for communication gaps data
        let communicationGapsData = null;
        let gapsMonths = 12;  // Default to 12 months
        let channelMixYears = 1;  // Default to 1 year

        // Change gaps time period
        async function changeGapsMonths(months) {
            gapsMonths = parseInt(months, 10);
            await loadCommunicationGaps();
        }

        // Change channel mix time period
        async function changeChannelMixYears(years) {
            channelMixYears = parseInt(years, 10);
            await loadChannelMixData();
        }

        // Load channel mix data from API with time filtering
        async function loadChannelMixData() {
            const container = document.getElementById('channelMixContainer');
            if (!container) return;

            if (selectedFamilyIds.length === 0) {
                container.innerHTML = '<div class="insight-empty"><span class="insight-empty-icon">ðŸ“Š</span>No family members selected</div>';
                return;
            }

            container.innerHTML = '<div class="insight-loading">Loading channel data...</div>';

            try {
                const idsParam = selectedFamilyIds.join(',');
                const daysBack = channelMixYears * 365;
                const data = await api(`/family/channel-mix?person_ids=${encodeURIComponent(idsParam)}&days_back=${daysBack}`);
                renderChannelMixWithData(data);
            } catch (error) {
                console.error('Failed to load channel mix:', error);
                // Fallback to using familyMembers data (lifetime totals)
                renderChannelMix();
            }
        }

        // Render Channel Mix with API data
        function renderChannelMixWithData(data) {
            const container = document.getElementById('channelMixContainer');
            if (!container || !data || !data.members) {
                renderChannelMix();  // Fallback
                return;
            }

            const members = data.members;
            if (members.length === 0) {
                container.innerHTML = '<div class="insight-empty"><span class="insight-empty-icon">ðŸ“Š</span>No data for selected period</div>';
                return;
            }

            // Sort alphabetically by name for consistency across all visualizations
            members.sort((a, b) => a.name.localeCompare(b.name));

            // Collect all unique channels
            const allChannels = new Set();
            members.forEach(m => {
                Object.keys(m.by_source || {}).forEach(ch => allChannels.add(ch));
            });

            // Build HTML for each member
            let html = members.map(member => {
                const sources = member.by_source || {};
                const total = Object.values(sources).reduce((a, b) => a + b, 0);

                if (total === 0) {
                    return `
                        <div class="channel-mix-item">
                            <div class="channel-mix-header">
                                <span class="channel-mix-name">${escapeHtml(member.name)}</span>
                                <span class="channel-mix-total">No interactions</span>
                            </div>
                            <div class="channel-mix-bar">
                                <div class="channel-segment channel-other" style="width: 100%">
                                    <span class="channel-segment-label">No data</span>
                                </div>
                            </div>
                        </div>
                    `;
                }

                // Sort channels by count
                const sortedChannels = Object.entries(sources)
                    .sort((a, b) => b[1] - a[1]);

                const segments = sortedChannels.map(([channel, count]) => {
                    const pct = (count / total) * 100;
                    const colorClass = CHANNEL_COLORS[channel] || 'channel-other';
                    const label = pct >= 15 ? CHANNEL_LABELS[channel]?.split(' ')[0] || channel : '';

                    const tooltipLabel = CHANNEL_LABELS[channel] || channel;
                    return `<div class="channel-segment ${colorClass}" style="width: ${pct}%">
                        <span class="channel-segment-label">${label}</span>
                        <div class="channel-segment-tooltip"><strong>${tooltipLabel}</strong><br>${count.toLocaleString()} (${Math.round(pct)}%)</div>
                    </div>`;
                }).join('');

                return `
                    <div class="channel-mix-item">
                        <div class="channel-mix-header">
                            <span class="channel-mix-name">${escapeHtml(member.name)}</span>
                            <span class="channel-mix-total">${total.toLocaleString()} interactions</span>
                        </div>
                        <div class="channel-mix-bar">${segments}</div>
                    </div>
                `;
            }).join('');

            // Add legend
            const usedChannels = [...allChannels].filter(ch => CHANNEL_LABELS[ch]);
            if (usedChannels.length > 0) {
                html += `
                    <div class="channel-legend">
                        ${usedChannels.map(ch => `
                            <div class="channel-legend-item">
                                <div class="channel-legend-dot ${CHANNEL_COLORS[ch] || 'channel-other'}"></div>
                                <span>${CHANNEL_LABELS[ch] || ch}</span>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        // Load and render Communication Gaps visualization
        // Calculate minimum gap threshold based on time period
        // Linear scale: 1 month â†’ 5 days, 12 months â†’ 20 days
        function getMinGapDays(months) {
            // Linear interpolation: 5 + (months - 1) * (20 - 5) / (12 - 1)
            return Math.round(5 + (months - 1) * 15 / 11);
        }

        async function loadCommunicationGaps() {
            const container = document.getElementById('gapsTimelineContainer');
            if (!container) return;

            if (selectedFamilyIds.length === 0) {
                container.innerHTML = '<div class="insight-empty"><span class="insight-empty-icon">ðŸ“‰</span>No family members selected</div>';
                return;
            }

            container.innerHTML = '<div class="insight-loading">Analyzing communication patterns...</div>';

            try {
                const idsParam = selectedFamilyIds.join(',');
                const daysBack = gapsMonths * 30;  // Approximate days from months
                const minGapDays = getMinGapDays(gapsMonths);

                // Update subtitle to show current threshold
                const subtitle = document.querySelector('.gaps-card .insight-card-subtitle');
                if (subtitle) {
                    subtitle.textContent = `Periods of extended silence (${minGapDays}+ days)`;
                }

                communicationGapsData = await api(`/family/communication-gaps?person_ids=${encodeURIComponent(idsParam)}&days_back=${daysBack}&min_gap_days=${minGapDays}`);
                renderCommunicationGaps();
            } catch (error) {
                console.error('Failed to load communication gaps:', error);
                container.innerHTML = '<div class="insight-empty"><span class="insight-empty-icon">âš ï¸</span>Failed to load data</div>';
            }
        }

        // Render Communication Gaps visualization
        function renderCommunicationGaps() {
            const container = document.getElementById('gapsTimelineContainer');
            if (!container || !communicationGapsData) return;

            const { gaps, person_summaries } = communicationGapsData;
            const minGapDays = getMinGapDays(gapsMonths);

            if (!person_summaries || person_summaries.length === 0) {
                container.innerHTML = '<div class="insight-empty"><span class="insight-empty-icon">âœ¨</span>No significant communication gaps found</div>';
                return;
            }

            // Sort alphabetically by name for consistency across all visualizations
            person_summaries.sort((a, b) => (a.person_name || a.name || '').localeCompare(b.person_name || b.name || ''));

            const now = new Date();
            const periodStart = new Date(now);
            periodStart.setDate(periodStart.getDate() - (gapsMonths * 30));
            const totalDays = gapsMonths * 30;

            // Build HTML for each person
            let html = person_summaries.map(summary => {
                const personGaps = gaps.filter(g => g.person_id === summary.person_id);

                // Create gap markers
                const markers = personGaps.map(gap => {
                    const startDate = new Date(gap.start_date);
                    const endDate = new Date(gap.end_date);
                    const daysSinceStart = Math.floor((startDate - periodStart) / (1000 * 60 * 60 * 24));
                    const leftPct = Math.max(0, Math.min(100, (daysSinceStart / totalDays) * 100));
                    const widthPct = Math.max(1, (gap.gap_days / totalDays) * 100);

                    const startLabel = startDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    const endLabel = endDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

                    return `
                        <div class="gap-marker" style="left: ${leftPct}%; width: ${widthPct}%;">
                            <div class="gap-marker-tooltip">
                                <strong>${gap.gap_days} days</strong><br>
                                ${startLabel} â†’ ${endLabel}
                            </div>
                        </div>
                    `;
                }).join('');

                const gapCount = personGaps.length;
                const statsText = gapCount === 0
                    ? `No gaps over ${minGapDays} days`
                    : `${gapCount} gap${gapCount > 1 ? 's' : ''} | Avg: ${summary.avg_gap_days}d | Max: ${summary.max_gap_days}d`;

                return `
                    <div class="gaps-person-section">
                        <div class="gaps-person-header">
                            <span class="gaps-person-name">${escapeHtml(summary.person_name)}</span>
                            <span class="gaps-person-stats">${statsText}</span>
                        </div>
                        <div class="gaps-timeline">
                            ${markers}
                        </div>
                        <div class="gaps-timeline-labels">
                            <span>${periodStart.toLocaleDateString('en-US', { month: 'short', year: '2-digit' })}</span>
                            <span>Now</span>
                        </div>
                    </div>
                `;
            }).join('');

            // Add overall summary - convert streak to weeks
            const totalGaps = gaps.length;
            const avgGapDays = person_summaries.reduce((a, b) => a + b.avg_gap_days, 0) / person_summaries.length;
            const maxGapDays = Math.max(...person_summaries.map(s => s.max_gap_days));
            const bestStreakDays = Math.max(...person_summaries.map(s => s.longest_streak));
            const bestStreakWeeks = Math.round(bestStreakDays / 7 * 10) / 10;  // Round to 1 decimal

            html += `
                <div class="gaps-summary">
                    <div class="gaps-summary-item">
                        <span class="gaps-summary-value">${totalGaps}</span>
                        <span class="gaps-summary-label">Total Gaps</span>
                    </div>
                    <div class="gaps-summary-item">
                        <span class="gaps-summary-value">${Math.round(avgGapDays)}d</span>
                        <span class="gaps-summary-label">Avg Gap</span>
                    </div>
                    <div class="gaps-summary-item">
                        <span class="gaps-summary-value">${maxGapDays}d</span>
                        <span class="gaps-summary-label">Longest Gap</span>
                    </div>
                    <div class="gaps-summary-item">
                        <span class="gaps-summary-value">${bestStreakWeeks}w</span>
                        <span class="gaps-summary-label">Best Streak</span>
                    </div>
                </div>
            `;

            container.innerHTML = html;
        }

        // Render all family insights visualizations
        function renderFamilyInsights() {
            renderDaysSinceContact();
            renderStreakTracker();
            renderChannelMix();
            loadCommunicationGaps();
        }

        // Change family health period
        async function changeFamilyHealthPeriod(period) {
            familyHealthPeriod = period;

            // Update button active state
            document.querySelectorAll('#familyDashboard .me-health-panel .health-period-pill').forEach(btn => {
                btn.classList.toggle('active', btn.getAttribute('data-period') === period);
            });

            await loadFamilyInteractions();
        }

        // Change family trend period
        async function changeFamilyTrendPeriod(period) {
            familyTrendPeriod = period;

            // Update button active state
            document.querySelectorAll('#familyTrendsPeriodSelector .trends-period-pill').forEach(btn => {
                btn.classList.toggle('active', btn.getAttribute('data-period') === period);
            });

            await loadFamilyInteractions();
        }

        // Load family timeline (interactions with selected family members)
        async function loadFamilyTimeline() {
            const container = document.getElementById('timelineContainer');
            if (!container) return;

            if (selectedFamilyIds.length === 0) {
                container.innerHTML = '<div class="loading">Select family members to see timeline</div>';
                return;
            }

            container.innerHTML = '<div class="loading">Loading timeline...</div>';

            try {
                const idsParam = selectedFamilyIds.join(',');
                const params = new URLSearchParams();
                params.set('person_ids', idsParam);

                // Apply source type filter if set
                const mappedSourceType = mapFilterToSourceType(timelineFilter);
                if (mappedSourceType) {
                    params.set('source_type', mappedSourceType);
                }

                // Apply date filter if set
                const fromDate = document.getElementById('timelineDateFrom')?.value;
                const toDate = document.getElementById('timelineDateTo')?.value;
                if (fromDate && toDate && fromDate === toDate) {
                    params.set('date', fromDate);
                }

                params.set('limit', TIMELINE_LIMIT.toString());

                const data = await api(`/family/timeline?${params.toString()}`);
                timelineData = data.items || [];

                // Update the count display
                updateTimelineCount(data.count || timelineData.length, data.has_more || false);

                renderTimeline();

                // Update filter visibility based on data
                updateTimelineFilterVisibility();
            } catch (error) {
                console.error('Failed to load family timeline:', error);
                container.innerHTML = '<div class="loading">Failed to load timeline</div>';
                updateTimelineCount(0, false);
            }
        }

        // Update hero stats for Me page with phone/slack counts
        function updateMeHeroStatsFromInteractions(data) {
            const bySource = data.by_source || {};

            const phoneCount = bySource.phone || 0;
            const slackCount = bySource.slack || 0;

            // Show phone stat if there's data
            const phoneContainer = document.getElementById('heroStatPhoneContainer');
            if (phoneContainer) {
                if (phoneCount > 0) {
                    phoneContainer.style.display = '';
                    document.getElementById('heroStatPhone').textContent = formatCompactNumber(phoneCount);
                } else {
                    phoneContainer.style.display = 'none';
                }
            }

            // Show slack stat if there's data
            const slackContainer = document.getElementById('heroStatSlackContainer');
            if (slackContainer) {
                if (slackCount > 0) {
                    slackContainer.style.display = '';
                    document.getElementById('heroStatSlack').textContent = formatCompactNumber(slackCount);
                } else {
                    slackContainer.style.display = 'none';
                }
            }
        }

        // Render 100% bar charts from aggregated data
        function renderBreakdownCharts(data) {
            // By Source - use pre-aggregated data
            renderBarChart('chartBySource', data.by_source || {}, 'source');

            // By Month (last 12 months) - sort and take last 12
            const byMonth = data.by_month || {};
            const sortedMonths = Object.keys(byMonth).sort().slice(-12);
            const monthData = {};
            sortedMonths.forEach(m => { monthData[m] = byMonth[m]; });
            renderBarChart('chartByMonth', monthData, 'month');

            // By Dunbar Circle - use pre-aggregated data
            const byCircle = {};
            Object.entries(data.by_circle || {}).forEach(([circle, count]) => {
                byCircle[`Circle ${circle}`] = count;
            });
            renderBarChart('chartByCircle', byCircle, 'circle');
        }

        function renderBarChart(elementId, data, type) {
            const container = document.getElementById(elementId);
            if (!container) return;

            const total = Object.values(data).reduce((a, b) => a + b, 0);
            if (total === 0) {
                container.innerHTML = '<div style="color: var(--text-muted); font-size: 0.75rem; padding: 0.5rem;">No data</div>';
                return;
            }

            let html = '';
            const entries = Object.entries(data).sort((a, b) => b[1] - a[1]);

            entries.forEach(([key, count]) => {
                const pct = (count / total * 100);
                if (pct < 1) return; // Skip tiny segments

                let colorClass = 'bar-other';
                let label = key;

                if (type === 'source') {
                    colorClass = `bar-${key.toLowerCase()}`;
                    label = key.charAt(0).toUpperCase() + key.slice(1);
                } else if (type === 'circle') {
                    const circleNum = parseInt(key.replace('Circle ', ''));
                    colorClass = `bar-circle-${circleNum}`;
                } else if (type === 'month') {
                    const [y, m] = key.split('-');
                    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    label = months[parseInt(m) - 1];
                    // Use a gradient based on position
                    const idx = entries.findIndex(e => e[0] === key);
                    colorClass = `bar-circle-${idx % 8}`;
                }

                html += `<div class="bar-segment ${colorClass}" style="width: ${pct}%;" title="${label}: ${count} (${pct.toFixed(1)}%)">
                    <span class="bar-segment-label">${pct > 8 ? label : ''}</span>
                </div>`;
            });

            container.innerHTML = html;
        }

        // Render top contacts from aggregated data
        function renderTopContacts(data) {
            const container = document.getElementById('meTopContacts');
            if (!container) return;

            const topContacts = data.top_contacts || [];

            if (topContacts.length === 0) {
                container.innerHTML = '<div style="color: var(--text-muted); font-size: 0.75rem;">No recent interactions</div>';
                return;
            }

            let html = '';
            // Show top 10 contacts (scrollable panel)
            topContacts.slice(0, 10).forEach((contact, idx) => {
                html += `<div class="top-contact" onclick="selectPerson('${contact.person_id}')">
                    <div class="top-contact-rank">${idx + 1}</div>
                    <div class="top-contact-info">
                        <div class="top-contact-name">${escapeHtml(contact.person_name)}</div>
                        <div class="top-contact-count">${contact.count} interactions</div>
                    </div>
                </div>`;
            });

            container.innerHTML = html;
        }

        // Current trend period (default: quarter)
        let currentTrendPeriod = 'quarter';

        // Change trend period and reload trends
        async function changeTrendPeriod(period) {
            currentTrendPeriod = period;

            // Update pill button states
            document.querySelectorAll('.trends-period-pill').forEach(pill => {
                pill.classList.toggle('active', pill.dataset.period === period);
            });

            // Show loading state
            const warmingList = document.getElementById('trendsWarmingList');
            const coolingList = document.getElementById('trendsCoolingList');
            if (warmingList) warmingList.innerHTML = '<div style="color: var(--text-muted); font-size: 0.75rem;">Loading...</div>';
            if (coolingList) coolingList.innerHTML = '';

            // Fetch trends for new period
            try {
                const data = await api(`/me/interactions?days_back=1095&trend_period=${period}`);
                renderRelationshipTrends(data);
            } catch (error) {
                console.error('Failed to load trends:', error);
                if (warmingList) warmingList.innerHTML = '<div style="color: var(--text-muted); font-size: 0.75rem;">Failed to load</div>';
            }
        }

        // Render relationship trends (warming/cooling) from aggregated data
        function renderRelationshipTrends(data) {
            const warmingList = document.getElementById('trendsWarmingList');
            const coolingList = document.getElementById('trendsCoolingList');
            if (!warmingList || !coolingList) return;

            const warming = data.warming || [];
            const cooling = data.cooling || [];

            // Render
            const renderTrend = (item, isWarming) => {
                const pctChange = item.previous_count > 0
                    ? Math.round(((item.recent_count - item.previous_count) / item.previous_count) * 100)
                    : (item.recent_count > 0 ? 100 : 0);
                const pctDisplay = pctChange >= 0 ? `+${pctChange}%` : `${pctChange}%`;
                const pctClass = isWarming ? 'trend-pct-warming' : 'trend-pct-cooling';
                return `
                    <div class="trend-item ${isWarming ? 'trend-warming' : 'trend-cooling'}" onclick="selectPerson('${item.person_id}')">
                        <span class="trend-indicator">${isWarming ? 'â†‘' : 'â†“'}</span>
                        <span class="trend-pct ${pctClass}">${pctDisplay}</span>
                        <span class="trend-name">${escapeHtml(item.person_name)}</span>
                        <span class="trend-change">${item.previous_count}â†’${item.recent_count}</span>
                    </div>
                `;
            };

            warmingList.innerHTML = warming.length > 0
                ? warming.slice(0, 5).map(w => renderTrend(w, true)).join('')
                : '<div style="color: var(--text-muted); font-size: 0.75rem; padding: 0.25rem;">No warming trends</div>';

            coolingList.innerHTML = cooling.length > 0
                ? cooling.slice(0, 5).map(c => renderTrend(c, false)).join('')
                : '<div style="color: var(--text-muted); font-size: 0.75rem; padding: 0.25rem;">No cooling trends</div>';
        }

        // Render Relationship Health Score
        let currentHealthPeriod = 'quarter';
        let healthChartData = []; // Store for tooltip lookups

        // Render Health Score Line Chart
        function renderHealthScore(data) {
            const container = document.getElementById('healthChartContainer');
            const scoreEl = document.getElementById('healthCurrentScore');
            if (!container) return;

            const history = data.health_score_history || [];
            healthChartData = history; // Store for tooltip

            // Use most recent chart value as current score (more accurate)
            const currentScore = history.length > 0 ? history[history.length - 1].score : (data.relationship_health_score || 0);

            // Update current score display with same color as dots
            if (scoreEl) {
                scoreEl.textContent = currentScore;
                // Color matches dot colors
                let color = '#ef4444';                        // Red - poor (<25)
                if (currentScore >= 80) color = '#22c55e';    // Bright green - excellent
                else if (currentScore >= 60) color = '#86efac'; // Light green - above avg
                else if (currentScore >= 40) color = '#9ca3af'; // Light gray - around avg
                else if (currentScore >= 25) color = '#f97316'; // Orange - below avg
                scoreEl.style.color = color;
            }

            if (history.length === 0) {
                container.innerHTML = '<div style="color: var(--text-muted); font-size: 0.8rem; padding: 1rem; text-align: center;">No health history data</div>';
                return;
            }

            // SVG dimensions - match typical container aspect ratio (roughly 4:1)
            const width = 600;
            const height = 120;
            const padding = { top: 10, right: 15, bottom: 20, left: 30 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            // Scale functions
            const xScale = (i) => padding.left + (i / Math.max(history.length - 1, 1)) * chartWidth;
            const yScale = (score) => padding.top + chartHeight - (score / 100) * chartHeight;

            // Build line path
            const linePath = history.map((point, i) => {
                const x = xScale(i);
                const y = yScale(point.score);
                return `${i === 0 ? 'M' : 'L'} ${x} ${y}`;
            }).join(' ');

            // Build area path (closed shape for fill)
            const areaPath = linePath +
                ` L ${xScale(history.length - 1)} ${padding.top + chartHeight}` +
                ` L ${padding.left} ${padding.top + chartHeight} Z`;

            // Helper to get dot color based on score relative to average (50)
            function getDotColor(score) {
                if (score >= 80) return '#22c55e';      // Bright green - excellent
                if (score >= 60) return '#86efac';      // Light green - above avg
                if (score >= 40) return '#9ca3af';      // Light gray - around avg
                if (score >= 25) return '#f97316';      // Orange - below avg
                return '#ef4444';                        // Red - poor
            }

            // Build dots with data attributes for tooltips, colored by score
            const avgCount = data.health_score_average || 0;
            const dots = history.map((point, i) => {
                const x = xScale(i);
                const y = yScale(point.score);
                const color = getDotColor(point.score);
                const count = point.count || 0;
                return `<circle class="health-chart-dot" cx="${x}" cy="${y}" r="4" data-index="${i}" data-score="${point.score}" data-count="${count}" data-avg="${avgCount}" data-date="${point.date}" style="fill: ${color};"/>`;
            }).join('');

            // Y-axis grid lines (at 25, 50, 75)
            const gridLines = [25, 50, 75].map(val => {
                const y = yScale(val);
                return `<line class="health-chart-grid-line" x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}"/>`;
            }).join('');

            // Y-axis labels (show "Avg" at 50)
            const yLabels = [{val: 0, label: '0'}, {val: 50, label: 'Avg'}, {val: 100, label: '100'}].map(({val, label}) => {
                const y = yScale(val);
                return `<text x="${padding.left - 5}" y="${y + 3}" font-size="11" fill="var(--text-primary)" text-anchor="end">${label}</text>`;
            }).join('');

            // X-axis labels (first, middle, last)
            const xLabels = [];
            if (history.length > 0) {
                const formatLabel = (dateStr) => {
                    const d = new Date(dateStr);
                    return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                };
                xLabels.push(`<text x="${xScale(0)}" y="${height - 2}" font-size="11" fill="var(--text-primary)" text-anchor="start">${formatLabel(history[0].date)}</text>`);
                if (history.length > 2) {
                    const midIdx = Math.floor(history.length / 2);
                    xLabels.push(`<text x="${xScale(midIdx)}" y="${height - 2}" font-size="11" fill="var(--text-primary)" text-anchor="middle">${formatLabel(history[midIdx].date)}</text>`);
                }
                xLabels.push(`<text x="${xScale(history.length - 1)}" y="${height - 2}" font-size="11" fill="var(--text-primary)" text-anchor="end">${formatLabel(history[history.length - 1].date)}</text>`);
            }

            container.innerHTML = `
                <div class="health-line-chart" style="position: relative;">
                    <svg class="health-chart-svg" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">
                        ${gridLines}
                        ${yLabels}
                        <path class="health-chart-area" d="${areaPath}" style="fill: #9ca3af; opacity: 0.1;"/>
                        <path class="health-chart-line" d="${linePath}" style="stroke: #9ca3af;"/>
                        ${dots}
                        ${xLabels.join('')}
                    </svg>
                    <div class="health-chart-tooltip" id="healthChartTooltip"></div>
                </div>
            `;

            // Setup instant hover tooltips
            setupHealthChartTooltips();
        }

        // Setup instant tooltips for health chart
        function setupHealthChartTooltips() {
            const container = document.querySelector('.health-line-chart');
            const tooltip = document.getElementById('healthChartTooltip');
            const dots = document.querySelectorAll('.health-chart-dot');

            if (!container || !tooltip) return;

            dots.forEach(dot => {
                dot.addEventListener('mouseenter', (e) => {
                    const score = dot.dataset.score;
                    const count = dot.dataset.count || 0;
                    const avg = dot.dataset.avg || 0;
                    const dateStr = dot.dataset.date;
                    const d = new Date(dateStr);
                    const formattedDate = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

                    tooltip.innerHTML = `
                        <div class="health-chart-tooltip-date">${formattedDate}</div>
                        <div class="health-chart-tooltip-score">Score: ${score}</div>
                        <div style="font-size: 0.6rem; color: var(--text-muted);">Interactions: ${count}</div>
                        <div style="font-size: 0.6rem; color: var(--text-muted);">Avg. for Period: ${avg}</div>
                    `;

                    // Position tooltip near the dot
                    const rect = dot.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();
                    tooltip.style.left = `${rect.left - containerRect.left + rect.width / 2}px`;
                    tooltip.style.top = `${rect.top - containerRect.top - 8}px`;
                    tooltip.style.transform = 'translate(-50%, -100%)';
                    tooltip.classList.add('visible');
                });

                dot.addEventListener('mouseleave', () => {
                    tooltip.classList.remove('visible');
                });
            });
        }

        // Change health score period
        async function changeHealthPeriod(period) {
            currentHealthPeriod = period;

            // Update pill states (only the main health panel, not tracked panels)
            document.querySelectorAll('#healthChartContainer').forEach(container => {
                const panel = container.closest('.me-health-panel');
                if (panel) {
                    panel.querySelectorAll('.health-period-pill').forEach(pill => {
                        pill.classList.toggle('active', pill.dataset.period === period);
                    });
                }
            });

            // Show loading
            const container = document.getElementById('healthChartContainer');
            if (container) {
                container.innerHTML = '<div style="color: var(--text-muted); font-size: 0.75rem; text-align: center; padding: 1rem;">Loading...</div>';
            }

            // Fetch new data
            try {
                const data = await api(`/me/interactions?days_back=1095&health_period=${period}`);
                renderHealthScore(data);
            } catch (error) {
                console.error('Failed to load health history:', error);
                if (container) {
                    container.innerHTML = '<div style="color: var(--text-muted); font-size: 0.75rem; text-align: center; padding: 1rem;">Failed to load</div>';
                }
            }
        }

        // Tracked Relationships state
        let currentTrackedPeriods = {
            parent: 'quarter',
            coparent: 'quarter'
        };
        let trackedRelationshipsData = [];

        // Render all tracked relationships
        function renderTrackedRelationships(data) {
            trackedRelationshipsData = data.tracked_relationships || [];

            trackedRelationshipsData.forEach(rel => {
                if (rel.name === 'Parent Relationship') {
                    renderTrackedChart('parent', rel);
                } else if (rel.name === 'Parallel Parenting') {
                    renderTrackedChart('coparent', rel);
                }
            });
        }

        // Render a single tracked relationship chart
        function renderTrackedChart(type, data) {
            const containerId = type === 'parent' ? 'parentChartContainer' : 'coparentChartContainer';
            const countId = type === 'parent' ? 'parentCurrentCount' : 'coparentCurrentCount';
            const peopleListId = type === 'parent' ? 'parentPeopleList' : 'coparentPeopleList';

            const container = document.getElementById(containerId);
            const countEl = document.getElementById(countId);
            const peopleListEl = document.getElementById(peopleListId);

            if (!container) return;

            const history = data.history || [];
            const isInverse = data.healthy_direction === 'less';  // fewer = healthier

            // Update current score display with same color as dots
            if (countEl) {
                const currentScore = data.current_score || 0;
                countEl.textContent = currentScore;

                // Color matches dot colors
                let color = '#ef4444';                        // Red - poor (<25)
                if (currentScore >= 80) color = '#22c55e';    // Bright green - excellent
                else if (currentScore >= 60) color = '#86efac'; // Light green - above avg
                else if (currentScore >= 40) color = '#9ca3af'; // Light gray - around avg
                else if (currentScore >= 25) color = '#f97316'; // Orange - below avg
                countEl.style.color = color;
                countEl.className = 'tracked-current-count';
            }

            // Render people chips
            if (peopleListEl) {
                const personIds = data.person_ids || [];
                const personNames = data.person_names || [];
                peopleListEl.innerHTML = personNames.map((name, i) => `
                    <span class="tracked-person-chip" onclick="selectPerson('${personIds[i]}')">${escapeHtml(name)}</span>
                `).join('');
            }

            if (history.length === 0) {
                container.innerHTML = '<div style="color: var(--text-muted); font-size: 0.8rem; padding: 1rem; text-align: center;">No interaction history</div>';
                return;
            }

            // Fixed 0-100 Y-axis for scores (like health score)
            const yAxisMax = 100;

            // SVG dimensions
            const width = 600;
            const height = 120;
            const padding = { top: 10, right: 15, bottom: 20, left: 30 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            // Scale functions
            const xScale = (i) => padding.left + (i / Math.max(history.length - 1, 1)) * chartWidth;
            const yScale = (score) => padding.top + chartHeight - (score / yAxisMax) * chartHeight;

            // Build line path
            const linePath = history.map((point, i) => {
                const x = xScale(i);
                const y = yScale(point.score);
                return `${i === 0 ? 'M' : 'L'} ${x} ${y}`;
            }).join(' ');

            // Build area path
            const areaPath = linePath +
                ` L ${xScale(history.length - 1)} ${padding.top + chartHeight}` +
                ` L ${padding.left} ${padding.top + chartHeight} Z`;

            // Helper to get dot color based on score relative to average (50)
            function getDotColor(score) {
                if (score >= 80) return '#22c55e';      // Bright green - excellent
                if (score >= 60) return '#86efac';      // Light green - above avg
                if (score >= 40) return '#9ca3af';      // Light gray - around avg
                if (score >= 25) return '#f97316';      // Orange - below avg
                return '#ef4444';                        // Red - poor
            }

            // Build dots with colors based on score
            const avgCount = data.average || 0;
            const dots = history.map((point, i) => {
                const x = xScale(i);
                const y = yScale(point.score);
                const color = getDotColor(point.score);
                const count = point.count || 0;
                return `<circle class="tracked-chart-dot" cx="${x}" cy="${y}" r="4" data-index="${i}" data-score="${point.score}" data-count="${count}" data-avg="${avgCount}" data-date="${point.date}" style="fill: ${color};"/>`;
            }).join('');

            // Y-axis grid lines (at 25, 50, 75 like health score)
            const gridLines = [25, 50, 75].map(val => {
                const y = yScale(val);
                return `<line class="health-chart-grid-line" x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}"/>`;
            }).join('');

            // Y-axis labels (show "Avg" at 50)
            const yLabels = [{val: 0, label: '0'}, {val: 50, label: 'Avg'}, {val: 100, label: '100'}].map(({val, label}) => {
                const y = yScale(val);
                return `<text x="${padding.left - 5}" y="${y + 3}" font-size="11" fill="var(--text-primary)" text-anchor="end">${label}</text>`;
            }).join('');

            // X-axis labels
            const xLabels = [];
            if (history.length > 0) {
                const formatLabel = (dateStr) => {
                    const d = new Date(dateStr);
                    return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                };
                xLabels.push(`<text x="${xScale(0)}" y="${height - 2}" font-size="11" fill="var(--text-primary)" text-anchor="start">${formatLabel(history[0].date)}</text>`);
                if (history.length > 2) {
                    const midIdx = Math.floor(history.length / 2);
                    xLabels.push(`<text x="${xScale(midIdx)}" y="${height - 2}" font-size="11" fill="var(--text-primary)" text-anchor="middle">${formatLabel(history[midIdx].date)}</text>`);
                }
                xLabels.push(`<text x="${xScale(history.length - 1)}" y="${height - 2}" font-size="11" fill="var(--text-primary)" text-anchor="end">${formatLabel(history[history.length - 1].date)}</text>`);
            }

            container.innerHTML = `
                <div class="tracked-line-chart" style="position: relative;" data-type="${type}">
                    <svg class="health-chart-svg" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">
                        ${gridLines}
                        ${yLabels}
                        <path d="${areaPath}" style="fill: #9ca3af; opacity: 0.1;"/>
                        <path d="${linePath}" style="fill: none; stroke: #9ca3af; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round;"/>
                        ${dots}
                        ${xLabels.join('')}
                    </svg>
                    <div class="health-chart-tooltip" id="${type}ChartTooltip"></div>
                </div>
            `;

            // Setup tooltips
            setupTrackedChartTooltips(type);
        }

        // Setup tooltips for tracked chart
        function setupTrackedChartTooltips(type) {
            const container = document.querySelector(`.tracked-line-chart[data-type="${type}"]`);
            const tooltip = document.getElementById(`${type}ChartTooltip`);
            const dots = container ? container.querySelectorAll('.tracked-chart-dot') : [];

            if (!container || !tooltip) return;

            dots.forEach(dot => {
                dot.addEventListener('mouseenter', (e) => {
                    const score = dot.dataset.score;
                    const count = dot.dataset.count || 0;
                    const avg = dot.dataset.avg || 0;
                    const dateStr = dot.dataset.date;
                    const d = new Date(dateStr);
                    const formattedDate = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

                    tooltip.innerHTML = `
                        <div class="health-chart-tooltip-date">${formattedDate}</div>
                        <div class="health-chart-tooltip-score">Score: ${score}</div>
                        <div style="font-size: 0.6rem; color: var(--text-muted);">Interactions: ${count}</div>
                        <div style="font-size: 0.6rem; color: var(--text-muted);">Avg. for Period: ${avg}</div>
                    `;

                    const rect = dot.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();
                    tooltip.style.left = `${rect.left - containerRect.left + rect.width / 2}px`;
                    tooltip.style.top = `${rect.top - containerRect.top - 8}px`;
                    tooltip.style.transform = 'translate(-50%, -100%)';
                    tooltip.classList.add('visible');
                });

                dot.addEventListener('mouseleave', () => {
                    tooltip.classList.remove('visible');
                });
            });
        }

        // Change tracked relationship period
        async function changeTrackedPeriod(type, period) {
            currentTrackedPeriods[type] = period;

            // Update pill states for this panel only
            const selectorId = type === 'parent' ? 'parentPeriodSelector' : 'coparentPeriodSelector';
            const selector = document.getElementById(selectorId);
            if (selector) {
                selector.querySelectorAll('.health-period-pill').forEach(pill => {
                    pill.classList.toggle('active', pill.dataset.period === period);
                });
            }

            // Show loading
            const containerId = type === 'parent' ? 'parentChartContainer' : 'coparentChartContainer';
            const container = document.getElementById(containerId);
            if (container) {
                container.innerHTML = '<div style="color: var(--text-muted); font-size: 0.75rem; text-align: center; padding: 1rem;">Loading...</div>';
            }

            // Fetch new data
            try {
                const data = await api(`/me/interactions?days_back=1095&health_period=${period}`);
                const tracked = data.tracked_relationships || [];
                const targetName = type === 'parent' ? 'Parent Relationship' : 'Parallel Parenting';
                const rel = tracked.find(r => r.name === targetName);
                if (rel) {
                    renderTrackedChart(type, rel);
                }
            } catch (error) {
                console.error('Failed to load tracked relationship:', error);
                if (container) {
                    container.innerHTML = '<div style="color: var(--text-muted); font-size: 0.75rem; text-align: center; padding: 1rem;">Failed to load</div>';
                }
            }
        }

        // Render Neglected Contacts
        function renderNeglectedContacts(data) {
            const container = document.getElementById('neglectedContactsList');
            if (!container) return;

            const neglected = data.neglected_contacts || [];

            if (neglected.length === 0) {
                container.innerHTML = '<div style="color: var(--text-muted); font-size: 0.8rem; padding: 1rem; text-align: center;">All caught up! No neglected contacts.</div>';
                return;
            }

            // Show top 20 (scrollable list)
            container.innerHTML = neglected.slice(0, 20).map(item => `
                <div class="neglected-item" onclick="selectPerson('${item.person_id}')">
                    <div class="neglected-circle neglected-circle-${item.dunbar_circle}">${item.dunbar_circle}</div>
                    <span class="neglected-name">${escapeHtml(item.person_name)}</span>
                    <span class="neglected-days">${item.days_since_contact}d ago</span>
                    <span class="neglected-typical">(usually ${item.typical_gap_days}d)</span>
                </div>
            `).join('');
        }

        // Render Network Growth Chart
        let networkGrowthData = []; // Store all data
        let networkGrowthCenterMonth = null; // null = default (most recent 12 months)

        function setGrowthCenterMonth(month) {
            const today = new Date();
            const currentMonth = today.toISOString().slice(0, 7);
            const clickedDate = new Date(month + '-01');
            const currentDate = new Date(currentMonth + '-01');
            const monthsBack = (currentDate.getFullYear() - clickedDate.getFullYear()) * 12 + (currentDate.getMonth() - clickedDate.getMonth());

            if (monthsBack < 6) {
                networkGrowthCenterMonth = null;
            } else {
                networkGrowthCenterMonth = month;
            }
            renderNetworkGrowthChart();
        }

        function resetGrowthCenter() {
            networkGrowthCenterMonth = null;
            renderNetworkGrowthChart();
        }

        function getGrowthWindowData() {
            const allData = networkGrowthData;
            if (allData.length === 0) return [];
            const sortedData = [...allData].sort((a, b) => a.month.localeCompare(b.month));

            if (!networkGrowthCenterMonth) {
                return sortedData.slice(-12);
            }

            const centerIndex = sortedData.findIndex(m => m.month === networkGrowthCenterMonth);
            if (centerIndex === -1) {
                return sortedData.slice(-12);
            }

            const startIndex = Math.max(0, centerIndex - 6);
            const endIndex = Math.min(sortedData.length, startIndex + 12);
            const adjustedStart = Math.max(0, endIndex - 12);
            return sortedData.slice(adjustedStart, endIndex);
        }

        function renderNetworkGrowth(data) {
            const container = document.getElementById('networkGrowthChart');
            if (!container) return;

            networkGrowthData = data.network_growth || [];
            if (networkGrowthData.length === 0) {
                container.innerHTML = '<div style="color: var(--text-muted); font-size: 0.8rem; padding: 1rem; text-align: center;">No network growth data</div>';
                return;
            }

            renderNetworkGrowthChart();
        }

        function renderNetworkGrowthChart() {
            const container = document.getElementById('networkGrowthChart');
            if (!container || networkGrowthData.length === 0) return;

            const growth = getGrowthWindowData();
            const maxNew = Math.max(...growth.map(g => g.new_people), 1);

            // Reset button if not at default view
            const resetBtnHtml = networkGrowthCenterMonth ? `<button class="growth-reset-btn" onclick="resetGrowthCenter()">â†» Now</button>` : '';

            // Generate y-axis labels (0, mid, max)
            const yAxisMid = Math.round(maxNew / 2);
            const yAxisLabels = `
                <div class="growth-y-axis">
                    <div class="growth-y-label">${maxNew}</div>
                    <div class="growth-y-label">${yAxisMid}</div>
                    <div class="growth-y-label">0</div>
                </div>
            `;

            const barsHtml = growth.map((g, idx) => {
                const height = (g.new_people / maxNew) * 100;
                return `
                    <div class="growth-bar-container" data-index="${idx}">
                        <div class="growth-bar" style="height: ${Math.max(height, 2)}%;"></div>
                    </div>
                `;
            }).join('');

            const labelsHtml = growth.map(g => {
                const [year, month] = g.month.split('-');
                const label = `${month}/${year.slice(-2)}`;
                return `<div class="growth-label clickable-month" onclick="setGrowthCenterMonth('${g.month}')">${label}</div>`;
            }).join('');

            container.innerHTML = `
                <div class="growth-chart" style="position: relative;">
                    ${resetBtnHtml ? `<div class="growth-chart-header">${resetBtnHtml}</div>` : ''}
                    <div class="growth-chart-inner">
                        ${yAxisLabels}
                        <div class="growth-bars">${barsHtml}</div>
                    </div>
                    <div class="growth-labels" style="margin-left: 24px;">${labelsHtml}</div>
                    <div class="growth-tooltip" id="growthTooltip"></div>
                </div>
            `;

            // Setup instant hover tooltips
            setupNetworkGrowthTooltips(growth);
        }

        // Setup instant tooltips for network growth chart
        function setupNetworkGrowthTooltips(windowedData) {
            const chartContainer = document.querySelector('.growth-chart');
            const tooltip = document.getElementById('growthTooltip');
            const bars = document.querySelectorAll('.growth-bar-container');

            if (!chartContainer || !tooltip) return;

            bars.forEach(bar => {
                bar.addEventListener('mouseenter', (e) => {
                    const idx = parseInt(bar.dataset.index);
                    const g = windowedData[idx];
                    if (!g) return;

                    const d = new Date(g.month + '-01');
                    const monthName = d.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });

                    tooltip.innerHTML = `
                        <div style="color: var(--text-muted); font-size: 0.6rem;">${monthName}</div>
                        <div style="font-weight: 600; color: var(--people);">${g.new_people} new people</div>
                    `;

                    // Position tooltip near the bar
                    const rect = bar.getBoundingClientRect();
                    const containerRect = chartContainer.getBoundingClientRect();
                    tooltip.style.left = `${rect.left - containerRect.left + rect.width / 2}px`;
                    tooltip.style.top = `${rect.top - containerRect.top - 8}px`;
                    tooltip.style.transform = 'translate(-50%, -100%)';
                    tooltip.classList.add('visible');
                });

                bar.addEventListener('mouseleave', () => {
                    tooltip.classList.remove('visible');
                });
            });
        }

        // Render Messaging Volume by Circle Chart
        // Store raw messaging data for filtering
        let messagingByCircleData = [];
        let messagingCircleFilters = new Set(['1', '2', '3', '4']);  // Inner circle excluded by default
        let messagingDisplayMode = 'raw';  // 'raw' or 'percent'
        let messagingCountMode = 'all';  // 'all' (message counts) or 'unique' (unique people)
        let messagingCenterMonth = null;  // null = default (most recent 12 months), or 'YYYY-MM' to center on

        function toggleMessagingDisplayMode(mode) {
            messagingDisplayMode = mode;
            renderMessagingChart();
        }

        function toggleMessagingCountMode(mode) {
            messagingCountMode = mode;
            renderMessagingChart();
        }

        function setMessagingCenterMonth(month) {
            // Get today's month
            const today = new Date();
            const currentMonth = today.toISOString().slice(0, 7);

            // Calculate how many months back the clicked month is
            const clickedDate = new Date(month + '-01');
            const currentDate = new Date(currentMonth + '-01');
            const monthsBack = (currentDate.getFullYear() - clickedDate.getFullYear()) * 12 + (currentDate.getMonth() - clickedDate.getMonth());

            // If clicking on a recent month (within last 6 months), cap at current view
            if (monthsBack < 6) {
                messagingCenterMonth = null;  // Reset to default
            } else {
                messagingCenterMonth = month;
            }
            renderMessagingChart();
        }

        function resetMessagingCenter() {
            messagingCenterMonth = null;
            renderMessagingChart();
        }

        // Get the 12-month window based on center month
        function getMessagingWindowData() {
            const allData = messagingByCircleData;
            if (allData.length === 0) return [];

            // Sort data by month
            const sortedData = [...allData].sort((a, b) => a.month.localeCompare(b.month));

            if (!messagingCenterMonth) {
                // Default: show most recent 12 months
                return sortedData.slice(-12);
            }

            // Find index of center month
            const centerIndex = sortedData.findIndex(m => m.month === messagingCenterMonth);
            if (centerIndex === -1) {
                // Center month not in data, return default
                return sortedData.slice(-12);
            }

            // Get 6 months before and 6 months after (including center = 13 months, but we show 12)
            // Actually, for 12 months centered: 5 before, center, 6 after = 12 total
            // Or: 6 before, center, 5 after = 12 total
            const startIndex = Math.max(0, centerIndex - 6);
            const endIndex = Math.min(sortedData.length, startIndex + 12);

            // Adjust start if we hit the end
            const adjustedStart = Math.max(0, endIndex - 12);

            return sortedData.slice(adjustedStart, endIndex);
        }

        function renderMessagingByCircle(data) {
            const container = document.getElementById('messagingByCircleChart');
            if (!container) return;

            messagingByCircleData = data.messaging_by_circle || [];
            if (messagingByCircleData.length === 0) {
                container.innerHTML = '<div style="color: var(--text-muted); font-size: 0.8rem; padding: 1rem; text-align: center;">No messaging data</div>';
                return;
            }

            renderMessagingChart();
        }

        function toggleCircleFilter(circle) {
            if (messagingCircleFilters.has(circle)) {
                // Don't allow removing the last filter
                if (messagingCircleFilters.size > 1) {
                    messagingCircleFilters.delete(circle);
                }
            } else {
                messagingCircleFilters.add(circle);
            }
            renderMessagingChart();
        }

        function renderMessagingChart() {
            const container = document.getElementById('messagingByCircleChart');
            if (!container || messagingByCircleData.length === 0) return;

            // Use windowed data based on center month selection
            const messaging = getMessagingWindowData();
            const selectedCircles = Array.from(messagingCircleFilters);
            const circleLabels = ['Inner', 'Close', 'Friend', 'Acquaint', 'Familiar', 'Outer'];
            const isPercentMode = messagingDisplayMode === 'percent';
            const isUniqueMode = messagingCountMode === 'unique';

            // Recalculate totals based on selected circles only
            // Use unique_by_circle when in unique mode, by_circle otherwise
            const filteredData = messaging.map(m => {
                const dataSource = isUniqueMode ? (m.unique_by_circle || {}) : m.by_circle;
                const filteredTotal = selectedCircles.reduce((sum, c) => sum + (dataSource[c] || 0), 0);
                const filteredPercentages = {};
                selectedCircles.forEach(c => {
                    filteredPercentages[c] = filteredTotal > 0 ? ((dataSource[c] || 0) / filteredTotal * 100) : 0;
                });
                // Keep both message and unique data for tooltips
                return { ...m, filteredTotal, filteredPercentages, dataSource };
            });

            const maxTotal = Math.max(...filteredData.map(m => m.filteredTotal), 1);

            // Calculate average distribution for comparison
            const avgByCircle = {};
            selectedCircles.forEach(c => {
                avgByCircle[c] = filteredData.reduce((sum, m) => sum + (m.dataSource[c] || 0), 0);
            });
            const avgTotal = Object.values(avgByCircle).reduce((a, b) => a + b, 0);
            const avgPercentages = {};
            selectedCircles.forEach(c => {
                avgPercentages[c] = avgTotal > 0 ? (avgByCircle[c] / avgTotal * 100).toFixed(1) : 0;
            });

            // Build stacked bars with data attributes for tooltips
            // Order: outer circles (4) at bottom, inner circles (0) at top
            // Sort descending so higher circle numbers render first (at bottom of stack)
            const orderedCircles = [...selectedCircles].sort((a, b) => parseInt(b) - parseInt(a));

            const barsHtml = filteredData.map((m, idx) => {
                // In percent mode, all bars are 100% height; in raw mode, scale by maxTotal
                const barHeight = isPercentMode ? 100 : (m.filteredTotal / maxTotal) * 100;

                // Segments always fill 100% of their bar - their heights are percentages within the bar
                const segments = orderedCircles.map(circle => {
                    const pct = m.filteredPercentages[circle] || 0;
                    return pct > 0 ? `<div class="messaging-segment messaging-segment-${circle}" style="height: ${pct}%;"></div>` : '';
                }).join('');

                return `
                    <div class="messaging-bar-container" data-index="${idx}">
                        <div class="messaging-stacked-bar" style="height: ${Math.max(barHeight, 2)}%;">${segments}</div>
                    </div>
                `;
            }).join('');

            // Generate y-axis labels based on mode
            let yAxisLabels;
            if (isPercentMode) {
                yAxisLabels = `
                    <div class="messaging-y-axis">
                        <div class="messaging-y-label">100%</div>
                        <div class="messaging-y-label">50%</div>
                        <div class="messaging-y-label">0%</div>
                    </div>
                `;
            } else {
                const yAxisMax = Math.max(...filteredData.map(m => m.filteredTotal), 1);
                const yAxisMid = Math.round(yAxisMax / 2);
                const formatYLabel = (n) => n >= 1000 ? `${(n/1000).toFixed(0)}k` : n;
                yAxisLabels = `
                    <div class="messaging-y-axis">
                        <div class="messaging-y-label">${formatYLabel(yAxisMax)}</div>
                        <div class="messaging-y-label">${formatYLabel(yAxisMid)}</div>
                        <div class="messaging-y-label">0</div>
                    </div>
                `;
            }

            const labelsHtml = filteredData.map(m => {
                const [year, month] = m.month.split('-');
                const label = `${month}/${year.slice(-2)}`;
                return `<div class="messaging-label clickable-month" onclick="setMessagingCenterMonth('${m.month}')">${label}</div>`;
            }).join('');

            // Display mode toggle (Raw / Percent) and count mode toggle (All / Unique) and Reset button
            const resetBtnHtml = messagingCenterMonth ? `<button class="messaging-reset-btn" onclick="resetMessagingCenter()">â†» Now</button>` : '';
            const modeToggleHtml = `
                <div class="messaging-toggles-container">
                    <div class="messaging-mode-toggle">
                        <button class="mode-toggle-btn ${!isPercentMode ? 'active' : ''}" onclick="toggleMessagingDisplayMode('raw')">Raw</button>
                        <button class="mode-toggle-btn ${isPercentMode ? 'active' : ''}" onclick="toggleMessagingDisplayMode('percent')">%</button>
                    </div>
                    <div class="messaging-mode-toggle">
                        <button class="mode-toggle-btn ${!isUniqueMode ? 'active' : ''}" onclick="toggleMessagingCountMode('all')">All</button>
                        <button class="mode-toggle-btn ${isUniqueMode ? 'active' : ''}" onclick="toggleMessagingCountMode('unique')">Unique</button>
                    </div>
                </div>
                ${resetBtnHtml}
            `;

            // Legend with toggles
            const legendHtml = ['0', '1', '2', '3', '4'].map(c => {
                const isSelected = messagingCircleFilters.has(c);
                return `
                    <div class="legend-item legend-toggle ${isSelected ? 'selected' : ''}" onclick="toggleCircleFilter('${c}')">
                        <div class="legend-dot messaging-segment-${c}"></div>
                        <span>${circleLabels[parseInt(c)]}</span>
                    </div>
                `;
            }).join('');

            // Generate insights based on the filtered data (show up to 4)
            const allInsights = generateMessagingInsights(filteredData, selectedCircles, avgPercentages, avgTotal, circleLabels);
            const insightsHtml = allInsights.slice(0, 4).map(i => `<div class="messaging-insight">${i}</div>`).join('');

            container.innerHTML = `
                <div class="messaging-chart" style="position: relative;">
                    <div class="messaging-chart-header">
                        ${modeToggleHtml}
                    </div>
                    <div class="messaging-chart-inner">
                        ${yAxisLabels}
                        <div class="messaging-stacked-bars">${barsHtml}</div>
                    </div>
                    <div class="messaging-labels" style="margin-left: 28px;">${labelsHtml}</div>
                    <div class="messaging-legend">${legendHtml}</div>
                    ${insightsHtml}
                    <div class="messaging-tooltip" id="messagingTooltip"></div>
                </div>
            `;

            // Setup instant hover tooltips
            setupMessagingTooltips(filteredData, selectedCircles, circleLabels, isUniqueMode);
        }

        // Setup instant tooltips for messaging chart
        function setupMessagingTooltips(filteredData, selectedCircles, circleLabels, isUniqueMode) {
            const chartContainer = document.querySelector('.messaging-chart');
            const tooltip = document.getElementById('messagingTooltip');
            const bars = document.querySelectorAll('.messaging-bar-container');

            if (!chartContainer || !tooltip) return;

            bars.forEach(bar => {
                bar.addEventListener('mouseenter', (e) => {
                    const idx = parseInt(bar.dataset.index);
                    const m = filteredData[idx];
                    if (!m) return;

                    const d = new Date(m.month + '-01');
                    const monthName = d.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });

                    // Build breakdown by circle - use the appropriate data source
                    const breakdown = selectedCircles.map(c => {
                        const count = m.dataSource[c] || 0;
                        const pct = m.filteredPercentages[c]?.toFixed(0) || 0;
                        return count > 0 ? `<div style="display: flex; justify-content: space-between; gap: 1rem;"><span style="color: var(--text-muted);">${circleLabels[parseInt(c)]}</span><span>${count} (${pct}%)</span></div>` : '';
                    }).filter(Boolean).join('');

                    const unitLabel = isUniqueMode ? 'people' : 'messages';
                    tooltip.innerHTML = `
                        <div style="color: var(--text-muted); font-size: 0.6rem; margin-bottom: 0.25rem;">${monthName}</div>
                        <div style="font-weight: 600; color: var(--people); margin-bottom: 0.25rem;">${m.filteredTotal.toLocaleString()} ${unitLabel}</div>
                        ${breakdown}
                    `;

                    // Position tooltip near the bar
                    const rect = bar.getBoundingClientRect();
                    const containerRect = chartContainer.getBoundingClientRect();
                    tooltip.style.left = `${rect.left - containerRect.left + rect.width / 2}px`;
                    tooltip.style.top = `${rect.top - containerRect.top - 8}px`;
                    tooltip.style.transform = 'translate(-50%, -100%)';
                    tooltip.classList.add('visible');
                });

                bar.addEventListener('mouseleave', () => {
                    tooltip.classList.remove('visible');
                });
            });
        }

        // Generate messaging insights based on filtered data
        function generateMessagingInsights(filteredData, selectedCircles, avgPercentages, avgTotal, circleLabels) {
            const insights = [];
            if (filteredData.length < 2 || avgTotal === 0) return insights;

            const recent = filteredData[filteredData.length - 1];
            const previous = filteredData[filteredData.length - 2];
            const avgMonthlyTotal = avgTotal / filteredData.length;
            const recentTotal = recent.filteredTotal;

            // Helper to get month name
            const getMonthName = (monthStr) => new Date(monthStr + '-01').toLocaleDateString('en-US', { month: 'short' });
            const recentMonthName = getMonthName(recent.month);

            // 1. Volume comparison vs average
            const volumeDiff = avgMonthlyTotal > 0 ? ((recentTotal - avgMonthlyTotal) / avgMonthlyTotal * 100) : 0;
            if (Math.abs(volumeDiff) >= 15) {
                const volumeDesc = volumeDiff > 0 ? `${Math.abs(volumeDiff).toFixed(0)}% more` : `${Math.abs(volumeDiff).toFixed(0)}% fewer`;
                insights.push(`In ${recentMonthName}, you sent ${volumeDesc} messages than your monthly average.`);
            }

            // 2. Inner circle concentration (circles 0-1 vs others)
            const innerCircles = selectedCircles.filter(c => c === '0' || c === '1');
            if (innerCircles.length > 0) {
                const innerPct = innerCircles.reduce((sum, c) => sum + (recent.filteredPercentages[c] || 0), 0);
                const avgInnerPct = innerCircles.reduce((sum, c) => sum + parseFloat(avgPercentages[c] || 0), 0);
                const concentrationDiff = innerPct - avgInnerPct;

                if (Math.abs(concentrationDiff) >= 8) {
                    if (concentrationDiff > 0) {
                        insights.push(`${recentMonthName} was more focused on your closest relationships (${innerPct.toFixed(0)}% to inner circles vs ${avgInnerPct.toFixed(0)}% average).`);
                    } else {
                        insights.push(`${recentMonthName} saw more outreach to your broader network (${(100 - innerPct).toFixed(0)}% outside inner circles).`);
                    }
                }
            }

            // 3. Month-over-month trend
            if (previous) {
                const momChange = previous.filteredTotal > 0 ? ((recentTotal - previous.filteredTotal) / previous.filteredTotal * 100) : 0;
                const prevMonthName = getMonthName(previous.month);
                if (Math.abs(momChange) >= 25) {
                    const direction = momChange > 0 ? 'increased' : 'decreased';
                    insights.push(`Messaging ${direction} ${Math.abs(momChange).toFixed(0)}% from ${prevMonthName} to ${recentMonthName}.`);
                }
            }

            // 4. Dominant circle insight
            let maxCircle = null;
            let maxPct = 0;
            selectedCircles.forEach(c => {
                const pct = recent.filteredPercentages[c] || 0;
                if (pct > maxPct) {
                    maxPct = pct;
                    maxCircle = c;
                }
            });
            if (maxCircle !== null && maxPct >= 40) {
                const circleName = circleLabels[parseInt(maxCircle)];
                insights.push(`Your "${circleName}" circle dominated ${recentMonthName} messaging at ${maxPct.toFixed(0)}% of volume.`);
            }

            // 5. Trend over time (first half vs second half of data)
            if (filteredData.length >= 6) {
                const midpoint = Math.floor(filteredData.length / 2);
                const firstHalfTotal = filteredData.slice(0, midpoint).reduce((sum, m) => sum + m.filteredTotal, 0);
                const secondHalfTotal = filteredData.slice(midpoint).reduce((sum, m) => sum + m.filteredTotal, 0);
                const firstHalfAvg = firstHalfTotal / midpoint;
                const secondHalfAvg = secondHalfTotal / (filteredData.length - midpoint);
                const trendChange = firstHalfAvg > 0 ? ((secondHalfAvg - firstHalfAvg) / firstHalfAvg * 100) : 0;

                if (Math.abs(trendChange) >= 20) {
                    const trend = trendChange > 0 ? 'upward' : 'downward';
                    insights.push(`Your messaging shows an ${trend} trend over the past year (${Math.abs(trendChange).toFixed(0)}% change).`);
                }
            }

            // 6. Circle shift insight (compare recent circle distribution to average)
            const circleShifts = [];
            selectedCircles.forEach(c => {
                const recentPct = recent.filteredPercentages[c] || 0;
                const avgPct = parseFloat(avgPercentages[c] || 0);
                const shift = recentPct - avgPct;
                if (Math.abs(shift) >= 10) {
                    circleShifts.push({ circle: c, shift, recentPct, avgPct });
                }
            });
            if (circleShifts.length > 0) {
                const biggest = circleShifts.sort((a, b) => Math.abs(b.shift) - Math.abs(a.shift))[0];
                const circleName = circleLabels[parseInt(biggest.circle)];
                const direction = biggest.shift > 0 ? 'up' : 'down';
                insights.push(`"${circleName}" circle is ${direction} ${Math.abs(biggest.shift).toFixed(0)} percentage points from your average in ${recentMonthName}.`);
            }

            // Return top insight (prioritize variety)
            return insights;
        }

        /**
         * Calculate dynamic heatmap thresholds based on actual interaction data.
         * Uses percentile-based approach so each person's heatmap shows meaningful variation.
         *
         * @param {Object} data - heatmapData object with date keys and {total, sources} values
         * @returns {number[]} - Array of 5 thresholds for levels 1-5
         */
        function calculateHeatmapThresholds(data) {
            // Collect all non-zero daily counts
            const counts = Object.values(data)
                .map(d => d.total)
                .filter(c => c > 0)
                .sort((a, b) => a - b);

            if (counts.length === 0) {
                // No interactions - return minimal thresholds
                return [1, 2, 3, 4, 5];
            }

            // Calculate percentiles for thresholds
            // Level 1: any interaction (>0)
            // Level 2: 25th percentile
            // Level 3: 50th percentile (median)
            // Level 4: 75th percentile
            // Level 5: 90th percentile and above
            const getPercentile = (arr, p) => {
                const index = Math.ceil((p / 100) * arr.length) - 1;
                return arr[Math.max(0, index)];
            };

            const p25 = getPercentile(counts, 25);
            const p50 = getPercentile(counts, 50);
            const p75 = getPercentile(counts, 75);
            const p90 = getPercentile(counts, 90);

            // Ensure thresholds are strictly increasing (at least +1 each level)
            const t1 = 1;  // Level 1: any interaction
            const t2 = Math.max(t1 + 1, p25);
            const t3 = Math.max(t2 + 1, p50);
            const t4 = Math.max(t3 + 1, p75);
            const t5 = Math.max(t4 + 1, p90);

            return [t1, t2, t3, t4, t5];
        }

        // Render heat map in GitHub contribution graph style
        function renderHeatMap() {
            const grid = document.getElementById('heatmapGrid');
            const monthsContainer = document.getElementById('heatmapMonths');
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Multi-year mode: 2-5 years uses 14 days/column, 6-8 years uses 28, 9-10 uses 35
            const isMultiYear = heatmapYears >= 2;
            const daysPerColumn = heatmapYears >= 9 ? 35 : (heatmapYears >= 6 ? 28 : (isMultiYear ? 14 : 7));

            // Calculate start date based on years
            const daysBack = heatmapYears * 365;
            const endDate = new Date(today);
            const startDate = new Date(today);
            startDate.setDate(startDate.getDate() - daysBack);

            // Adjust to start on appropriate day (Sunday for 7-day, or align for 14-day)
            if (!isMultiYear) {
                const startDayOfWeek = startDate.getDay();
                startDate.setDate(startDate.getDate() - startDayOfWeek);
            } else {
                // For 14-day columns, align to even weeks
                const startDayOfWeek = startDate.getDay();
                startDate.setDate(startDate.getDate() - startDayOfWeek);
            }

            // Calculate dynamic thresholds based on this person's interaction distribution
            // This ensures meaningful color variation regardless of interaction volume
            const thresholds = calculateHeatmapThresholds(heatmapData);

            // Generate columns
            let columnsHtml = '';
            let currentDate = new Date(startDate);
            let timeLabels = [];
            let columnIndex = 0;
            let lastLabelValue = -1;

            while (currentDate <= endDate) {
                columnsHtml += '<div class="heatmap-week">';

                for (let day = 0; day < daysPerColumn; day++) {
                    const dateKey = currentDate.toISOString().split('T')[0];
                    const dayData = heatmapData[dateKey] || { total: 0, sources: {} };
                    const count = dayData.total;

                    // Calculate level (0-5) using dynamic thresholds based on this person's data
                    // Level 0: no interaction, Level 5: above 90th percentile
                    let level = 0;
                    if (count > 0) level = 1;
                    if (count >= thresholds[1]) level = 2;
                    if (count >= thresholds[2]) level = 3;
                    if (count >= thresholds[3]) level = 4;
                    if (count >= thresholds[4]) level = 5;

                    // Track time label changes at the START of each column
                    if (day === 0 && currentDate >= startDate && currentDate <= endDate) {
                        if (isMultiYear) {
                            // Year labels for multi-year view
                            const currentYear = currentDate.getFullYear();
                            if (currentYear !== lastLabelValue) {
                                timeLabels.push({ columnIndex, label: currentYear.toString() });
                                lastLabelValue = currentYear;
                            }
                        } else {
                            // Month labels for single-year view
                            const currentMonth = currentDate.getMonth();
                            if (currentMonth !== lastLabelValue) {
                                const monthName = currentDate.toLocaleDateString('en-US', { month: 'short' });
                                timeLabels.push({ columnIndex, label: monthName });
                                lastLabelValue = currentMonth;
                            }
                        }
                    }

                    // Only render if within valid date range
                    if (currentDate > endDate || currentDate < startDate) {
                        columnsHtml += '<div class="heatmap-day" style="visibility:hidden"></div>';
                    } else {
                        columnsHtml += `<div class="heatmap-day" data-level="${level}" data-date="${dateKey}"></div>`;
                    }

                    currentDate.setDate(currentDate.getDate() + 1);
                }

                columnsHtml += '</div>';
                columnIndex++;
            }

            grid.innerHTML = columnsHtml;

            // Generate time labels with precise positioning
            const totalColumns = columnIndex;
            let labelsHtml = '';

            for (let i = 0; i < timeLabels.length; i++) {
                const label = timeLabels[i];
                const nextLabel = timeLabels[i + 1];

                // Calculate flex-grow based on columns this label spans
                const nextColumnIndex = nextLabel ? nextLabel.columnIndex : totalColumns;
                const columnsSpan = nextColumnIndex - label.columnIndex;

                labelsHtml += `<div class="heatmap-month-label" style="flex: ${columnsSpan};">${label.label}</div>`;
            }
            monthsContainer.innerHTML = labelsHtml;

            // Setup tooltip and click handlers
            setupHeatmapInteractions();

            // Render volume chart with same time period
            renderVolumeChart();
        }

        // Store volume chart data for hover interactions
        let volumeChartPoints = [];
        let volumeChartConfig = null;

        /**
         * Render a smoothed line chart showing interaction volume over time.
         * Uses the same time period as the heatmap (heatmapYears).
         */
        function renderVolumeChart(highlightIndex = -1) {
            const canvas = document.getElementById('volumeChartCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;

            // Set canvas size with device pixel ratio for sharpness
            const rect = canvas.getBoundingClientRect();

            // Skip if canvas not visible (zero dimensions)
            if (rect.width === 0 || rect.height === 0) {
                // Retry after layout completes
                requestAnimationFrame(() => renderVolumeChart(highlightIndex));
                return;
            }

            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            const width = rect.width;
            const height = rect.height;
            // Minimal padding - balanced for Y-axis labels on left, minimal on right
            const padding = { top: 15, right: 10, bottom: 20, left: 30 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            // Store config for hover detection
            volumeChartConfig = { width, height, padding, chartWidth, chartHeight };

            // Clear canvas completely
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.scale(dpr, dpr);

            // Aggregate data by week or month depending on time range
            const daysBack = heatmapYears * 365;
            const useMonthly = heatmapYears >= 3;
            const aggregated = aggregateVolumeData(heatmapData, daysBack, useMonthly);

            if (aggregated.length === 0) {
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px system-ui, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No interaction data', width / 2, height / 2);
                volumeChartPoints = [];
                return;
            }

            // Find max value for scaling
            const maxValue = Math.max(...aggregated.map(d => d.value), 1);

            // Calculate points and store globally for hover
            volumeChartPoints = aggregated.map((d, i) => ({
                x: padding.left + (i / (aggregated.length - 1 || 1)) * chartWidth,
                y: padding.top + chartHeight - (d.value / maxValue) * chartHeight,
                value: d.value,
                label: d.label,
                fullLabel: d.fullLabel || d.label
            }));

            // Draw grid lines
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--border').trim() || '#333';
            ctx.lineWidth = 0.5;
            const gridLines = 4;
            for (let i = 0; i <= gridLines; i++) {
                const y = padding.top + (i / gridLines) * chartHeight;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();
            }

            // Draw Y-axis labels (white text)
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px system-ui, sans-serif';
            ctx.textAlign = 'right';
            for (let i = 0; i <= gridLines; i++) {
                const value = Math.round(maxValue * (1 - i / gridLines));
                const y = padding.top + (i / gridLines) * chartHeight;
                ctx.fillText(value.toString(), padding.left - 5, y + 3);
            }

            // Draw smoothed line using cardinal spline
            if (volumeChartPoints.length > 1) {
                ctx.beginPath();
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--people').trim() || '#00bcd4';
                ctx.lineWidth = 2;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';

                // Draw smooth curve through points
                drawSmoothLine(ctx, volumeChartPoints);
                ctx.stroke();

                // Fill area under curve
                ctx.lineTo(volumeChartPoints[volumeChartPoints.length - 1].x, padding.top + chartHeight);
                ctx.lineTo(volumeChartPoints[0].x, padding.top + chartHeight);
                ctx.closePath();
                ctx.fillStyle = 'rgba(0, 188, 212, 0.15)';
                ctx.fill();
            }

            // Draw X-axis labels (show a few evenly spaced, white text)
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px system-ui, sans-serif';
            ctx.textAlign = 'center';
            const labelCount = Math.min(6, aggregated.length);
            const step = Math.floor(aggregated.length / labelCount) || 1;
            for (let i = 0; i < aggregated.length; i += step) {
                const x = padding.left + (i / (aggregated.length - 1 || 1)) * chartWidth;
                ctx.fillText(aggregated[i].label, x, height - 5);
            }

            // Draw highlight circle if hovering
            if (highlightIndex >= 0 && highlightIndex < volumeChartPoints.length) {
                const point = volumeChartPoints[highlightIndex];
                ctx.beginPath();
                ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--people').trim() || '#00bcd4';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Setup hover interactions (only once)
            if (!canvas.dataset.hoverSetup) {
                setupVolumeChartHover(canvas);
                canvas.dataset.hoverSetup = 'true';
            }
        }

        /**
         * Setup hover interactions for the volume chart.
         */
        function setupVolumeChartHover(canvas) {
            const tooltip = document.getElementById('heatmapTooltip');

            canvas.addEventListener('mousemove', (e) => {
                if (!volumeChartPoints.length || !volumeChartConfig) return;

                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Find nearest point
                let nearestIndex = -1;
                let nearestDist = Infinity;

                volumeChartPoints.forEach((point, i) => {
                    const dist = Math.abs(point.x - x);
                    if (dist < nearestDist && dist < 30) {
                        nearestDist = dist;
                        nearestIndex = i;
                    }
                });

                if (nearestIndex >= 0) {
                    const point = volumeChartPoints[nearestIndex];
                    canvas.style.cursor = 'pointer';

                    // Re-render with highlight
                    renderVolumeChart(nearestIndex);

                    // Show tooltip
                    const useMonthly = heatmapYears >= 3;
                    const periodLabel = useMonthly ? 'Month' : 'Week';
                    tooltip.innerHTML = `
                        <div class="heatmap-tooltip-date">${point.fullLabel}</div>
                        <div class="heatmap-tooltip-item">${point.value} interaction${point.value !== 1 ? 's' : ''}</div>
                        <div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 4px;">${periodLabel} total</div>
                    `;
                    tooltip.classList.add('visible');

                    // Position tooltip near cursor
                    const tooltipRect = tooltip.getBoundingClientRect();
                    let tooltipX = e.clientX + 15;
                    let tooltipY = e.clientY - 10;

                    // Keep tooltip in viewport
                    if (tooltipX + tooltipRect.width > window.innerWidth) {
                        tooltipX = e.clientX - tooltipRect.width - 15;
                    }
                    if (tooltipY + tooltipRect.height > window.innerHeight) {
                        tooltipY = e.clientY - tooltipRect.height - 10;
                    }

                    tooltip.style.left = tooltipX + 'px';
                    tooltip.style.top = tooltipY + 'px';
                } else {
                    canvas.style.cursor = 'default';
                    tooltip.classList.remove('visible');
                    // Re-render without highlight
                    renderVolumeChart(-1);
                }
            });

            canvas.addEventListener('mouseleave', () => {
                tooltip.classList.remove('visible');
                canvas.style.cursor = 'default';
                renderVolumeChart(-1);
            });
        }

        /**
         * Aggregate heatmap data into weekly or monthly buckets for the volume chart.
         * Creates buckets for the ENTIRE date range, including periods with no data.
         */
        function aggregateVolumeData(data, daysBack, useMonthly) {
            const buckets = {};
            const now = new Date();
            now.setHours(12, 0, 0, 0);
            const startDate = new Date(now);
            startDate.setDate(startDate.getDate() - daysBack);

            // First, create all buckets for the entire date range (including empty ones)
            if (useMonthly) {
                // Create monthly buckets from startDate to now
                const current = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
                const endMonth = new Date(now.getFullYear(), now.getMonth(), 1);
                while (current <= endMonth) {
                    const bucketKey = `${current.getFullYear()}-${String(current.getMonth() + 1).padStart(2, '0')}`;
                    buckets[bucketKey] = { value: 0, date: new Date(current) };
                    current.setMonth(current.getMonth() + 1);
                }
            } else {
                // Create weekly buckets from startDate to now
                const current = new Date(startDate);
                current.setDate(current.getDate() - current.getDay()); // Start of week (Sunday)
                while (current <= now) {
                    const bucketKey = current.toISOString().slice(0, 10);
                    buckets[bucketKey] = { value: 0, date: new Date(current) };
                    current.setDate(current.getDate() + 7);
                }
            }

            // Now populate buckets with actual data
            for (const [dateKey, dayData] of Object.entries(data)) {
                const date = new Date(dateKey + 'T12:00:00');
                if (date < startDate) continue;

                let bucketKey;
                if (useMonthly) {
                    bucketKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                } else {
                    // Weekly: use ISO week start (Sunday)
                    const weekStart = new Date(date);
                    weekStart.setDate(date.getDate() - date.getDay());
                    bucketKey = weekStart.toISOString().slice(0, 10);
                }

                if (buckets[bucketKey]) {
                    buckets[bucketKey].value += dayData.total || 0;
                }
            }

            // Sort by date and format labels as MM/YY
            const sorted = Object.entries(buckets)
                .sort(([a], [b]) => a.localeCompare(b))
                .map(([key, bucketData]) => {
                    let label, fullLabel;
                    if (useMonthly) {
                        const [year, month] = key.split('-');
                        const date = new Date(year, parseInt(month) - 1, 1);
                        label = `${month}/${year.slice(-2)}`;
                        fullLabel = date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                    } else {
                        const date = new Date(key + 'T12:00:00');
                        const mm = String(date.getMonth() + 1).padStart(2, '0');
                        const yy = String(date.getFullYear()).slice(-2);
                        label = `${mm}/${yy}`;
                        fullLabel = `Week of ${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}`;
                    }
                    return { label, fullLabel, value: bucketData.value };
                });

            return sorted;
        }

        /**
         * Draw a smooth curve through points using cardinal spline interpolation.
         */
        function drawSmoothLine(ctx, points) {
            if (points.length < 2) return;

            const tension = 0.3;

            ctx.moveTo(points[0].x, points[0].y);

            for (let i = 0; i < points.length - 1; i++) {
                const p0 = points[i - 1] || points[0];
                const p1 = points[i];
                const p2 = points[i + 1];
                const p3 = points[i + 2] || p2;

                const cp1x = p1.x + (p2.x - p0.x) * tension;
                const cp1y = p1.y + (p2.y - p0.y) * tension;
                const cp2x = p2.x - (p3.x - p1.x) * tension;
                const cp2y = p2.y - (p3.y - p1.y) * tension;

                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
            }
        }

        // Setup tooltip and click interactions for heatmap
        function setupHeatmapInteractions() {
            const tooltip = document.getElementById('heatmapTooltip');
            const days = document.querySelectorAll('.heatmap-day[data-date]');

            days.forEach(day => {
                day.addEventListener('mouseenter', (e) => {
                    const dateKey = day.dataset.date;
                    const dayData = heatmapData[dateKey] || { total: 0, sources: {} };

                    // Format date nicely
                    const dateObj = new Date(dateKey + 'T12:00:00');
                    const dateStr = dateObj.toLocaleDateString('en-US', {
                        weekday: 'short',
                        month: 'short',
                        day: 'numeric',
                        year: 'numeric'
                    });

                    // Build tooltip content
                    let html = `<div class="heatmap-tooltip-date">${dateStr}</div>`;

                    if (dayData.total === 0) {
                        html += '<div class="heatmap-tooltip-item">No interactions</div>';
                    } else {
                        // Sort sources by count descending
                        const sortedSources = Object.entries(dayData.sources)
                            .sort((a, b) => b[1] - a[1]);

                        sortedSources.forEach(([sourceType, count]) => {
                            const sourceInfo = SOURCE_BADGES[sourceType] || { badge: String.fromCodePoint(0x1F4C4), label: sourceType };
                            html += `<div class="heatmap-tooltip-item">${sourceInfo.badge} ${count} ${sourceInfo.label}</div>`;
                        });

                        html += `<div class="heatmap-tooltip-total">Total: ${dayData.total} interaction${dayData.total !== 1 ? 's' : ''}</div>`;
                    }

                    tooltip.innerHTML = html;

                    // Position tooltip
                    const rect = day.getBoundingClientRect();
                    tooltip.style.left = `${rect.left + rect.width / 2}px`;
                    tooltip.style.top = `${rect.top - 8}px`;
                    tooltip.style.transform = 'translate(-50%, -100%)';
                    tooltip.classList.add('visible');
                });

                day.addEventListener('mouseleave', () => {
                    tooltip.classList.remove('visible');
                });

                day.addEventListener('click', () => {
                    const dateKey = day.dataset.date;
                    navigateToTimelineDate(dateKey);
                });
            });
        }

        /**
         * Navigate to timeline tab filtered to a specific date (from heatmap click).
         *
         * This uses the standard date range filter UI by setting both From and To
         * to the same date, providing a unified filtering experience. The user sees
         * the date populated in the filter inputs and can modify or clear it.
         *
         * @param {string} dateKey - Date in YYYY-MM-DD format
         */
        async function navigateToTimelineDate(dateKey) {
            // Set both date range inputs to the clicked date (same from/to = single day)
            // This unifies the filtering experience - heatmap clicks and manual date
            // selection use the same mechanism
            const fromInput = document.getElementById('timelineDateFrom');
            const toInput = document.getElementById('timelineDateTo');
            const clearBtn = document.getElementById('clearDateRangeBtn');

            fromInput.value = dateKey;
            toInput.value = dateKey;
            clearBtn.style.display = '';

            // Update the date range state variables to match
            timelineDateRangeFrom = new Date(dateKey + 'T00:00:00');
            timelineDateRangeTo = new Date(dateKey + 'T23:59:59');

            // Reset source filter to 'all' so we see all interactions for this date
            timelineFilter = 'all';
            document.querySelectorAll('.timeline-filter-chip').forEach(c => c.classList.remove('active'));
            document.querySelector('[data-source="all"]')?.classList.add('active');

            // Switch to timeline tab - loadTimeline will use the date range for filtering
            await switchTab('timeline');
        }

        /**
         * Map UI filter names to API source_type values.
         *
         * The UI uses friendly names like "messages" and "notes" which map to
         * multiple underlying source types. The API accepts comma-separated values.
         *
         * @param {string} filter - UI filter name (e.g., 'gmail', 'messages', 'notes')
         * @returns {string|null} - API source_type value(s) or null for 'all'
         */
        function mapFilterToSourceType(filter) {
            if (filter === 'all') return null;

            // Compound filters that map to multiple source types
            const compoundFilters = {
                'messages': 'imessage,whatsapp',  // Both messaging platforms
                'notes': 'vault,granola',          // Both note types
            };

            return compoundFilters[filter] || filter;
        }

        /**
         * Load timeline data from the API.
         *
         * IMPORTANT: Filtering is now done server-side via the source_type and date parameters.
         * This ensures we get the correct filtered data regardless of how many total
         * interactions exist. Previously, filtering was client-side on a limited 100-item
         * fetch, which meant filters would show nothing if no matching items were in
         * the initial fetch.
         *
         * Date filtering uses the same date range inputs whether the user clicks on
         * a heatmap date or manually enters dates. This provides a unified experience.
         *
         * @param {string} personId - The person ID to load timeline for
         */
        // Maximum number of timeline items to load (prevents UI freezing for high-volume contacts)
        const TIMELINE_LIMIT = 500;

        async function loadTimeline(personId) {
            const container = document.getElementById('timelineContainer');

            // Check date filter
            const fromInput = document.getElementById('timelineDateFrom');
            const toInput = document.getElementById('timelineDateTo');
            const fromDate = fromInput?.value;
            const toDate = toInput?.value;
            const dateKey = (fromDate && toDate && fromDate === toDate) ? fromDate : null;

            // Get current filter state
            const sourceType = mapFilterToSourceType(timelineFilter);

            // When filtering by source type, fetch that type directly from API
            // This ensures we get ALL items of that type, not just what's in the 500-item cache
            // (e.g., photos would be drowned out by thousands of messages in the cache)
            if (sourceType !== null) {
                container.innerHTML = '<div class="loading">Loading timeline...</div>';
                try {
                    const params = new URLSearchParams();
                    if (dateKey) params.set('date', dateKey);
                    params.set('limit', TIMELINE_LIMIT.toString());
                    params.set('source_type', sourceType);

                    const isMePage = isMyPage(personId);
                    const baseUrl = isMePage ? '/me/timeline' : `/people/${personId}/timeline`;
                    const data = await api(`${baseUrl}?${params.toString()}`);

                    timelineData = data.items || [];
                    updateTimelineCount(data.count || timelineData.length, data.has_more || false);
                    renderTimeline();
                    return;
                } catch (error) {
                    console.error('Failed to load filtered timeline:', error);
                    container.innerHTML = '<div class="loading">Error loading timeline</div>';
                    return;
                }
            }

            // No source filter - try cache for "All" view
            const cached = getCachedTimeline(personId, dateKey);
            if (cached) {
                timelineData = cached.items || [];
                updateTimelineCount(cached.count || timelineData.length, cached.has_more || false);
                updateTimelineFilterVisibility();
                renderTimeline();
                return;
            }

            // Cache miss - fetch from API
            container.innerHTML = '<div class="loading">Loading timeline...</div>';

            try {
                // Build API URL with query parameters
                const params = new URLSearchParams();

                if (dateKey) {
                    // Single day filter - use API's date parameter for server-side filtering
                    params.set('date', dateKey);
                }

                // Always use consistent limit to prevent loading failures for high-volume contacts
                params.set('limit', TIMELINE_LIMIT.toString());

                // Use different endpoint for /me page vs regular person page
                const isMePage = isMyPage(personId);
                const baseUrl = isMePage ? '/me/timeline' : `/people/${personId}/timeline`;
                const url = `${baseUrl}?${params.toString()}`;

                const data = await api(url);

                // Cache the full (unfiltered) result
                setCachedTimeline(personId, dateKey, data);

                timelineData = data.items || [];
                updateTimelineCount(data.count || timelineData.length, data.has_more || false);
                updateTimelineFilterVisibility()

                renderTimeline();
            } catch (error) {
                console.error('Failed to load timeline:', error);
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">âš ï¸</div><p>Failed to load timeline</p></div>';
                updateTimelineCount(0, false);
            }
        }

        /**
         * Update the timeline count display.
         * Shows the number of interactions matching current filters.
         * @param {number} count - Number of interactions
         * @param {boolean} hasMore - Whether there are more results beyond the limit
         */
        function updateTimelineCount(count, hasMore) {
            const countEl = document.getElementById('timelineCount');
            if (!countEl) return;

            countEl.textContent = formatCompactNumber(count);
            countEl.classList.toggle('has-more', hasMore);
            countEl.title = hasMore
                ? `Showing ${count} most recent interactions (more available)`
                : `${count} interactions matching current filters`;
        }

        // Timeline date range state (synced with the From/To input fields)
        let timelineDateRangeFrom = null;
        let timelineDateRangeTo = null;

        /**
         * Group consecutive photos by date for collapsed display.
         * Non-photo items pass through unchanged.
         */
        function groupPhotosInTimeline(items) {
            const result = [];
            let photoGroup = null;

            for (const item of items) {
                if (item.source_type === 'photos') {
                    const date = item.timestamp.split('T')[0];
                    if (photoGroup && photoGroup.date === date) {
                        photoGroup.items.push(item);
                    } else {
                        if (photoGroup) result.push(photoGroup);
                        photoGroup = { type: 'photo_group', date, items: [item] };
                    }
                } else {
                    if (photoGroup) {
                        result.push(photoGroup);
                        photoGroup = null;
                    }
                    result.push(item);
                }
            }
            if (photoGroup) result.push(photoGroup);
            return result;
        }

        /**
         * Render a photo group (collapsed by default).
         */
        function renderPhotoGroup(group) {
            const count = group.items.length;
            const id = `photo-group-${group.date}`;
            return `
                <div class="timeline-item timeline-photo-group" id="${id}">
                    <div class="timeline-badge">ðŸ“·</div>
                    <div class="timeline-content">
                        <div class="timeline-title photo-group-header" onclick="togglePhotoGroup('${id}', '${group.date}')">
                            ${count} photo${count > 1 ? 's' : ''}
                            <span class="photo-group-toggle">â–¸</span>
                        </div>
                        <div class="timeline-meta">${formatDate(group.items[0].timestamp)}</div>
                        <div class="photo-group-details" style="display: none;"></div>
                    </div>
                </div>
            `;
        }

        /**
         * Open a photo in the Photos app.
         * Uses the API endpoint which runs AppleScript to open Photos.
         */
        async function openPhotoInApp(uuid) {
            try {
                await fetch(`/api/photos/open/${uuid}`);
            } catch (err) {
                console.error('Failed to open photo:', err);
            }
        }

        /**
         * Handle photo thumbnail loading error.
         * Checks if photo is in iCloud (410) vs truly not found (404).
         */
        async function handlePhotoError(img, uuid) {
            try {
                // Re-fetch to check actual status (the img onerror doesn't give us status code)
                const response = await fetch(`/api/photos/thumbnail/${uuid}`);
                if (response.status === 410) {
                    // iCloud only - show cloud icon with click to download
                    img.outerHTML = `<div class="photo-thumbnail-placeholder icloud-photo" onclick="openPhotoInApp('${uuid}')" title="Photo in iCloud - Click to open in Photos">â˜ï¸</div>`;
                } else {
                    // Regular 404 - show camera placeholder
                    img.outerHTML = '<div class="photo-thumbnail-placeholder">ðŸ“·</div>';
                }
            } catch (err) {
                // Network error - show camera placeholder
                img.outerHTML = '<div class="photo-thumbnail-placeholder">ðŸ“·</div>';
            }
        }

        /**
         * Toggle expand/collapse of a photo group.
         * Loads photo details from API on first expand.
         */
        async function togglePhotoGroup(groupId, date) {
            const group = document.getElementById(groupId);
            if (!group) return;

            const details = group.querySelector('.photo-group-details');
            const toggle = group.querySelector('.photo-group-toggle');

            if (details.style.display === 'none') {
                // Expand - load photo details if not already loaded
                if (!details.dataset.loaded) {
                    details.innerHTML = '<div class="photo-card">Loading...</div>';
                    try {
                        // Use fetch directly since photos API is at /api/photos, not /api/crm
                        const response = await fetch(`/api/photos/person/${selectedPersonId}?date=${date}`);
                        if (!response.ok) throw new Error(`API error: ${response.status}`);
                        const data = await response.json();
                        details.innerHTML = data.photos.map(p => `
                            <div class="photo-card">
                                <img class="photo-thumbnail"
                                     src="/api/photos/thumbnail/${p.uuid}"
                                     onerror="handlePhotoError(this, '${p.uuid}')"
                                     loading="lazy"
                                     alt="Photo"
                                     onclick="openPhotoInApp('${p.uuid}')">
                                <div class="photo-info">
                                    <span class="photo-time">${formatTime(p.timestamp)}</span>
                                    <a href="#" class="photo-open-btn" onclick="event.preventDefault(); openPhotoInApp('${p.uuid}');">Open in Photos</a>
                                </div>
                            </div>
                        `).join('') || '<div class="photo-card">No photos found</div>';
                        details.dataset.loaded = 'true';
                    } catch (err) {
                        console.error('Failed to load photos:', err);
                        details.innerHTML = '<div class="photo-card">Failed to load photos</div>';
                    }
                }
                details.style.display = 'block';
                toggle.textContent = 'â–¾';
            } else {
                // Collapse
                details.style.display = 'none';
                toggle.textContent = 'â–¸';
            }
        }

        /**
         * Format time from ISO timestamp (e.g., "2:30 PM").
         */
        function formatTime(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp);
            return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
        }

        /**
         * Render the timeline items to the DOM.
         *
         * NOTE: Source type filtering is handled by the API in loadTimeline().
         * Date filtering for single days is also handled by the API.
         * This function applies client-side date range filtering only when
         * from != to (for filtering within the fetched data).
         */
        function renderTimeline() {
            const container = document.getElementById('timelineContainer');

            // Start with all items from the API (already filtered by source_type server-side)
            let items = timelineData;

            // Apply date range filter if set (this is a client-side refinement)
            // The date range picker allows narrowing down within the fetched data
            // Use string comparison on YYYY-MM-DD to avoid timezone conversion issues
            const fromDateStr = document.getElementById('timelineDateFrom')?.value || null;
            const toDateStr = document.getElementById('timelineDateTo')?.value || null;
            if (fromDateStr || toDateStr) {
                items = items.filter(item => {
                    // Extract YYYY-MM-DD from ISO timestamp (e.g., "2020-11-10T00:00:00+00:00" -> "2020-11-10")
                    // This matches how the aggregated timeline groups dates, ensuring consistency
                    const itemDateStr = item.timestamp.split('T')[0];
                    if (fromDateStr && itemDateStr < fromDateStr) return false;
                    if (toDateStr && itemDateStr > toDateStr) return false;
                    return true;
                });
            }

            if (items.length === 0) {
                // Show appropriate message based on whether filters are active
                const hasFilters = timelineFilter !== 'all' || timelineDateRangeFrom || timelineDateRangeTo;
                const message = hasFilters
                    ? 'No interactions match the current filters'
                    : 'No interactions found';
                container.innerHTML = `<div class="empty-state"><div class="empty-state-icon">ðŸ“…</div><p>${message}</p></div>`;
                return;
            }

            // Group photos by date for collapsed display
            const groupedItems = groupPhotosInTimeline(items);

            container.innerHTML = groupedItems.map(item => {
                // Photo groups render differently
                if (item.type === 'photo_group') {
                    return renderPhotoGroup(item);
                }

                // Regular timeline items
                const title = item.title || '';
                const snippet = item.snippet || '';
                const isDuplicate = snippet && (
                    snippet === title ||
                    snippet.trim() === title.trim() ||
                    title.includes(snippet) ||
                    snippet.includes(title)
                );

                return `
                <div class="timeline-item">
                    <div class="timeline-badge">${item.source_badge || 'ðŸ“„'}</div>
                    <div class="timeline-content">
                        <div class="timeline-title">
                            ${item.source_link ? `<a href="${item.source_link}" target="_blank">${escapeHtml(title)}</a>` : escapeHtml(title)}
                        </div>
                        ${snippet && !isDuplicate ? `<div class="timeline-snippet">${escapeHtml(snippet)}</div>` : ''}
                        <div class="timeline-meta">
                            ${formatDate(item.timestamp)}
                            <span class="timeline-source-badge">${escapeHtml(item.source_type || 'Unknown')}</span>
                        </div>
                    </div>
                </div>
            `}).join('');
        }

        /**
         * Navigate to timeline tab with a specific filter pre-applied.
         * Used when clicking on stat cards (e.g., "Emails: 500" links to filtered timeline).
         *
         * @param {string} source - Filter to apply (e.g., 'gmail', 'messages')
         */
        async function navigateToTimelineFiltered(source) {
            // Set the filter before switching tabs
            timelineFilter = source;

            // Switch to timeline tab - this calls loadTimeline which uses timelineFilter
            await switchTab('timeline');

            // Update the filter chip UI to reflect the selection
            document.querySelectorAll('.timeline-filter-chip').forEach(c => c.classList.remove('active'));
            const chip = document.querySelector(`[data-source="${source}"]`);
            if (chip) chip.classList.add('active');

            // Note: No need to call renderTimeline() here - switchTab already calls loadTimeline
        }

        /**
         * Filter timeline by source type.
         * Called when user clicks a filter chip (Emails, Events, Messages, etc.)
         *
         * IMPORTANT: This now re-fetches from the API with the filter applied server-side.
         * Previously it only filtered the client-side data, which didn't work when the
         * desired items weren't in the initial limited fetch.
         *
         * @param {string} source - Filter to apply (e.g., 'gmail', 'calendar', 'messages')
         */
        async function filterTimeline(source) {
            timelineFilter = source;

            // Update UI to show active filter
            document.querySelectorAll('.timeline-filter-chip').forEach(c => c.classList.remove('active'));
            document.querySelector(`[data-source="${source}"]`).classList.add('active');

            // Re-fetch from API with the new filter applied server-side
            const { isFamily } = parseUrl();
            if (isFamily) {
                await loadFamilyTimeline();
            } else if (selectedPersonId) {
                await loadTimeline(selectedPersonId);
            }
        }

        /**
         * Apply date range filter when user changes the From/To date inputs.
         *
         * Always reloads timeline data when a date filter is set, to ensure
         * we have the correct data and can update filter chip visibility.
         *
         * Resets the source type filter to 'all' when date changes, so we can
         * accurately determine which source types have data for the new date range.
         */
        async function applyTimelineDateRange() {
            const fromInput = document.getElementById('timelineDateFrom');
            const toInput = document.getElementById('timelineDateTo');
            const clearBtn = document.getElementById('clearDateRangeBtn');

            const fromValue = fromInput.value;
            const toValue = toInput.value;

            timelineDateRangeFrom = fromValue ? new Date(fromValue + 'T00:00:00') : null;
            timelineDateRangeTo = toValue ? new Date(toValue + 'T23:59:59') : null;

            // Show/hide clear button
            if (timelineDateRangeFrom || timelineDateRangeTo) {
                clearBtn.style.display = '';
            } else {
                clearBtn.style.display = 'none';
            }

            // Reset source type filter to 'all' when date changes
            // This ensures we can see all available source types for the new date range
            // and correctly update filter chip visibility
            timelineFilter = 'all';
            document.querySelectorAll('.timeline-filter-chip').forEach(c => c.classList.remove('active'));
            document.querySelector('[data-source="all"]')?.classList.add('active');

            // Reload from API with the new date filter
            const { isFamily } = parseUrl();
            if (isFamily) {
                await loadFamilyTimeline();
            } else if (selectedPersonId) {
                await loadTimeline(selectedPersonId);
            }
        }

        /**
         * Clear date range filter and reload timeline data.
         *
         * Since the current data may be filtered to a specific date, we need
         * to reload from the API to get the full unfiltered dataset.
         * Also resets source filter to 'all' and restores filter visibility
         * based on global totals (not date-filtered counts).
         */
        async function clearTimelineDateRange() {
            document.getElementById('timelineDateFrom').value = '';
            document.getElementById('timelineDateTo').value = '';
            document.getElementById('clearDateRangeBtn').style.display = 'none';
            timelineDateRangeFrom = null;
            timelineDateRangeTo = null;

            // Reset source type filter to 'all'
            timelineFilter = 'all';
            document.querySelectorAll('.timeline-filter-chip').forEach(c => c.classList.remove('active'));
            document.querySelector('[data-source="all"]')?.classList.add('active');

            // Reload from API to get unfiltered data
            const { isFamily } = parseUrl();
            if (isFamily) {
                await loadFamilyTimeline();
            } else if (selectedPersonId) {
                await loadTimeline(selectedPersonId);
            }

            // Restore filter visibility based on global totals (since no date filter is active)
            updateTimelineFilterVisibility();
        }

        // Quick Facts state
        let factsData = [];
        let autoExtractInProgress = false; // Prevent multiple auto-extracts

        // Load facts for a person
        async function loadFacts(personId) {
            const container = document.getElementById('factsContainer');

            try {
                const data = await api(`/people/${personId}/facts`);
                factsData = data.facts || [];
                const byCategory = data.by_category || {};
                renderFacts(byCategory);

                // Auto-trigger extraction if no facts exist (using fast/cheap Haiku)
                const hasAnyFacts = Object.values(byCategory).some(facts => facts && facts.length > 0);
                if (!hasAnyFacts && !autoExtractInProgress && selectedPersonId === personId) {
                    autoExtractInProgress = true;
                    console.log('No facts found, auto-triggering Haiku extraction...');
                    // Small delay to let the UI render first
                    setTimeout(() => {
                        extractFacts('haiku').finally(() => {
                            autoExtractInProgress = false;
                        });
                    }, 500);
                }
            } catch (error) {
                console.error('Failed to load facts:', error);
                container.innerHTML = '<div class="facts-empty">Failed to load facts.</div>';
            }
        }

        // Render facts grouped by category
        function renderFacts(byCategory) {
            const container = document.getElementById('factsContainer');

            // Include summary category at the end
            const categoryOrder = ['summary', 'family', 'work', 'background', 'interests', 'preferences', 'dates', 'topics', 'travel'];
            const categoryIcons = {
                'family': String.fromCodePoint(0x1F468, 0x200D, 0x1F469, 0x200D, 0x1F467),  // family emoji
                'preferences': String.fromCodePoint(0x2699, 0xFE0F),  // gear
                'background': String.fromCodePoint(0x1F3E0),  // house
                'interests': String.fromCodePoint(0x1F3AF),  // target
                'dates': String.fromCodePoint(0x1F4C5),  // calendar
                'work': String.fromCodePoint(0x1F4BC),  // briefcase
                'topics': String.fromCodePoint(0x1F4AC),  // speech bubble
                'travel': String.fromCodePoint(0x2708, 0xFE0F),  // airplane
                'summary': String.fromCodePoint(0x1F4CA),  // chart emoji
            };

            // Display names for categories
            const categoryNames = {
                'summary': 'Relationship Insights',
                'family': 'Family',
                'work': 'Work',
                'background': 'Background',
                'interests': 'Interests',
                'preferences': 'Preferences',
                'dates': 'Important Dates',
                'topics': 'Topics',
                'travel': 'Travel',
            };

            // Check if we have any facts
            const hasAnyFacts = Object.values(byCategory).some(facts => facts && facts.length > 0);

            if (!hasAnyFacts) {
                container.innerHTML = '<div class="facts-empty">No facts extracted yet. Click "Extract Facts" to analyze interactions.</div>';
                return;
            }

            let html = '';
            for (const category of categoryOrder) {
                const facts = byCategory[category];
                if (!facts || facts.length === 0) continue;

                const icon = categoryIcons[category] || '';
                const displayName = categoryNames[category] || (category.charAt(0).toUpperCase() + category.slice(1));

                html += `
                    <div class="facts-category ${category}">
                        <div class="facts-category-header">
                            <span class="facts-category-icon">${icon}</span>
                            <span>${displayName}</span>
                        </div>
                        <ul class="facts-list">
                            ${facts.map(fact => renderFactItem(fact)).join('')}
                        </ul>
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        // Render a single fact as a bullet point
        function renderFactItem(fact) {
            const unconfirmedClass = fact.confirmed_by_user ? '' : 'unconfirmed';
            const factSentence = formatFactAsSentence(fact.key, fact.value);
            const confidencePercent = Math.round(fact.confidence * 100);

            // Confidence level - High/Mid/Low
            const confLevel = fact.confidence >= 0.8 ? 'high' : (fact.confidence >= 0.5 ? 'medium' : 'low');
            const confLabel = fact.confidence >= 0.8 ? 'High' : (fact.confidence >= 0.5 ? 'Mid' : 'Low');

            // Source link (clickable to open Gmail/Calendar/Obsidian)
            const sourceLinkHtml = fact.source_link ?
                `<a href="${escapeHtml(fact.source_link)}" class="fact-source-link" target="_blank" onclick="event.stopPropagation();" title="View source">
                    <span class="fact-source-link-icon">${getSourceIcon(fact.source_link)}</span>
                    view source
                </a>` : '';

            // Confidence indicator - just text label
            const confidenceHtml = `<span class="fact-confidence ${confLevel}">(${confLabel})</span>`;

            // Source quote (shown on hover)
            const quoteHtml = fact.source_quote ?
                `<div class="fact-quote">${escapeHtml(fact.source_quote)}</div>` : '';

            const bulletClass = fact.confirmed_by_user ? 'confirmed' : 'unconfirmed';
            return `
                <li class="fact-item ${unconfirmedClass}">
                    <span class="fact-bullet ${bulletClass}">â€¢</span>
                    <span class="fact-content">
                        <span class="fact-text">${escapeHtml(factSentence)}</span>
                        ${sourceLinkHtml}
                        ${confidenceHtml}
                        ${quoteHtml}
                    </span>
                    <div class="fact-actions">
                        ${!fact.confirmed_by_user ? `<button class="fact-action-btn confirm" onclick="confirmFact('${fact.id}'); event.stopPropagation();" title="Confirm">âœ“</button>` : ''}
                        <button class="fact-action-btn delete" onclick="deleteFact('${fact.id}'); event.stopPropagation();" title="Delete">Ã—</button>
                    </div>
                </li>
            `;
        }

        // Get appropriate icon for source link type
        function getSourceIcon(sourceLink) {
            if (!sourceLink) return '';
            if (sourceLink.includes('mail.google.com')) return String.fromCodePoint(0x1F4E7);
            if (sourceLink.includes('calendar.google.com')) return String.fromCodePoint(0x1F4C5);
            if (sourceLink.startsWith('obsidian://')) return String.fromCodePoint(0x1F4DD);
            return String.fromCodePoint(0x1F517);
        }

        // Format a fact key/value pair as a natural sentence
        function formatFactAsSentence(key, value) {
            const keyLower = key.toLowerCase().replace(/_/g, ' ');

            // Common patterns for natural phrasing
            const patterns = {
                'spouse': `Spouse is ${value}`,
                'spouse name': `Spouse is ${value}`,
                'partner': `Partner is ${value}`,
                'kids': `Has kids: ${value}`,
                'children': `Has children: ${value}`,
                'birthday': `Birthday is ${value}`,
                'birth date': `Birthday is ${value}`,
                'company': `Works at ${value}`,
                'employer': `Works at ${value}`,
                'job title': `Works as ${value}`,
                'role': `Role is ${value}`,
                'title': `Title is ${value}`,
                'hometown': `From ${value}`,
                'location': `Located in ${value}`,
                'city': `Lives in ${value}`,
                'email': `Email is ${value}`,
                'phone': `Phone is ${value}`,
                'alma mater': `Studied at ${value}`,
                'school': `Studied at ${value}`,
                'university': `Attended ${value}`,
                'hobby': `Enjoys ${value}`,
                'hobbies': `Enjoys ${value}`,
                'interest': `Interested in ${value}`,
                'interests': `Interested in ${value}`,
                'favorite': `Favorite: ${value}`,
                'pet': `Has a pet: ${value}`,
                'pets': `Has pets: ${value}`,
                'anniversary': `Anniversary is ${value}`,
                // Summary category patterns
                'relationship trajectory': value,
                'key themes': `Key themes: ${value}`,
                'major events': `Major events: ${value}`,
                'communication style': `Communication style: ${value}`,
            };

            // Check for exact or partial matches
            for (const [pattern, template] of Object.entries(patterns)) {
                if (keyLower === pattern || keyLower.includes(pattern)) {
                    return template;
                }
            }

            // Default: capitalize key and use "is" connector
            const capitalizedKey = keyLower.charAt(0).toUpperCase() + keyLower.slice(1);
            return `${capitalizedKey} is ${value}`;
        }

        // Format source attribution text
        function formatSourceAttribution(fact) {
            if (!fact.source_interaction_id && !fact.extracted_at) {
                return '';
            }

            // For now, show extracted date as source indicator
            // Could be enhanced to show actual source type if available
            if (fact.extracted_at) {
                return `(extracted ${formatRelativeDate(fact.extracted_at)})`;
            }

            return '';
        }

        // Format a date as relative text (e.g., "Mar 15" or "2 days ago")
        function formatRelativeDate(dateStr) {
            if (!dateStr) return '';

            const date = new Date(dateStr);
            const now = new Date();
            const diffMs = now - date;
            const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

            if (diffDays === 0) return 'today';
            if (diffDays === 1) return 'yesterday';
            if (diffDays < 7) return `${diffDays} days ago`;
            if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;

            // Format as "Mar 15" for older dates
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            return `${months[date.getMonth()]} ${date.getDate()}`;
        }

        // Extract facts using LLM
        // Extract facts for a person
        // model: 'haiku' (default, fast/cheap) or 'sonnet' (high quality)
        async function extractFacts(model = 'haiku') {
            if (!selectedPersonId) return;

            const btn = document.getElementById('extractFactsBtn');
            const isManual = model === 'sonnet';

            if (isManual) {
                btn.disabled = true;
                btn.classList.add('extracting');
                btn.innerHTML = '<span>Extracting (Sonnet)...</span>';
            } else {
                // Auto-extraction with Haiku - show subtle indicator
                btn.innerHTML = '<span>Auto-extracting...</span>';
            }

            try {
                const data = await api(`/people/${selectedPersonId}/facts/extract?model=${model}`, { method: 'POST' });

                if (data.status === 'no_interactions') {
                    if (isManual) {
                        alert('No interactions found to extract facts from.');
                    }
                } else {
                    // Reload facts to show updated list (skip auto-trigger since we just extracted)
                    const tmpAutoExtract = autoExtractInProgress;
                    autoExtractInProgress = true;  // Prevent re-triggering
                    await loadFacts(selectedPersonId);
                    autoExtractInProgress = tmpAutoExtract;
                }
            } catch (error) {
                console.error('Failed to extract facts:', error);
                if (isManual) {
                    alert('Failed to extract facts. Please try again.');
                }
            } finally {
                btn.disabled = false;
                btn.classList.remove('extracting');
                btn.innerHTML = '<span>Extract Facts</span>';
            }
        }

        // Confirm a fact
        async function confirmFact(factId) {
            if (!selectedPersonId) return;

            try {
                await api(`/people/${selectedPersonId}/facts/${factId}/confirm`, { method: 'POST' });
                await loadFacts(selectedPersonId);
            } catch (error) {
                console.error('Failed to confirm fact:', error);
            }
        }

        // Delete a fact
        async function deleteFact(factId) {
            if (!selectedPersonId) return;

            if (!confirm('Are you sure you want to delete this fact?')) return;

            try {
                await api(`/people/${selectedPersonId}/facts/${factId}`, { method: 'DELETE' });
                await loadFacts(selectedPersonId);
            } catch (error) {
                console.error('Failed to delete fact:', error);
            }
        }

        // Timeline state
        let timelineData = [];
        let timelineFilter = 'all';

        // Graph visualization state
        let graphSimulation = null;
        let graphSvg = null;
        let graphZoom = null;
        let graphWeightRange = null;  // Stores min/max/range for edge filtering
        let graphLinks = null;        // Stores link data for CURRENT (filtered) view
        let graphNodes = null;        // Stores node data for CURRENT (filtered) view
        let graphCenterId = null;     // Stores center node ID for edge filtering
        let graphNodesAll = null;     // Stores ORIGINAL unfiltered node data
        let graphLinksAll = null;     // Stores ORIGINAL unfiltered link data
        let graphContainer = null;    // Stores container element for rebuilding
        let currentZoomScale = 1;
        let isRenderingGraph = false; // Guard against infinite render loops
        let filterDebounceTimer = null; // Debounce timer for filter changes
        let graphLoadingPersonId = null; // Guard against duplicate loadGraph calls for same person
        let hiddenNodeIds = new Set(); // Nodes hidden via right-click
        let graphHighlightedNodeId = null; // Node whose edges are currently highlighted (null = center node)
        let nodeSizingMode = 'strength'; // 'strength' or 'centrality'
        let nodeCentralityMap = new Map(); // Maps node ID to centrality score (0-1)

        /**
         * /ME PAGE "2ND DEGREE" NODE TRACKING
         *
         * On the /me page, almost everyone is technically a 1st-degree connection (directly
         * connected to me). Traditional "2nd degree" (friends-of-friends who AREN'T directly
         * connected) barely exists.
         *
         * So on the /me page, we redefine what "1st degree" and "2nd degree" mean:
         *
         *   - "1st degree node": A person whose edge weight TO ME exceeds the 1st degree threshold
         *   - "2nd degree node": A person whose edge weight to ANY VISIBLE 1st degree node
         *                        exceeds the 2nd degree threshold (regardless of whether they're
         *                        technically directly connected to me)
         *
         * This set tracks which nodes qualify as "2nd degree" under this /me-specific definition.
         * Used for:
         *   1. Determining visibility when "show 2nd degree" is enabled
         *   2. Styling edges from me to these nodes with faint gray (de-emphasized)
         *
         * ONLY populated when viewing the /me page. Empty otherwise.
         */
        let graphSecondDegreeNodeIds = new Set();

        // Preserved filter state (for node-to-node navigation)
        let preservedEdgeStrength = null;
        let preservedDegreeFilter = null;
        let preservedSourceFilter = null;

        // Source filter functions
        function toggleSourceFilter() {
            const options = document.getElementById('sourceFilterOptions');
            options.classList.toggle('visible');

            // Close on outside click
            if (options.classList.contains('visible')) {
                setTimeout(() => {
                    document.addEventListener('click', closeSourceFilterOnOutsideClick);
                }, 0);
            }
        }

        function closeSourceFilterOnOutsideClick(e) {
            const dropdown = document.getElementById('sourceFilterDropdown');
            if (dropdown && !dropdown.contains(e.target)) {
                document.getElementById('sourceFilterOptions').classList.remove('visible');
                document.removeEventListener('click', closeSourceFilterOnOutsideClick);
            }
        }

        function getSelectedSources() {
            const checkboxes = document.querySelectorAll('#sourceFilterOptions input[type="checkbox"]');
            const selected = [];
            checkboxes.forEach(cb => {
                if (cb.checked) selected.push(cb.value);
            });
            return selected;
        }

        function updateSourceFilter() {
            const selected = getSelectedSources();
            const label = document.getElementById('sourceFilterLabel');

            if (selected.length === 8) {
                label.textContent = 'All Sources';
            } else if (selected.length === 0) {
                label.textContent = 'None';
            } else if (selected.length <= 2) {
                label.textContent = selected.join(', ');
            } else {
                label.textContent = `${selected.length} sources`;
            }

            // Debounce to avoid rapid rebuilds
            if (filterDebounceTimer) clearTimeout(filterDebounceTimer);
            filterDebounceTimer = setTimeout(() => {
                applyGraphFilters();
            }, 300);
        }

        function restoreSourceFilter(sources) {
            const checkboxes = document.querySelectorAll('#sourceFilterOptions input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = sources.includes(cb.value);
            });
            updateSourceFilter();
        }

        // Graph filter bar expansion toggle
        function toggleGraphFiltersExpansion(event) {
            if (event) event.stopPropagation();
            const expansion = document.getElementById('graphControlsExpansion');
            const btn = document.querySelector('.graph-expand-btn');
            if (expansion) {
                expansion.classList.toggle('visible');
            }
            if (btn) {
                btn.classList.toggle('expanded');
            }
        }

        // Refresh graph layout - fully reload graph for current center person
        function refreshGraphLayout() {
            if (graphCenterId) {
                loadGraph(graphCenterId);
            }
        }

        // Category filter functions
        function toggleCategoryFilter() {
            const options = document.getElementById('categoryFilterOptions');
            options.classList.toggle('visible');

            if (options.classList.contains('visible')) {
                setTimeout(() => {
                    document.addEventListener('click', closeCategoryFilterOnOutsideClick);
                }, 0);
            }
        }

        function closeCategoryFilterOnOutsideClick(e) {
            const dropdown = document.getElementById('categoryFilterDropdown');
            if (dropdown && !dropdown.contains(e.target)) {
                document.getElementById('categoryFilterOptions').classList.remove('visible');
                document.removeEventListener('click', closeCategoryFilterOnOutsideClick);
            }
        }

        function getSelectedCategories() {
            const checkboxes = document.querySelectorAll('#categoryFilterOptions input[type="checkbox"]');
            const selected = [];
            checkboxes.forEach(cb => {
                if (cb.checked) selected.push(cb.value);
            });
            return selected;
        }

        function updateCategoryFilter() {
            const selected = getSelectedCategories();
            const label = document.getElementById('categoryFilterLabel');

            if (selected.length === 4) {
                label.textContent = 'All';
            } else if (selected.length === 0) {
                label.textContent = 'None';
            } else {
                label.textContent = `${selected.length} selected`;
            }

            // Debounce filter application
            if (filterDebounceTimer) clearTimeout(filterDebounceTimer);
            filterDebounceTimer = setTimeout(() => {
                applyGraphFilters();
            }, 300);
        }

        // Dunbar filter functions
        function toggleDunbarFilter() {
            const options = document.getElementById('dunbarFilterOptions');
            options.classList.toggle('visible');

            if (options.classList.contains('visible')) {
                setTimeout(() => {
                    document.addEventListener('click', closeDunbarFilterOnOutsideClick);
                }, 0);
            }
        }

        function closeDunbarFilterOnOutsideClick(e) {
            const dropdown = document.getElementById('dunbarFilterDropdown');
            if (dropdown && !dropdown.contains(e.target)) {
                document.getElementById('dunbarFilterOptions').classList.remove('visible');
                document.removeEventListener('click', closeDunbarFilterOnOutsideClick);
            }
        }

        function getSelectedDunbarCircles() {
            const checkboxes = document.querySelectorAll('#dunbarFilterOptions input[type="checkbox"]');
            const selected = [];
            checkboxes.forEach(cb => {
                if (cb.checked) {
                    if (cb.value === '6+') {
                        // "6+" includes both circle 6 and 7
                        selected.push(6, 7);
                    } else {
                        selected.push(parseInt(cb.value));
                    }
                }
            });
            return selected;
        }

        function updateDunbarFilter() {
            const checkboxes = document.querySelectorAll('#dunbarFilterOptions input[type="checkbox"]');
            const checkedCount = Array.from(checkboxes).filter(cb => cb.checked).length;
            const label = document.getElementById('dunbarFilterLabel');

            // 7 checkboxes total (0-5 plus "6+")
            if (checkedCount === 7) {
                label.textContent = 'All';
            } else if (checkedCount === 0) {
                label.textContent = 'None';
            } else {
                label.textContent = `${checkedCount} circles`;
            }

            // Debounce filter application
            if (filterDebounceTimer) clearTimeout(filterDebounceTimer);
            filterDebounceTimer = setTimeout(() => {
                applyGraphFilters();
            }, 300);
        }

        // Set node sizing mode (strength vs centrality)
        function setNodeSizingMode(mode) {
            nodeSizingMode = mode;

            // Update UI
            document.querySelectorAll('.node-sizing-toggle .sizing-option').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });

            // Update node sizes in place without rebuilding the graph
            if (graphSvg) {
                // Get current zoom compensation factor
                const zoomCompensation = Math.min(2.5, Math.max(0.7, 1 / Math.pow(currentZoomScale, 0.5)));

                // Update circle radii
                graphSvg.selectAll('.graph-node circle')
                    .transition()
                    .duration(300)
                    .attr('r', d => getNodeRadius(d) * zoomCompensation);

                // Update label positions to match new node sizes
                graphSvg.selectAll('.graph-node text')
                    .transition()
                    .duration(300)
                    .attr('dy', d => (getNodeRadius(d) * zoomCompensation) + 12);

                // Update hide button positions
                graphSvg.selectAll('.node-hide-btn')
                    .transition()
                    .duration(300)
                    .attr('transform', d => {
                        const r = getNodeRadius(d) * zoomCompensation;
                        return `translate(${r * 0.7}, ${-r * 0.7})`;
                    });
            }
        }

        // Calculate filtered edge weight based on selected sources
        function calculateFilteredWeight(edge, selectedSources) {
            let weight = 0;
            if (selectedSources.includes('calendar')) {
                weight += (edge.shared_events_count || 0) * 3;
            }
            if (selectedSources.includes('email')) {
                weight += (edge.shared_threads_count || 0) * 2;
            }
            if (selectedSources.includes('imessage')) {
                weight += (edge.shared_messages_count || 0) * 2;
            }
            if (selectedSources.includes('whatsapp')) {
                weight += (edge.shared_whatsapp_count || 0) * 2;
            }
            if (selectedSources.includes('slack')) {
                weight += (edge.shared_slack_count || 0);
            }
            if (selectedSources.includes('phone')) {
                weight += (edge.shared_phone_calls_count || 0) * 4;
            }
            if (selectedSources.includes('photos')) {
                weight += (edge.shared_photos_count || 0) * 3;
            }
            if (selectedSources.includes('linkedin') && edge.is_linkedin_connection) {
                weight += 10;
            }
            return weight;
        }

        // Check if edge has any signal from selected sources
        function edgeHasSelectedSource(edge, selectedSources) {
            if (selectedSources.includes('calendar') && (edge.shared_events_count || 0) > 0) return true;
            if (selectedSources.includes('email') && (edge.shared_threads_count || 0) > 0) return true;
            if (selectedSources.includes('imessage') && (edge.shared_messages_count || 0) > 0) return true;
            if (selectedSources.includes('whatsapp') && (edge.shared_whatsapp_count || 0) > 0) return true;
            if (selectedSources.includes('slack') && (edge.shared_slack_count || 0) > 0) return true;
            if (selectedSources.includes('phone') && (edge.shared_phone_calls_count || 0) > 0) return true;
            if (selectedSources.includes('photos') && (edge.shared_photos_count || 0) > 0) return true;
            if (selectedSources.includes('linkedin') && edge.is_linkedin_connection) return true;
            return false;
        }

        // Calculate optimal edge strength threshold to show approximately targetNodeCount nodes
        function calculateOptimalEdgeThreshold(nodes, links, centerId, targetNodeCount = 25) {
            // Get all first-degree edges (connected to center)
            const firstDegreeEdges = links.filter(l => l.source === centerId || l.target === centerId);

            if (firstDegreeEdges.length === 0) return 0;

            // Get weights of first-degree edges
            const weights = firstDegreeEdges.map(l => l.weight);
            const maxWeight = weights.reduce((a, b) => Math.max(a, b), 1);
            const minWeight = weights.reduce((a, b) => Math.min(a, b), Infinity);
            const weightRange = Math.max(1, maxWeight - minWeight);

            // Count first-degree nodes (excluding center)
            const firstDegreeNodeIds = new Set();
            firstDegreeEdges.forEach(l => {
                if (l.source !== centerId) firstDegreeNodeIds.add(l.source);
                if (l.target !== centerId) firstDegreeNodeIds.add(l.target);
            });
            const totalFirstDegree = firstDegreeNodeIds.size;

            // If we have fewer than target, show all (threshold = 0)
            if (totalFirstDegree <= targetNodeCount) return 0;

            // Binary search for threshold that gives closest to target node count
            let bestThreshold = 0;
            let bestDiff = Infinity;

            for (let percent = 0; percent <= 100; percent += 5) {
                const threshold = minWeight + (weightRange * (percent / 100));

                // Count nodes that would pass this threshold
                const visibleNodes = new Set();
                firstDegreeEdges.forEach(l => {
                    if (l.weight >= threshold) {
                        if (l.source !== centerId) visibleNodes.add(l.source);
                        if (l.target !== centerId) visibleNodes.add(l.target);
                    }
                });

                const nodeCount = visibleNodes.size;
                const diff = Math.abs(nodeCount - targetNodeCount);

                if (diff < bestDiff) {
                    bestDiff = diff;
                    bestThreshold = percent;
                }

                // If we're below target, higher thresholds will only show fewer nodes
                if (nodeCount < targetNodeCount) break;
            }

            return bestThreshold;
        }

        // Load graph visualization using 2-degree network
        async function loadGraph(personId) {
            // Prevent duplicate loads for the same person (race between loadPersonDetail and switchTab)
            if (graphLoadingPersonId === personId) {
                return;
            }
            graphLoadingPersonId = personId;

            // Close edge panel when loading a new graph (belt-and-suspenders with node click handler)
            closeEdgePanel();

            const container = document.getElementById('graphContainer');
            container.innerHTML = '<div class="loading">Loading graph...</div>';

            try {
                // Use the network endpoint with depth=2 for second-degree connections
                const data = await api(`/network?center_on=${personId}&depth=2`);

                if (!data.nodes || data.nodes.length === 0) {
                    container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ”—</div><p>No connections to visualize</p></div>';
                    return;
                }

                // Transform nodes from API format
                const nodes = data.nodes.map(node => ({
                    id: node.id,
                    name: node.name,
                    category: node.category,
                    degree: node.degree,  // 0 = center, 1 = first-degree, 2 = second-degree
                    strength: node.category === 'self' ? 100 : node.strength,  // "Me" node always 100%
                    interactionCount: node.interaction_count
                }));

                // Transform edges from API format (include source breakdown for filtering)
                const links = data.edges.map(edge => ({
                    source: edge.source,
                    target: edge.target,
                    weight: edge.weight,
                    type: edge.type,
                    // Source breakdown for multi-source filtering
                    shared_events_count: edge.shared_events_count || 0,
                    shared_threads_count: edge.shared_threads_count || 0,
                    shared_messages_count: edge.shared_messages_count || 0,
                    shared_whatsapp_count: edge.shared_whatsapp_count || 0,
                    shared_slack_count: edge.shared_slack_count || 0,
                    shared_phone_calls_count: edge.shared_phone_calls_count || 0,
                    shared_photos_count: edge.shared_photos_count || 0,
                    is_linkedin_connection: edge.is_linkedin_connection || false
                }));

                if (nodes.length === 1) {
                    container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ”—</div><p>No connections to visualize</p></div>';
                    return;
                }

                // Store ORIGINAL unfiltered data for filtering
                graphNodesAll = nodes;
                graphLinksAll = links;
                graphContainer = container;
                graphCenterId = personId;

                // Calculate optimal edge strength threshold to show ~25 nodes
                const optimalThreshold = calculateOptimalEdgeThreshold(nodes, links, personId, 25);

                // Set the slider to the optimal value
                const slider = document.getElementById('edgeStrengthSlider');
                if (slider) {
                    slider.value = optimalThreshold;
                    document.getElementById('edgeStrengthValue').textContent = optimalThreshold + '%';
                }

                // Apply filters and render (will compute filtered subset)
                applyGraphFilters();

            } catch (error) {
                console.error('Failed to load graph:', error);
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">âš ï¸</div><p>Failed to load graph</p></div>';
            } finally {
                // Clear loading guard so future loads for this person work
                if (graphLoadingPersonId === personId) {
                    graphLoadingPersonId = null;
                }
            }
        }

        // Get node radius based on sizing mode (strength or centrality)
        function getNodeRadius(node) {
            let normalizedValue;

            if (nodeSizingMode === 'centrality') {
                // Use centrality score (0-1) from the map
                normalizedValue = nodeCentralityMap.get(node.id) || 0;
            } else {
                // Use relationship strength (API returns 0-100 scale)
                normalizedValue = (node.strength || 0) / 100;
            }

            const baseRadius = 8 + normalizedValue * 15;

            // Center node (degree 0) is largest, first-degree normal, second-degree smaller
            if (node.degree === 0) {
                return baseRadius * 1.5;  // Center person is 50% larger
            } else if (node.degree === 2) {
                return baseRadius * 0.7;  // Second-degree is 30% smaller
            }
            return baseRadius;
        }

        // Category colors for nodes
        const categoryColors = {
            self: '#ffffff',      // White (CRM owner)
            family: '#daa520',    // Goldenrod
            work: '#4f46e5',      // Indigo
            personal: '#00bcd4',  // Light blue (cyan)
            unknown: '#6b7280'    // Gray
        };

        // Dunbar circle colors - matches CSS definitions for .header-dunbar-circle.circle-N
        // These are the canonical color definitions used across the app
        const dunbarCircleColors = {
            0: '#e94560',  // Intimate (5 people)
            1: '#ff6b6b',  // Close (15 people)
            2: '#ffa502',  // Good friends (50 people)
            3: '#2ed573',  // Friends (150 people)
            4: '#1e90ff',  // Acquaintances (500 people)
            5: '#5352ed',  // Recognized (1500 people)
            6: '#747d8c',  // Known (5000 people)
            7: '#747d8c'   // Outer (beyond 5000)
        };

        // Graph color mode: 'category' (default) or 'dunbar'
        let graphColorMode = 'category';

        /**
         * Get node fill color based on current color mode
         * @param {object} node - D3 node data
         * @returns {string} - Hex color for the node
         */
        function getNodeFillColor(node) {
            // Self node always stays white regardless of color mode
            if (node.category === 'self') {
                return categoryColors.self;
            }
            if (graphColorMode === 'dunbar') {
                const circle = dunbarCircleMap.get(node.id);
                return dunbarCircleColors[circle] || dunbarCircleColors[7];
            }
            return categoryColors[node.category] || categoryColors.unknown;
        }

        // Render D3 force-directed graph with degree-based styling
        function renderGraph(container, nodes, links, centerId) {
            // Stop any existing simulation to prevent memory leaks
            if (graphSimulation) {
                graphSimulation.stop();
                graphSimulation = null;
            }

            container.innerHTML = '';

            const width = container.clientWidth;
            const height = container.clientHeight || 400;
            const centerX = width / 2;
            const centerY = height / 2;

            // Create SVG
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            graphSvg = svg;

            // Close panels when clicking on empty space in the graph
            // (clicks on nodes/edges call stopPropagation, so they won't trigger this)
            svg.on('click', () => {
                closeEdgePanel();
                closeNodePanel();
            });

            // Create group for zoomable content
            const g = svg.append('g');

            // Use pre-calculated weight range from FULL dataset if available (from applyGraphFilters)
            // Otherwise calculate from passed-in links (for backwards compatibility)
            let minWeight, maxWeight, weightRange;
            if (graphWeightRange && graphWeightRange.range > 0) {
                minWeight = graphWeightRange.min;
                maxWeight = graphWeightRange.max;
                weightRange = graphWeightRange.range;
            } else {
                const weights = links.map(l => l.weight);
                maxWeight = weights.reduce((a, b) => Math.max(a, b), 1);
                minWeight = weights.reduce((a, b) => Math.min(a, b), Infinity);
                weightRange = Math.max(1, maxWeight - minWeight);
            }

            // Function to update label visibility based on zoom (edge visibility controlled by slider)
            function updateLabelsForZoom(scale) {
                currentZoomScale = scale;

                // Compensation factor: larger when zoomed out, smaller when zoomed in
                // At scale 0.2, factor ~2.0; at scale 1.0, factor ~1.0; at scale 2.0, factor ~0.8
                const zoomCompensation = Math.min(2.5, Math.max(0.7, 1 / Math.pow(scale, 0.5)));

                // Update node circle sizes to compensate for zoom
                g.selectAll('.graph-node circle')
                    .attr('r', d => getNodeRadius(d) * zoomCompensation);

                // Update label positions to match new node sizes
                g.selectAll('.graph-node text')
                    .attr('dy', d => (getNodeRadius(d) * zoomCompensation) + 12);

                // Update hide button positions and sizes
                g.selectAll('.node-hide-btn')
                    .attr('transform', d => {
                        const r = getNodeRadius(d) * zoomCompensation;
                        return `translate(${r * 0.7}, ${-r * 0.7})`;
                    })
                    .each(function() {
                        const btn = d3.select(this);
                        const btnRadius = 8 * zoomCompensation;
                        btn.select('circle')
                            .attr('r', btnRadius);
                        btn.select('text')
                            .attr('font-size', (12 * zoomCompensation) + 'px')
                            .attr('dy', '0.3em');  // Keep text vertically centered
                    });

                // Update label visibility and font size
                g.selectAll('.graph-node text')
                    .style('display', d => {
                        // Always show center node label
                        if (d.degree === 0) return 'block';
                        // Show 1st degree at scale >= 0.3
                        if (d.degree === 1 && scale >= 0.3) return 'block';
                        // Show 2nd degree at scale >= 0.7
                        if (d.degree === 2 && scale >= 0.7) return 'block';
                        return 'none';
                    })
                    .style('font-size', d => {
                        // Base font size, scaled to compensate for zoom
                        const baseSize = d.degree === 0 ? 15 : (d.degree === 1 ? 13 : 12);
                        return (baseSize * zoomCompensation) + 'px';
                    });

                // Show hide buttons when zoomed in enough (scale >= 1.3)
                g.selectAll('.node-hide-btn')
                    .style('display', scale >= 1.3 ? 'block' : 'none');
            }

            // Create zoom behavior with label visibility updates
            graphZoom = d3.zoom()
                .scaleExtent([0.05, 4])  // Allow more zoom out to see full network
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                    updateLabelsForZoom(event.transform.k);
                });

            svg.call(graphZoom);

            // Add tooltip div
            const tooltip = d3.select(container)
                .append('div')
                .attr('class', 'graph-tooltip');

            // Create force simulation - standard layout with strong repulsion
            const nodeCount = nodes.length;
            const spreadFactor = Math.max(1.5, Math.sqrt(nodeCount / 15));  // More aggressive spread

            // Initialize node positions - center node fixed at center, others spread around
            nodes.forEach(n => {
                if (n.degree === 0) {
                    // Center node goes exactly at center
                    n.x = centerX;
                    n.y = centerY;
                    n.fx = centerX;  // Fix position so it doesn't move
                    n.fy = centerY;
                } else if (n.x === undefined) {
                    // Other nodes spread around center
                    n.x = centerX + (Math.random() - 0.5) * 200 * spreadFactor;
                    n.y = centerY + (Math.random() - 0.5) * 200 * spreadFactor;
                }
            });

            // Store data globally for the slider and degree filter
            // Only set graphWeightRange if not already set (applyGraphFilters sets it from FULL dataset)
            if (!graphWeightRange || graphWeightRange.range <= 0) {
                graphWeightRange = { min: minWeight, max: maxWeight, range: weightRange };
            }
            graphLinks = links;
            graphNodes = nodes;
            graphCenterId = centerId;

            // Build adjacency set for cluster-aware repulsion
            const adjacencySet = new Set();
            links.forEach(l => {
                const sid = typeof l.source === 'object' ? l.source.id : l.source;
                const tid = typeof l.target === 'object' ? l.target.id : l.target;
                adjacencySet.add(`${sid}|${tid}`);
                adjacencySet.add(`${tid}|${sid}`);
            });

            graphSimulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links)
                    .id(d => d.id)
                    .distance(d => {
                        // Moderate distances - let repulsion create the real spacing
                        const sourceNode = typeof d.source === 'object' ? d.source : nodes.find(n => n.id === d.source);
                        const targetNode = typeof d.target === 'object' ? d.target : nodes.find(n => n.id === d.target);
                        const minDegree = Math.min(sourceNode?.degree ?? 1, targetNode?.degree ?? 1);

                        // Shorter base distances - clusters form from repulsion, not link length
                        if (minDegree === 0) return 100 * spreadFactor;  // Center to 1st degree
                        return 80 * spreadFactor;                         // Between other nodes
                    })
                    .strength(d => {
                        // Weak links let repulsion dominate, but keep connected nodes somewhat together
                        const w = d.weight || 50;
                        return 0.02 + (w / 100) * 0.03;  // 0.02 to 0.05 based on weight
                    }))
                .force('charge', d3.forceManyBody()
                    .strength(d => {
                        // Repulsion strength from tuning sliders
                        if (d.degree === 0) return -layoutTuning.centerRepel * spreadFactor;
                        if (d.degree === 1) return -layoutTuning.firstRepel * spreadFactor;
                        return -layoutTuning.secondRepel * spreadFactor;
                    })
                    .distanceMax(layoutTuning.range * spreadFactor))
                .force('center', d3.forceCenter(centerX, centerY).strength(0.02))  // Very weak centering
                .force('collision', d3.forceCollide()
                    .radius(d => getNodeRadius(d) + 15)  // Just prevent overlap
                    .strength(0.8))
                .alphaDecay(0.02)   // Slower decay = more time to settle into clusters
                .alphaMin(0.001)    // Lower minimum = simulation runs longer
                .velocityDecay(0.4) // Less friction = nodes can move into position
                .stop();  // Don't auto-start - wait until elements are created

            // Stop simulation after it settles (with timeout as backup)
            graphSimulation.on('end', () => {
                console.log('Graph simulation settled');
            });

            // Backup: force stop after 8 seconds (longer to allow clusters to form)
            setTimeout(() => {
                if (graphSimulation) {
                    graphSimulation.alpha(0).stop();
                }
            }, 8000);

            // Helper to check if edge connects to center node
            function isFirstDegreeEdge(d) {
                const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                return sourceId === centerId || targetId === centerId;
            }

            /**
             * /ME PAGE: Check if edge connects center to a "2nd degree" node
             *
             * On the /me page, graphSecondDegreeNodeIds contains nodes that qualified
             * for visibility through their connection to 1st degree nodes (not through
             * their direct edge to me). See detailed explanation at variable definition.
             *
             * Edges from me to these nodes should be visually de-emphasized (faint gray)
             * to reflect that the relationship is indirect/weak.
             */
            function isEdgeToSecondDegreeNode(d) {
                if (graphSecondDegreeNodeIds.size === 0) return false;
                const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                // Only applies to edges connecting to center
                if (sourceId !== centerId && targetId !== centerId) return false;
                const otherNodeId = sourceId === centerId ? targetId : sourceId;
                return graphSecondDegreeNodeIds.has(otherNodeId);
            }

            // Sort links so first-degree edges are rendered last (on top) for easier clicking
            const sortedLinks = [...links].sort((a, b) => {
                const aFirst = isFirstDegreeEdge(a) ? 1 : 0;
                const bFirst = isFirstDegreeEdge(b) ? 1 : 0;
                return aFirst - bFirst;  // First-degree edges come last (rendered on top)
            });

            // Draw links with distinctive first-degree edges
            const link = g.append('g')
                .attr('class', 'graph-links')
                .selectAll('line')
                .data(sortedLinks)
                .join('line')
                .attr('class', d => {
                    // On /me page, edges to "2nd degree" nodes don't get first-degree class
                    const useFirstDegreeStyle = isFirstDegreeEdge(d) && !isEdgeToSecondDegreeNode(d);
                    return 'graph-link' + (useFirstDegreeStyle ? ' first-degree' : '');
                })
                .attr('stroke', d => {
                    // On /me page, edges to "2nd degree" nodes use faint styling
                    // (see isEdgeToSecondDegreeNode() for explanation)
                    const useFirstDegreeStyle = isFirstDegreeEdge(d) && !isEdgeToSecondDegreeNode(d);
                    const normalizedWeight = (d.weight - minWeight) / weightRange;

                    if (useFirstDegreeStyle) {
                        // First-degree edges: bright cyan/teal gradient based on weight
                        const r = Math.round(0 + normalizedWeight * 50);
                        const g = Math.round(180 + normalizedWeight * 75);
                        const b = Math.round(200 + normalizedWeight * 55);
                        return `rgb(${r}, ${g}, ${b})`;
                    } else {
                        // Second-degree edges (or edges to /me-page "2nd degree" nodes): muted blue/gray
                        const r = Math.round(60 + normalizedWeight * 20);
                        const g = Math.round(70 + normalizedWeight * 40);
                        const b = Math.round(100 + normalizedWeight * 50);
                        return `rgb(${r}, ${g}, ${b})`;
                    }
                })
                .attr('stroke-width', d => {
                    const useFirstDegreeStyle = isFirstDegreeEdge(d) && !isEdgeToSecondDegreeNode(d);
                    const normalizedWeight = (d.weight - minWeight) / weightRange;

                    if (useFirstDegreeStyle) {
                        // First-degree: thicker (1 to 10px)
                        return 1 + normalizedWeight * 9;
                    } else {
                        // Second-degree: visible but thinner (0.5 to 4px)
                        return 0.5 + normalizedWeight * 3.5;
                    }
                })
                .attr('stroke-opacity', d => {
                    const useFirstDegreeStyle = isFirstDegreeEdge(d) && !isEdgeToSecondDegreeNode(d);
                    const normalizedWeight = (d.weight - minWeight) / weightRange;

                    if (useFirstDegreeStyle) {
                        // First-degree: very visible (0.6 to 0.95)
                        return 0.6 + normalizedWeight * 0.35;
                    } else {
                        // Second-degree: clearly visible (0.35 to 0.7)
                        return 0.35 + normalizedWeight * 0.35;
                    }
                })
                .attr('data-weight', d => d.weight);

            // Add invisible hit areas for easier edge clicking (wider transparent lines)
            // Use same sorted order as visible links
            const linkHitAreas = g.append('g')
                .attr('class', 'graph-link-hit-areas')
                .selectAll('line')
                .data(sortedLinks)
                .join('line')
                .attr('class', 'graph-link-hit')
                .attr('stroke', 'transparent')
                .attr('stroke-width', 15)  // Wide invisible hit area
                .style('cursor', 'pointer')
                .on('click', (event, d) => {
                    event.stopPropagation();
                    const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                    const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                    showEdgeDetails(sourceId, targetId);
                });

            // Draw nodes
            const node = g.append('g')
                .attr('class', 'graph-nodes')
                .selectAll('g')
                .data(nodes)
                .join('g')
                .attr('class', d => `graph-node degree-${d.degree}` + (d.degree === 0 ? ' selected' : ''))
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended))
                .on('click', (event, d) => {
                    // Single-click: Show person details panel (preview without navigating)
                    event.stopPropagation();
                    showNodeDetails(d);
                })
                .on('dblclick', (event, d) => {
                    // Double-click: Navigate to this person's graph view
                    event.stopPropagation();
                    // Close any open panels
                    closeEdgePanel();
                    closeNodePanel();
                    // Save current filter values before navigating (except edge strength - recalculated per person)
                    const degreeSelect = document.getElementById('degreeFilter');
                    preservedDegreeFilter = degreeSelect ? degreeSelect.value : 'all';
                    preservedSourceFilter = getSelectedSources();
                    // Switch to this person's detail view, stay on Graph tab, and reload their graph
                    selectPerson(d.id, true);
                })
                .on('mouseenter', (event, d) => {
                    const degreeLabel = d.degree === 0 ? 'Center' : (d.degree === 1 ? '1st degree' : '2nd degree');
                    tooltip.html(`
                        <strong>${escapeHtml(d.name)}</strong><br>
                        ${degreeLabel}<br>
                        Category: ${d.category || 'unknown'}<br>
                        Strength: ${Math.round(d.strength || 0)}%<br>
                        Interactions: ${d.interactionCount || 0}
                    `);
                    tooltip.classed('visible', true);
                })
                .on('mousemove', (event) => {
                    tooltip
                        .style('left', (event.offsetX + 10) + 'px')
                        .style('top', (event.offsetY - 10) + 'px');
                })
                .on('mouseleave', () => {
                    tooltip.classed('visible', false);
                })
;

            // Node circles with degree-based styling
            node.append('circle')
                .attr('r', d => getNodeRadius(d))
                .attr('fill', d => getNodeFillColor(d))
                .attr('fill-opacity', d => d.degree === 2 ? 0.7 : 1)
                .attr('stroke', d => {
                    if (d.degree === 0) return '#ef4444';  // Red border for selected
                    if (d.category === 'self') return '#4f46e5';  // Indigo stroke for white self node
                    return 'var(--bg-primary)';
                })
                .attr('stroke-width', d => d.degree === 0 ? 6 : (d.category === 'self' ? 3 : 2))
                .style('filter', d => d.degree === 0 ? 'drop-shadow(0 0 6px #ef4444)' : null);

            // Node labels - add to ALL nodes, visibility controlled by zoom
            node.append('text')
                .attr('dy', d => getNodeRadius(d) + 12)
                .text(d => truncateName(d.name, d.degree === 0 ? 28 : 20));

            // Hide button - appears when zoomed in, allows removing node from view
            // Only add to non-center nodes
            node.filter(d => d.degree !== 0)
                .append('g')
                .attr('class', 'node-hide-btn')
                .attr('transform', d => {
                    const r = getNodeRadius(d);
                    // Position at top-right of node
                    return `translate(${r * 0.7}, ${-r * 0.7})`;
                })
                .style('display', 'none')  // Hidden by default, shown on zoom
                .style('cursor', 'pointer')
                .on('click', (event, d) => {
                    event.stopPropagation();
                    event.preventDefault();
                    hideGraphNode(d.id, d.name);
                })
                .on('mouseenter', function() {
                    d3.select(this).select('circle').attr('fill', '#ef4444');
                })
                .on('mouseleave', function() {
                    d3.select(this).select('circle').attr('fill', 'rgba(0,0,0,0.6)');
                })
                .each(function() {
                    const btn = d3.select(this);
                    btn.append('circle')
                        .attr('r', 8)
                        .attr('fill', 'rgba(0,0,0,0.6)')
                        .attr('stroke', 'rgba(255,255,255,0.8)')
                        .attr('stroke-width', 1);
                    btn.append('text')
                        .attr('text-anchor', 'middle')
                        .attr('dy', '0.35em')
                        .attr('fill', 'white')
                        .attr('font-size', '12px')
                        .attr('font-weight', 'bold')
                        .text('Ã—');
                });

            // Apply initial label visibility based on current zoom
            updateLabelsForZoom(currentZoomScale);

            // Update positions on tick
            graphSimulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                linkHitAreas
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });

            // Now start the simulation (elements are ready) with lower initial energy
            graphSimulation.alpha(1).restart();  // Full energy to let clusters form

            // Restore or reset the filters
            const slider = document.getElementById('edgeStrengthSlider');
            const degreeFilterEl = document.getElementById('degreeFilter');

            // Use preserved values if available (for node-to-node navigation),
            // otherwise keep current DOM values (for filter-triggered rebuilds),
            // otherwise use defaults (for initial load)
            const currentSliderValue = slider ? parseInt(slider.value) : null;
            const currentDegreeValue = degreeFilterEl ? degreeFilterEl.value : null;
            const currentSourceCheckboxes = document.querySelectorAll('#sourceFilterOptions input[type="checkbox"]:checked');
            const currentSourceValue = currentSourceCheckboxes.length > 0 ?
                Array.from(currentSourceCheckboxes).map(cb => cb.value) : null;

            const edgeStrengthValue = preservedEdgeStrength !== null ? preservedEdgeStrength :
                                      (currentSliderValue !== null ? currentSliderValue : 50);
            const degreeFilterValue = preservedDegreeFilter !== null ? preservedDegreeFilter :
                                      (currentDegreeValue !== null ? currentDegreeValue : 'first');
            const sourceFilterValue = preservedSourceFilter !== null ? preservedSourceFilter :
                                      (currentSourceValue !== null ? currentSourceValue :
                                       ['calendar', 'email', 'imessage', 'whatsapp', 'slack', 'phone', 'linkedin', 'photos']);

            // Only update DOM if we're using preserved values (navigation scenario)
            // Don't overwrite what the user just set for filter-triggered rebuilds
            if (preservedEdgeStrength !== null && slider) {
                slider.value = edgeStrengthValue;
                document.getElementById('edgeStrengthValue').textContent = edgeStrengthValue + '%';
            }

            if (preservedDegreeFilter !== null && degreeFilterEl) {
                degreeFilterEl.value = degreeFilterValue;
            }

            // Only restore source filter checkboxes if we have preserved values
            if (preservedSourceFilter !== null) {
                const checkboxes = document.querySelectorAll('#sourceFilterOptions input[type="checkbox"]');
                checkboxes.forEach(cb => {
                    cb.checked = sourceFilterValue.includes(cb.value);
                });
                // Update label without triggering filter
                const sourceLabel = document.getElementById('sourceFilterLabel');
                if (sourceLabel) {
                    if (sourceFilterValue.length === 8) {
                        sourceLabel.textContent = 'All Sources';
                    } else if (sourceFilterValue.length === 0) {
                        sourceLabel.textContent = 'None';
                    } else if (sourceFilterValue.length <= 2) {
                        sourceLabel.textContent = sourceFilterValue.join(', ');
                    } else {
                        sourceLabel.textContent = `${sourceFilterValue.length} sources`;
                    }
                }
            }

            // Clear preserved values after using them
            preservedEdgeStrength = null;
            preservedDegreeFilter = null;
            preservedSourceFilter = null;

            // Drag functions - gentler reanimation
            function dragstarted(event, d) {
                if (!event.active) graphSimulation.alphaTarget(0.1).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) graphSimulation.alphaTarget(0);
                // Keep node fixed where user dropped it
                // d.fx = null;
                // d.fy = null;
            }

            // Add legend with color mode toggle
            const legend = d3.select(container)
                .append('div')
                .attr('class', 'graph-legend')
                .attr('id', 'graphLegend');

            updateGraphLegend();
        }

        /**
         * Update graph legend based on current color mode
         * Called on initial render and when color mode changes
         */
        function updateGraphLegend() {
            const legend = document.getElementById('graphLegend');
            if (!legend) return;

            // Build category legend items
            const categoryLegendItems = `
                <div class="graph-legend-item">
                    <div class="graph-legend-color" style="background: var(--bg-tertiary); border: 4px solid #ef4444; box-shadow: 0 0 6px #ef4444;"></div>
                    <span>Selected</span>
                </div>
                <div class="graph-legend-item">
                    <div class="graph-legend-color" style="background: ${categoryColors.self};"></div>
                    <span>Me</span>
                </div>
                <div class="graph-legend-item">
                    <div class="graph-legend-color" style="background: ${categoryColors.family};"></div>
                    <span>Family</span>
                </div>
                <div class="graph-legend-item">
                    <div class="graph-legend-color" style="background: ${categoryColors.work};"></div>
                    <span>Work</span>
                </div>
                <div class="graph-legend-item">
                    <div class="graph-legend-color" style="background: ${categoryColors.personal};"></div>
                    <span>Personal</span>
                </div>
            `;

            // Build Dunbar circle legend items using colors from dunbarCircleColors
            // Labels match getDunbarCircleSize() values used throughout the app
            const dunbarLabels = ['Intimate', 'Close', 'Good Friends', 'Friends', 'Acquaintances', 'Known', 'Familiar/Contacts'];
            const dunbarLegendItems = `
                <div class="graph-legend-item">
                    <div class="graph-legend-color" style="background: var(--bg-tertiary); border: 4px solid #ef4444; box-shadow: 0 0 6px #ef4444;"></div>
                    <span>Selected</span>
                </div>
                <div class="graph-legend-item">
                    <div class="graph-legend-color" style="background: ${categoryColors.self}; border: 1px solid #666;"></div>
                    <span>Me</span>
                </div>
                ${[0, 1, 2, 3, 4, 5].map(i => `
                    <div class="graph-legend-item">
                        <div class="graph-legend-color" style="background: ${dunbarCircleColors[i]};"></div>
                        <span>${i}: ${dunbarLabels[i]}</span>
                    </div>
                `).join('')}
                <div class="graph-legend-item">
                    <div class="graph-legend-color" style="background: ${dunbarCircleColors[6]};"></div>
                    <span>6+: ${dunbarLabels[6]}</span>
                </div>
            `;

            legend.innerHTML = `
                <div class="graph-legend-toggle">
                    <span class="graph-legend-toggle-label ${graphColorMode === 'category' ? 'active' : ''}"
                          onclick="setGraphColorMode('category')">Category</span>
                    <span class="graph-legend-toggle-label ${graphColorMode === 'dunbar' ? 'active' : ''}"
                          onclick="setGraphColorMode('dunbar')">Dunbar</span>
                </div>
                <div class="graph-legend-items">
                    ${graphColorMode === 'category' ? categoryLegendItems : dunbarLegendItems}
                </div>
            `;
        }

        /**
         * Set graph color mode and update visualization
         * @param {string} mode - 'category' or 'dunbar'
         */
        function setGraphColorMode(mode) {
            if (mode === graphColorMode) return;
            graphColorMode = mode;

            // Update legend display
            updateGraphLegend();

            // Update all node colors in the existing graph
            if (graphSvg) {
                graphSvg.selectAll('.graph-node circle')
                    .transition()
                    .duration(300)
                    .attr('fill', d => getNodeFillColor(d));
            }
        }

        // Reset graph zoom
        function resetGraphZoom() {
            if (graphSvg && graphZoom) {
                graphSvg.transition()
                    .duration(300)
                    .call(graphZoom.transform, d3.zoomIdentity);
            }
        }

        // Toggle graph fullscreen mode (mobile)
        function toggleGraphFullscreen() {
            const tabGraph = document.getElementById('tabGraph');
            if (!tabGraph) return;

            const isFullscreen = tabGraph.classList.toggle('graph-fullscreen');
            document.body.style.overflow = isFullscreen ? 'hidden' : '';

            // Resize graph to new container dimensions after CSS transition
            setTimeout(() => {
                const container = document.getElementById('graphContainer');
                if (graphSvg && container) {
                    graphSvg.attr('width', container.clientWidth)
                            .attr('height', container.clientHeight);
                    // Re-fit to nodes if we have data
                    if (graphNodes && graphNodes.length > 0) {
                        fitToFirstDegreeNodes();
                    }
                }
            }, 350);
        }

        // Fit zoom to show all first-degree nodes
        function fitToFirstDegreeNodes() {
            if (!graphSvg || !graphZoom || !graphNodes || graphNodes.length === 0) return;

            // Wait for simulation to stabilize a bit before fitting
            setTimeout(() => {
                // Get first-degree nodes (degree 0 or 1)
                const firstDegreeNodes = graphNodes.filter(n => n.degree === 0 || n.degree === 1);
                if (firstDegreeNodes.length === 0) return;

                // Calculate bounding box of first-degree nodes
                const xs = firstDegreeNodes.map(n => n.x).filter(x => x !== undefined);
                const ys = firstDegreeNodes.map(n => n.y).filter(y => y !== undefined);
                if (xs.length === 0 || ys.length === 0) return;

                const minX = Math.min(...xs);
                const maxX = Math.max(...xs);
                const minY = Math.min(...ys);
                const maxY = Math.max(...ys);

                // Add padding for node radius and labels
                const padding = 80;
                const boundsWidth = (maxX - minX) + padding * 2;
                const boundsHeight = (maxY - minY) + padding * 2;
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;

                // Get container dimensions
                const container = graphSvg.node().parentElement;
                const width = container.clientWidth;
                const height = container.clientHeight;

                // Calculate scale to fit bounds
                const scale = Math.min(
                    width / boundsWidth,
                    height / boundsHeight,
                    1.5  // Don't zoom in too much
                );

                // Calculate translation to center
                const tx = width / 2 - centerX * scale;
                const ty = height / 2 - centerY * scale;

                // Apply transform with animation
                graphSvg.transition()
                    .duration(500)
                    .call(graphZoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
            }, 800);  // Wait for simulation to settle
        }

        // Edge panel state
        let edgePanelData = { personAId: null, personBId: null };
        let selectedEdgeKey = null;  // Track which edge is selected

        // Show edge details panel
        async function showEdgeDetails(sourceId, targetId) {
            // Close node panel if open (edge panel replaces it)
            closeNodePanel();

            const panel = document.getElementById('edgePanel');

            // Clear previous selection and highlight new one
            if (graphSvg) {
                graphSvg.selectAll('.graph-link').classed('selected', false);
                // Find and highlight the clicked edge
                graphSvg.selectAll('.graph-link').each(function(d) {
                    const dSourceId = typeof d.source === 'object' ? d.source.id : d.source;
                    const dTargetId = typeof d.target === 'object' ? d.target.id : d.target;
                    if ((dSourceId === sourceId && dTargetId === targetId) ||
                        (dSourceId === targetId && dTargetId === sourceId)) {
                        d3.select(this).classed('selected', true);
                    }
                });
            }
            selectedEdgeKey = `${sourceId}:${targetId}`;

            try {
                const data = await api(`/relationship/${sourceId}/${targetId}`);
                edgePanelData = { personAId: data.person_a_id, personBId: data.person_b_id };

                // Update panel content
                document.getElementById('edgePanelPersonA').textContent = data.person_a_name;
                document.getElementById('edgePanelPersonB').textContent = data.person_b_name;
                // Backend returns normalized 0-100 weight
                document.getElementById('edgePanelWeight').textContent = (data.weight || 0) + '%';

                // Source breakdown
                document.getElementById('edgePanelEvents').textContent = data.shared_events_count || 0;
                document.getElementById('edgePanelThreads').textContent = data.shared_threads_count || 0;
                document.getElementById('edgePanelMessages').textContent = data.shared_messages_count || 0;
                document.getElementById('edgePanelWhatsapp').textContent = data.shared_whatsapp_count || 0;
                document.getElementById('edgePanelSlack').textContent = data.shared_slack_count || 0;
                document.getElementById('edgePanelPhone').textContent = data.shared_phone_calls_count || 0;
                document.getElementById('edgePanelPhotos').textContent = data.shared_photos_count || 0;
                document.getElementById('edgePanelLinkedin').textContent = data.is_linkedin_connection ? 'âœ“ Connected' : 'â€”';

                // Format dates
                const formatDate = (isoStr) => {
                    if (!isoStr) return 'â€”';
                    const date = new Date(isoStr);
                    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                };
                document.getElementById('edgePanelFirstSeen').textContent = formatDate(data.first_seen_together);
                document.getElementById('edgePanelLastSeen').textContent = formatDate(data.last_seen_together);

                // Shared contexts
                const contextsContainer = document.getElementById('edgePanelContexts');
                const tagsContainer = document.getElementById('edgePanelContextTags');
                if (data.shared_contexts && data.shared_contexts.length > 0) {
                    contextsContainer.style.display = 'block';
                    tagsContainer.innerHTML = data.shared_contexts.map(ctx =>
                        `<span class="edge-panel-context-tag">${escapeHtml(ctx)}</span>`
                    ).join('');
                } else {
                    contextsContainer.style.display = 'none';
                }

                panel.classList.add('visible');
            } catch (error) {
                console.error('Failed to load edge details:', error);
            }
        }

        // Close edge panel
        function closeEdgePanel() {
            document.getElementById('edgePanel').classList.remove('visible');
            // Deselect edge
            if (graphSvg) {
                graphSvg.selectAll('.graph-link').classed('selected', false);
            }
            selectedEdgeKey = null;
        }

        // Copy edge ID to clipboard
        function copyEdgeId() {
            if (!edgePanelData) return;
            const edgeId = `${edgePanelData.personAId}|${edgePanelData.personBId}`;
            copyToClipboardWithFeedback(edgeId, '#edgePanel .edge-panel-copy');
        }

        // Navigate to person from edge panel
        function navigateToEdgePerson(which) {
            const personId = which === 'a' ? edgePanelData.personAId : edgePanelData.personBId;
            if (personId) {
                // Save current filter values (except edge strength - recalculated per person)
                const degreeSelect = document.getElementById('degreeFilter');
                preservedDegreeFilter = degreeSelect ? degreeSelect.value : 'all';
                preservedSourceFilter = getSelectedSources();

                closeEdgePanel();
                selectPerson(personId, true);
            }
        }

        // Node panel state (for single-click person details)
        let nodePanelPersonId = null;
        let selectedNodeId = null;

        /**
         * Show person details panel when single-clicking a node.
         * This provides a quick preview without navigating away from the current graph.
         * Double-click is used to navigate to that person's graph view.
         *
         * @param {object} nodeData - D3 node data object with person info
         */
        async function showNodeDetails(nodeData) {
            const panel = document.getElementById('nodePanel');
            const isSelfNode = nodeData.category === 'self' || isMyPage(nodeData.id);

            // Close edge panel if open
            closeEdgePanel();

            // Highlight the selected node visually (teal border via CSS)
            if (graphSvg) {
                graphSvg.selectAll('.graph-node').classed('panel-selected', false);
                graphSvg.selectAll('.graph-node').each(function(d) {
                    if (d.id === nodeData.id) {
                        d3.select(this).classed('panel-selected', true);
                    }
                });
            }
            selectedNodeId = nodeData.id;
            nodePanelPersonId = nodeData.id;

            // Update edge highlighting to show this node's first-degree connections in cyan
            // (The center node keeps its red border - only edges change)
            updateEdgeHighlighting(nodeData.id);

            // Populate panel with node data (already available from graph)
            document.getElementById('nodePanelName').textContent = nodeData.name || 'Unknown';
            document.getElementById('nodePanelCategory').textContent = nodeData.category || 'unknown';

            // Hide relationship strength and timing for self node
            const relationshipSection = document.getElementById('nodePanelRelationshipSection');
            const timingSection = document.getElementById('nodePanelTimingSection');
            if (isSelfNode) {
                relationshipSection.style.display = 'none';
                timingSection.style.display = 'none';
            } else {
                relationshipSection.style.display = 'block';
                timingSection.style.display = 'block';
                document.getElementById('nodePanelStrength').textContent = Math.round(nodeData.strength || 0) + '%';

                // Dunbar circle from the map
                const circle = dunbarCircleMap.get(nodeData.id);
                if (circle !== undefined && circle >= 0) {
                    document.getElementById('nodePanelDunbar').textContent = `Circle ${circle}`;
                } else {
                    document.getElementById('nodePanelDunbar').textContent = 'â€”';
                }
            }

            // Try to get detailed data - use /me/stats for self, /people/{id} for others
            try {
                if (isSelfNode) {
                    // For self node, use aggregate stats from /me/stats
                    // Note: API returns total_emails, total_meetings, total_messages (not email_count, etc.)
                    const stats = await api('/me/stats');
                    document.getElementById('nodePanelEmails').textContent = formatCompactNumber(stats.total_emails || 0);
                    document.getElementById('nodePanelMeetings').textContent = formatCompactNumber(stats.total_meetings || 0);
                    document.getElementById('nodePanelMsgs').textContent = formatCompactNumber(stats.total_messages || 0);
                    document.getElementById('nodePanelMentions').textContent = 'â€”'; // Notes not in /me/stats
                } else {
                    // For other nodes, use person-specific data
                    const person = await api(`/people/${nodeData.id}`);
                    document.getElementById('nodePanelEmails').textContent = person.email_count || 0;
                    document.getElementById('nodePanelMeetings').textContent = person.meeting_count || 0;
                    document.getElementById('nodePanelMsgs').textContent = person.message_count || 0;
                    document.getElementById('nodePanelMentions').textContent = person.mention_count || 0;

                    // Format dates
                    const formatDate = (isoStr) => {
                        if (!isoStr) return 'â€”';
                        const date = new Date(isoStr);
                        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                    };
                    document.getElementById('nodePanelFirstSeen').textContent = formatDate(person.first_seen);
                    document.getElementById('nodePanelLastSeen').textContent = formatDate(person.last_seen);
                }
            } catch (error) {
                console.error('Failed to load person details:', error);
                // Use fallback data
                document.getElementById('nodePanelEmails').textContent = 'â€”';
                document.getElementById('nodePanelMeetings').textContent = 'â€”';
                document.getElementById('nodePanelMsgs').textContent = 'â€”';
                document.getElementById('nodePanelMentions').textContent = 'â€”';
                if (!isSelfNode) {
                    document.getElementById('nodePanelFirstSeen').textContent = 'â€”';
                    document.getElementById('nodePanelLastSeen').textContent = 'â€”';
                }
            }

            panel.classList.add('visible');
        }

        /**
         * Navigate to person's timeline with a specific source filter applied.
         * Called when clicking interaction stats in the node panel.
         * @param {string} filterType - Filter type: 'emails', 'events', 'messages', 'notes'
         */
        async function navigateToFilteredTimeline(filterType) {
            if (!nodePanelPersonId) return;

            const personId = nodePanelPersonId;

            // Close the panel first
            closeNodePanel();

            // Set the filter BEFORE any navigation - this ensures loadTimeline uses the correct filter
            timelineFilter = filterType;

            // Check if we're already viewing this person
            if (selectedPersonId === personId) {
                // Update filter chip UI
                document.querySelectorAll('.timeline-filter-chip').forEach(c => c.classList.remove('active'));
                const chip = document.querySelector(`.timeline-filter-chip[data-source="${filterType}"]`);
                if (chip) chip.classList.add('active');

                // Just switch to timeline tab with the filter already set
                await switchTab('timeline');
            } else {
                // Navigate to the new person
                selectedPersonId = personId;
                hiddenNodeIds.clear();
                closeEdgePanel();
                renderPeopleList();

                // Update URL to the timeline tab
                updateUrl(personId, 'timeline');

                // Load the person detail first (await it fully)
                await loadPersonDetail(personId, true);

                // Update filter chip UI (now that the DOM is rendered)
                document.querySelectorAll('.timeline-filter-chip').forEach(c => c.classList.remove('active'));
                const chip = document.querySelector(`.timeline-filter-chip[data-source="${filterType}"]`);
                if (chip) chip.classList.add('active');

                // Switch to timeline tab - this will call loadTimeline with our filter
                await switchTab('timeline');
            }
        }

        /**
         * Close the node details panel and deselect the node.
         */
        function closeNodePanel() {
            document.getElementById('nodePanel').classList.remove('visible');
            // Deselect node
            if (graphSvg) {
                graphSvg.selectAll('.graph-node').classed('panel-selected', false);
            }
            selectedNodeId = null;
            nodePanelPersonId = null;

            // Revert edge highlighting to show center node's first-degree edges
            updateEdgeHighlighting(null);
        }

        /**
         * Copy person ID to clipboard.
         */
        function copyPersonId() {
            if (!nodePanelPersonId) return;
            copyToClipboardWithFeedback(nodePanelPersonId, '#nodePanel .edge-panel-copy');
        }

        /**
         * Update edge highlighting to show a specific node's first-degree connections in cyan.
         * When a node is clicked (showing the details panel), that node's edges become highlighted.
         * When the panel is closed, edges revert to highlighting the center node's connections.
         *
         * @param {string|null} nodeId - The node whose edges should be highlighted, or null for center node
         */
        function updateEdgeHighlighting(nodeId) {
            // Use center node if no specific node provided
            const highlightNodeId = nodeId || graphCenterId;
            graphHighlightedNodeId = nodeId; // Track which node is highlighted (null means center)

            if (!graphSvg || !graphWeightRange) return;

            const { min: minWeight, range: weightRange } = graphWeightRange;

            // Helper to check if an edge connects to the highlighted node
            function isHighlightedEdge(d) {
                const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                return sourceId === highlightNodeId || targetId === highlightNodeId;
            }

            // Update all edge colors based on the highlighted node
            graphSvg.selectAll('.graph-link')
                .attr('stroke', function(d) {
                    const normalizedWeight = (d.weight - minWeight) / weightRange;

                    if (isHighlightedEdge(d)) {
                        // Edges to highlighted node: bright cyan/teal gradient based on weight
                        const r = Math.round(0 + normalizedWeight * 50);
                        const g = Math.round(180 + normalizedWeight * 75);
                        const b = Math.round(200 + normalizedWeight * 55);
                        return `rgb(${r}, ${g}, ${b})`;
                    } else {
                        // Other edges: muted blue/gray
                        const r = Math.round(60 + normalizedWeight * 20);
                        const g = Math.round(70 + normalizedWeight * 40);
                        const b = Math.round(100 + normalizedWeight * 50);
                        return `rgb(${r}, ${g}, ${b})`;
                    }
                })
                .attr('stroke-width', function(d) {
                    const normalizedWeight = (d.weight - minWeight) / weightRange;

                    if (isHighlightedEdge(d)) {
                        // Highlighted edges: thicker (1 to 10px)
                        return 1 + normalizedWeight * 9;
                    } else {
                        // Other edges: thinner (0.5 to 4px)
                        return 0.5 + normalizedWeight * 3.5;
                    }
                })
                .attr('stroke-opacity', function(d) {
                    const normalizedWeight = (d.weight - minWeight) / weightRange;

                    if (isHighlightedEdge(d)) {
                        // Highlighted edges: very visible (0.6 to 0.95)
                        return 0.6 + normalizedWeight * 0.35;
                    } else {
                        // Other edges: clearly visible (0.35 to 0.7)
                        return 0.35 + normalizedWeight * 0.35;
                    }
                })
                .classed('first-degree', function(d) {
                    return isHighlightedEdge(d);
                });

            // Bring highlighted edges to the front (render above gray edges)
            graphSvg.selectAll('.graph-link')
                .filter(function(d) { return isHighlightedEdge(d); })
                .raise();
        }

        /**
         * Close panels when clicking anywhere outside them.
         * This handles clicks on the page outside the graph area.
         */
        document.addEventListener('click', (event) => {
            const edgePanel = document.getElementById('edgePanel');
            const nodePanel = document.getElementById('nodePanel');

            // Check if click is inside either panel
            const clickedInsideEdgePanel = edgePanel && edgePanel.contains(event.target);
            const clickedInsideNodePanel = nodePanel && nodePanel.contains(event.target);

            // If click is outside both panels, close them
            if (!clickedInsideEdgePanel && edgePanel?.classList.contains('visible')) {
                closeEdgePanel();
            }
            if (!clickedInsideNodePanel && nodePanel?.classList.contains('visible')) {
                closeNodePanel();
            }
        });

        /**
         * Navigate to the person shown in the node panel.
         * Called when clicking "Go to Profile" button.
         */
        async function navigateFromNodePanel() {
            if (!nodePanelPersonId) return;

            const personId = nodePanelPersonId;

            // Save current filter values for when they return to graph
            const degreeSelect = document.getElementById('degreeFilter');
            preservedDegreeFilter = degreeSelect ? degreeSelect.value : 'all';
            preservedSourceFilter = getSelectedSources();

            closeNodePanel();

            // Navigate to the person's overview tab (not staying on current tab)
            selectedPersonId = personId;
            hiddenNodeIds.clear();
            closeEdgePanel();
            renderPeopleList();

            // Update URL to overview tab
            updateUrl(personId, 'overview');

            // Load person detail and switch to overview tab
            await loadPersonDetail(personId, false);
            await switchTab('overview', true); // true = don't update URL again
        }

        // Apply filters and REBUILD graph with only visible nodes for compact layouts
        function applyGraphFilters() {
            if (!graphNodesAll || !graphLinksAll || !graphContainer) return;

            // Prevent infinite loops from events during render
            if (isRenderingGraph) return;
            isRenderingGraph = true;

            try {
                // Get current filter values
                const slider = document.getElementById('edgeStrengthSlider');
                const secondSlider = document.getElementById('secondDegreeSlider');
                const degreeSelect = document.getElementById('degreeFilter');
                const thresholdPercent = slider ? parseInt(slider.value) : 15;
                const secondThresholdPercent = secondSlider ? parseInt(secondSlider.value) : 30;
                const showOnlyFirstDegree = degreeSelect ? (degreeSelect.value === 'first') : false;
                const selectedSources = getSelectedSources();
                const selectedCategories = getSelectedCategories();
                const selectedDunbarCircles = getSelectedDunbarCircles();

                // Get memoized weight stats from FULL dataset (avoids recalculating on every filter change)
                const weightStats = getGraphWeightStats();
                const { maxWeight, minWeight, weightRange } = weightStats;
                const threshold = minWeight + (weightRange * (thresholdPercent / 100));
                const secondThreshold = minWeight + (weightRange * (secondThresholdPercent / 100));

                // Build node lookup by ID from ORIGINAL data
                const nodeById = {};
                graphNodesAll.forEach(n => { nodeById[n.id] = n; });

                // Step 1: Determine which first-degree nodes pass the edge strength and source filter
                const visibleNodeIds = new Set();
                visibleNodeIds.add(graphCenterId); // Center node always visible

                graphLinksAll.forEach(linkData => {
                    if (!linkData) return;

                    const sourceId = linkData.source;
                    const targetId = linkData.target;
                    const isFirstDegree = sourceId === graphCenterId || targetId === graphCenterId;

                    // Check if edge has signal from any selected source
                    const hasSelectedSource = edgeHasSelectedSource(linkData, selectedSources);

                    // First-degree edges with sufficient weight make the OTHER node visible
                    // Use linkData.weight (normalized 0-100) for threshold comparison
                    if (isFirstDegree && hasSelectedSource && linkData.weight >= threshold) {
                        visibleNodeIds.add(sourceId);
                        visibleNodeIds.add(targetId);
                    }
                });

                // Step 2: If showing 2nd degree too, add second-degree nodes connected to visible first-degree
                // Track which second-degree edges pass the threshold (for filtering later)
                const visibleSecondDegreeEdges = new Set();

                // Clear the /me page 2nd-degree tracking set (see definition at top of file)
                graphSecondDegreeNodeIds = new Set();

                if (!showOnlyFirstDegree) {
                    const firstDegreeIds = new Set(visibleNodeIds);
                    const isViewingMeGraph = graphCenterId === DUNBAR_CONFIG.myPersonId;

                    if (isViewingMeGraph) {
                        /**
                         * /ME PAGE SPECIAL LOGIC
                         *
                         * On the /me page, almost everyone is technically a 1st-degree connection
                         * (directly connected to me in the graph). Traditional "2nd degree" nodes
                         * (friends-of-friends who AREN'T directly connected to me) barely exist.
                         *
                         * So we REDEFINE what "1st degree" and "2nd degree" mean on this page:
                         *
                         *   "1st degree node": A person whose edge weight TO ME exceeds the
                         *                      1st degree threshold slider value.
                         *                      (i.e., people I have STRONG direct relationships with)
                         *
                         *   "2nd degree node": A person whose edge weight to ANY VISIBLE 1st degree
                         *                      node exceeds the 2nd degree threshold slider value.
                         *                      (i.e., people my strong contacts have strong relationships with)
                         *
                         * This means someone who IS technically directly connected to me can appear
                         * as a "2nd degree node" if:
                         *   - Their direct edge to me is weak (below 1st threshold)
                         *   - BUT they have a strong edge to one of my visible 1st degree contacts
                         *
                         * We track these nodes in graphSecondDegreeNodeIds so we can visually
                         * de-emphasize the edges from me to them (faint gray instead of bright cyan).
                         */

                        // Remove center from firstDegreeIds - we don't want ME as a bridge
                        // (I'm connected to everyone, so that would make everyone visible)
                        firstDegreeIds.delete(graphCenterId);

                        graphLinksAll.forEach(linkData => {
                            if (!linkData) return;

                            const sourceId = linkData.source;
                            const targetId = linkData.target;

                            // Skip edges involving the center (me) - those are 1st degree edges
                            // We're looking for edges BETWEEN other people
                            if (sourceId === graphCenterId || targetId === graphCenterId) return;

                            // Edge must pass source filter
                            const hasSelectedSource = edgeHasSelectedSource(linkData, selectedSources);
                            if (!hasSelectedSource) return;

                            // Edge must pass second-degree weight threshold
                            if (linkData.weight < secondThreshold) return;

                            // If one end is a visible 1st-degree node and the other is not yet visible,
                            // add the other as a "2nd degree" node
                            if (firstDegreeIds.has(sourceId) && !visibleNodeIds.has(targetId)) {
                                visibleNodeIds.add(targetId);
                                graphSecondDegreeNodeIds.add(targetId);
                                visibleSecondDegreeEdges.add(`${sourceId}|${targetId}`);
                            }
                            if (firstDegreeIds.has(targetId) && !visibleNodeIds.has(sourceId)) {
                                visibleNodeIds.add(sourceId);
                                graphSecondDegreeNodeIds.add(sourceId);
                                visibleSecondDegreeEdges.add(`${sourceId}|${targetId}`);
                            }
                        });
                    } else {
                        /**
                         * NON-/ME PAGE LOGIC (original behavior)
                         *
                         * On pages for other people, we use traditional graph degree:
                         *   - 1st degree: Graph distance of 1 from center (node.degree === 1)
                         *   - 2nd degree: Graph distance of 2 from center (node.degree === 2)
                         *
                         * We exclude "me" (the CRM owner) from being a bridge for 2nd degree,
                         * since I'm connected to everyone and would cause all nodes to appear.
                         */
                        firstDegreeIds.delete(DUNBAR_CONFIG.myPersonId);

                        graphLinksAll.forEach(linkData => {
                            if (!linkData) return;

                            const sourceId = linkData.source;
                            const targetId = linkData.target;
                            const sourceNode = nodeById[sourceId];
                            const targetNode = nodeById[targetId];

                            // Edge must pass source filter
                            const hasSelectedSource = edgeHasSelectedSource(linkData, selectedSources);
                            if (!hasSelectedSource) return;

                            // Second-degree edge must also pass the second-degree weight threshold
                            if (linkData.weight < secondThreshold) return;

                            // If one end is a visible first-degree node and other has graph degree=2, add it
                            if (firstDegreeIds.has(sourceId) && targetNode && targetNode.degree === 2) {
                                visibleNodeIds.add(targetId);
                                visibleSecondDegreeEdges.add(`${sourceId}|${targetId}`);
                            }
                            if (firstDegreeIds.has(targetId) && sourceNode && sourceNode.degree === 2) {
                                visibleNodeIds.add(sourceId);
                                visibleSecondDegreeEdges.add(`${sourceId}|${targetId}`);
                            }
                        });
                    }
                }

                // Step 3: Create filtered link array with appropriate thresholds
                const filteredLinks = graphLinksAll.filter(l => {
                    const sourceId = l.source;
                    const targetId = l.target;
                    const bothVisible = visibleNodeIds.has(sourceId) && visibleNodeIds.has(targetId);
                    const neitherHidden = !hiddenNodeIds.has(sourceId) && !hiddenNodeIds.has(targetId);
                    const hasSelectedSource = edgeHasSelectedSource(l, selectedSources);

                    if (!bothVisible || !neitherHidden || !hasSelectedSource) return false;

                    // Check if this is a first-degree edge (connects to center)
                    const isFirstDegree = sourceId === graphCenterId || targetId === graphCenterId;

                    if (isFirstDegree) {
                        /**
                         * /ME PAGE EDGE EXCEPTION
                         *
                         * On the /me page, edges from me to "2nd degree nodes" should be shown
                         * even though their weight is below the 1st degree threshold.
                         * (That's WHY they're "2nd degree" - their direct edge to me is weak,
                         * but they qualify through a strong edge to one of my 1st degree contacts.)
                         *
                         * Without this exception, these edges would be filtered out here,
                         * making the "2nd degree" nodes appear disconnected from me.
                         */
                        const otherNodeId = sourceId === graphCenterId ? targetId : sourceId;
                        if (graphSecondDegreeNodeIds.has(otherNodeId)) {
                            return true;  // Allow edge to 2nd-degree node regardless of weight
                        }
                        // First-degree edges use first threshold
                        return l.weight >= threshold;
                    } else {
                        // Second-degree edges use second threshold
                        return l.weight >= secondThreshold;
                    }
                }).map(l => ({...l})); // Clone to avoid mutating original

                // Step 4: Remove second-degree nodes that have no visible edges after filtering
                const nodesWithEdges = new Set();
                nodesWithEdges.add(graphCenterId); // Center always visible
                filteredLinks.forEach(l => {
                    nodesWithEdges.add(l.source);
                    nodesWithEdges.add(l.target);
                });

                const filteredNodes = graphNodesAll
                    .filter(n => {
                        if (!visibleNodeIds.has(n.id) || hiddenNodeIds.has(n.id)) return false;

                        // Apply category filter (center node always passes)
                        // Nodes with undefined/unknown category default to 'work' for filtering
                        if (n.id !== graphCenterId) {
                            const nodeCategory = n.category || 'work';
                            if (!selectedCategories.includes(nodeCategory)) {
                                return false;
                            }
                        }

                        // Apply Dunbar circle filter (center node always passes)
                        if (n.id !== graphCenterId) {
                            const dunbarCircle = dunbarCircleMap.get(n.id) ?? 7;
                            if (!selectedDunbarCircles.includes(dunbarCircle)) {
                                return false;
                            }
                        }

                        // First-degree nodes stay even without edges (connected to center)
                        if (n.degree <= 1) return true;
                        // Second-degree nodes need at least one visible edge
                        return nodesWithEdges.has(n.id);
                    })
                    .map(n => ({...n, x: undefined, y: undefined, fx: undefined, fy: undefined})); // Reset positions

                // Step 5: Filter links to only include edges between remaining nodes
                // This handles cases where category/Dunbar filters removed nodes
                const filteredNodeIds = new Set(filteredNodes.map(n => n.id));
                const finalLinks = filteredLinks.filter(l => {
                    return filteredNodeIds.has(l.source) && filteredNodeIds.has(l.target);
                });

                // Store filtered data as current view
                graphNodes = filteredNodes;
                graphLinks = finalLinks;
                graphWeightRange = { min: minWeight, max: maxWeight, range: weightRange };

                // Calculate node centrality (degree centrality based on visible edges)
                // Use rank-based normalization for better visual differentiation
                nodeCentralityMap.clear();
                const degreeCount = new Map();
                finalLinks.forEach(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    degreeCount.set(sourceId, (degreeCount.get(sourceId) || 0) + 1);
                    degreeCount.set(targetId, (degreeCount.get(targetId) || 0) + 1);
                });
                // Sort nodes by degree and assign rank-based scores (percentile)
                const sortedByDegree = Array.from(degreeCount.entries())
                    .sort((a, b) => a[1] - b[1]);  // Sort ascending by degree
                const nodeCount = sortedByDegree.length;
                sortedByDegree.forEach(([nodeId, degree], index) => {
                    // Map rank to 0-1 range (lowest degree = 0, highest = 1)
                    const rankScore = nodeCount > 1 ? index / (nodeCount - 1) : 0.5;
                    nodeCentralityMap.set(nodeId, rankScore);
                });

                // Check if we have anything to show
                if (filteredNodes.length <= 1) {
                    if (graphSimulation) {
                        graphSimulation.stop();
                    }
                    graphContainer.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ”—</div><p>No connections match current filters</p></div>';
                    graphSvg = null;
                    graphSimulation = null;
                    return;
                }

                // Rebuild the graph with only filtered data
                renderGraph(graphContainer, filteredNodes, finalLinks, graphCenterId);

                // Fit zoom to show all first-degree nodes
                fitToFirstDegreeNodes();
            } finally {
                isRenderingGraph = false;
            }
        }

        // Hide a node from the graph (right-click action)
        function hideGraphNode(nodeId, nodeName) {
            hiddenNodeIds.add(nodeId);
            console.log(`Hidden node: ${nodeName} (${nodeId})`);
            // Reapply filters to rebuild graph without this node
            applyGraphFilters();
        }

        // Update edge visibility - wrapper that calls unified filter
        function updateEdgeVisibility(thresholdPercent) {
            document.getElementById('edgeStrengthValue').textContent = thresholdPercent + '%';
            // Debounce filter application to avoid rebuilding graph while dragging slider
            if (filterDebounceTimer) clearTimeout(filterDebounceTimer);
            filterDebounceTimer = setTimeout(() => {
                applyGraphFilters();
            }, 500);
        }

        // Update degree filter - wrapper that calls unified filter
        function updateDegreeFilter(value) {
            // Show/hide second degree slider based on selection
            const secondSlider = document.getElementById('secondDegreeSliderContainer');
            if (secondSlider) {
                secondSlider.style.display = (value === 'all') ? 'flex' : 'none';
            }

            // Debounce to avoid rapid rebuilds
            if (filterDebounceTimer) clearTimeout(filterDebounceTimer);
            filterDebounceTimer = setTimeout(() => {
                applyGraphFilters();
            }, 300);
        }

        // Update second degree weight filter
        function updateSecondDegreeWeight(value) {
            document.getElementById('secondDegreeValue').textContent = value + '%';
            // Debounce filter application
            if (filterDebounceTimer) clearTimeout(filterDebounceTimer);
            filterDebounceTimer = setTimeout(() => {
                applyGraphFilters();
            }, 500);
        }

        // Toggle layout tuning panel
        function toggleLayoutTuning() {
            const sliders = document.getElementById('tuningSliders');
            sliders.classList.toggle('visible');

            if (sliders.classList.contains('visible')) {
                setTimeout(() => {
                    document.addEventListener('click', closeLayoutTuningOnOutsideClick);
                }, 0);
            }
        }

        function closeLayoutTuningOnOutsideClick(e) {
            const container = document.querySelector('.graph-layout-tuning');
            if (container && !container.contains(e.target)) {
                document.getElementById('tuningSliders').classList.remove('visible');
                document.removeEventListener('click', closeLayoutTuningOnOutsideClick);
            }
        }

        // Layout tuning values - load from localStorage or use defaults
        let layoutTuning = (() => {
            const saved = localStorage.getItem('graphLayoutTuning');
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {}
            }
            return {
                centerRepel: 1000,
                firstRepel: 1300,
                secondRepel: 900,
                range: 900
            };
        })();

        // Initialize layout tuning sliders from saved values
        function initLayoutTuningSliders() {
            const centerSlider = document.getElementById('centerRepelSlider');
            const firstSlider = document.getElementById('firstRepelSlider');
            const secondSlider = document.getElementById('secondRepelSlider');
            const rangeSlider = document.getElementById('repelRangeSlider');

            if (centerSlider) {
                centerSlider.value = layoutTuning.centerRepel;
                document.getElementById('centerRepelValue').textContent = layoutTuning.centerRepel;
            }
            if (firstSlider) {
                firstSlider.value = layoutTuning.firstRepel;
                document.getElementById('firstRepelValue').textContent = layoutTuning.firstRepel;
            }
            if (secondSlider) {
                secondSlider.value = layoutTuning.secondRepel;
                document.getElementById('secondRepelValue').textContent = layoutTuning.secondRepel;
            }
            if (rangeSlider) {
                rangeSlider.value = layoutTuning.range;
                document.getElementById('repelRangeValue').textContent = layoutTuning.range;
            }
        }

        // Update layout tuning from sliders
        function updateLayoutTuning() {
            layoutTuning.centerRepel = parseInt(document.getElementById('centerRepelSlider').value);
            layoutTuning.firstRepel = parseInt(document.getElementById('firstRepelSlider').value);
            layoutTuning.secondRepel = parseInt(document.getElementById('secondRepelSlider').value);
            layoutTuning.range = parseInt(document.getElementById('repelRangeSlider').value);

            // Update displayed values
            document.getElementById('centerRepelValue').textContent = layoutTuning.centerRepel;
            document.getElementById('firstRepelValue').textContent = layoutTuning.firstRepel;
            document.getElementById('secondRepelValue').textContent = layoutTuning.secondRepel;
            document.getElementById('repelRangeValue').textContent = layoutTuning.range;

            // Save to localStorage
            localStorage.setItem('graphLayoutTuning', JSON.stringify(layoutTuning));

            // Rebuild graph with new layout parameters
            if (filterDebounceTimer) clearTimeout(filterDebounceTimer);
            filterDebounceTimer = setTimeout(() => {
                applyGraphFilters();
            }, 300);
        }

        // Helper to truncate name
        function truncateName(name, maxLen) {
            if (!name) return '';
            if (name.length <= maxLen) return name;
            return name.substring(0, maxLen - 1) + 'â€¦';
        }

        // Switch tab
        async function switchTab(tabName, skipUrlUpdate = false) {
            // Update tab UI
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');

            // Show/hide content
            document.querySelectorAll('.tab-content').forEach(c => c.style.display = 'none');
            const tabContent = document.getElementById(`tab${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`);
            tabContent.style.display = tabName === 'graph' ? 'flex' : 'block';

            // Toggle compact header modes (graph/timeline)
            const detailContent = document.getElementById('detailContent');
            detailContent.classList.remove('graph-mode', 'timeline-mode');
            if (tabName === 'graph') {
                detailContent.classList.add('graph-mode');
            } else if (tabName === 'timeline') {
                detailContent.classList.add('timeline-mode');
            }

            // Load data if needed
            const { isFamily } = parseUrl();
            if (isFamily) {
                // Family view - load family-specific data
                if (tabName === 'timeline') {
                    await loadFamilyTimeline();
                }
                // Graph not supported for family view
            } else if (selectedPersonId) {
                if (tabName === 'timeline') {
                    await loadTimeline(selectedPersonId);
                } else if (tabName === 'graph') {
                    await loadGraph(selectedPersonId);
                }

                // Update URL (unless called from popstate or initial load)
                if (!skipUrlUpdate) {
                    updateUrl(selectedPersonId, tabName);
                }
            }
        }

        // Toggle source entities
        function toggleSourceEntities() {
            const list = document.getElementById('sourceEntitiesList');
            const toggle = document.getElementById('sourceEntitiesToggle');

            if (list.classList.contains('expanded')) {
                list.classList.remove('expanded');
                toggle.textContent = 'â–¶';
            } else {
                list.classList.add('expanded');
                toggle.textContent = 'â–¼';
            }
        }

        // Track original notes value for dirty checking
        let originalNotesValue = '';

        // Handle notes input - show save button when changed
        function onNotesInput() {
            const notesArea = document.getElementById('notesArea');
            const saveBtn = document.getElementById('notesSaveBtn');
            const indicator = document.getElementById('notesUnsavedIndicator');

            const hasChanges = notesArea.value !== originalNotesValue;

            if (hasChanges) {
                saveBtn.style.display = 'inline-block';
                indicator.style.display = 'inline';
            } else {
                saveBtn.style.display = 'none';
                indicator.style.display = 'none';
            }
        }

        // Save notes
        async function saveNotes() {
            if (!selectedPersonId) return;

            const notesArea = document.getElementById('notesArea');
            const saveBtn = document.getElementById('notesSaveBtn');
            const indicator = document.getElementById('notesUnsavedIndicator');
            const notes = notesArea.value;

            // Disable button while saving
            saveBtn.disabled = true;
            saveBtn.textContent = 'Saving...';

            try {
                await api(`/people/${selectedPersonId}`, {
                    method: 'PATCH',
                    body: JSON.stringify({ notes })
                });

                // Update original value and hide save button
                originalNotesValue = notes;
                saveBtn.style.display = 'none';
                indicator.style.display = 'none';
            } catch (error) {
                console.error('Failed to save notes:', error);
                alert('Failed to save notes. Please try again.');
            } finally {
                saveBtn.disabled = false;
                saveBtn.textContent = 'Save';
            }
        }

        // People list filter functions
        function togglePeopleCategoryFilter() {
            const options = document.getElementById('peopleCategoryOptions');
            options.classList.toggle('show');
            // Close dunbar dropdown if open
            document.getElementById('peopleDunbarOptions').classList.remove('show');
        }

        function togglePeopleDunbarFilter() {
            const options = document.getElementById('peopleDunbarOptions');
            options.classList.toggle('show');
            // Close category dropdown if open
            document.getElementById('peopleCategoryOptions').classList.remove('show');
        }

        function updatePeopleCategoryFilter() {
            const checkboxes = document.querySelectorAll('#peopleCategoryOptions input[type="checkbox"]');
            peopleCategoryFilters.clear();
            checkboxes.forEach(cb => {
                if (cb.checked) peopleCategoryFilters.add(cb.value);
            });

            // Update label
            const label = document.getElementById('peopleCategoryLabel');
            if (peopleCategoryFilters.size === 4) {
                label.textContent = 'Categories';
            } else if (peopleCategoryFilters.size === 0) {
                label.textContent = 'None';
            } else {
                label.textContent = `${peopleCategoryFilters.size} Selected`;
            }

            renderPeopleList();
        }

        function updatePeopleDunbarFilter() {
            // Check if we were previously in "only outer circles" mode
            const wasOnlyOuter = peopleDunbarFilters.size > 0 &&
                [...peopleDunbarFilters].every(c => c === '5' || c === '6+');

            const checkboxes = document.querySelectorAll('#peopleDunbarOptions input[type="checkbox"]');
            peopleDunbarFilters.clear();
            checkboxes.forEach(cb => {
                if (cb.checked) peopleDunbarFilters.add(cb.value);
            });

            // Check if we are now in "only outer circles" mode
            const isOnlyOuter = peopleDunbarFilters.size > 0 &&
                [...peopleDunbarFilters].every(c => c === '5' || c === '6+');

            // Update label
            const label = document.getElementById('peopleDunbarLabel');
            if (peopleDunbarFilters.size === 7) {
                label.textContent = 'Circles';
            } else if (peopleDunbarFilters.size === 0) {
                label.textContent = 'None';
            } else {
                label.textContent = `${peopleDunbarFilters.size} Selected`;
            }

            // If switching to/from "only outer circles", reload from API
            if (wasOnlyOuter !== isOnlyOuter) {
                loadPeople();
            } else {
                renderPeopleList();
            }
        }

        // All/None toggle functions for category filter
        function selectAllCategories() {
            document.querySelectorAll('#peopleCategoryOptions input[type="checkbox"]').forEach(cb => cb.checked = true);
            updatePeopleCategoryFilter();
        }

        function selectNoCategories() {
            document.querySelectorAll('#peopleCategoryOptions input[type="checkbox"]').forEach(cb => cb.checked = false);
            updatePeopleCategoryFilter();
        }

        // All/None toggle functions for dunbar filter
        function selectAllDunbar() {
            document.querySelectorAll('#peopleDunbarOptions input[type="checkbox"]').forEach(cb => cb.checked = true);
            updatePeopleDunbarFilter();
        }

        function selectNoDunbar() {
            document.querySelectorAll('#peopleDunbarOptions input[type="checkbox"]').forEach(cb => cb.checked = false);
            updatePeopleDunbarFilter();
        }

        // ===============================
        // Tag Filter Functions
        // ===============================

        function togglePeopleTagFilter() {
            const options = document.getElementById('peopleTagOptions');
            options.classList.toggle('show');
            // Close other dropdowns
            document.getElementById('peopleCategoryOptions').classList.remove('show');
            document.getElementById('peopleDunbarOptions').classList.remove('show');
        }

        // Collect all unique tags from loaded people
        function collectAllTags() {
            const tagSet = new Set();
            for (const person of people) {
                if (person.tags && person.tags.length > 0) {
                    person.tags.forEach(tag => tagSet.add(tag));
                }
            }
            const newTags = [...tagSet].sort();
            // Only rebuild if tags changed
            if (JSON.stringify(newTags) !== JSON.stringify(allAvailableTags)) {
                allAvailableTags = newTags;
                buildTagFilterOptions();
            }
        }

        // Build tag filter dropdown options grouped by prefix
        function buildTagFilterOptions() {
            const container = document.getElementById('peopleTagOptions');
            if (!container) return;

            // Include search input and toggle buttons
            let html = `
                <input type="text" class="tag-search-input" id="tagSearchInput" placeholder="Search tags..." oninput="filterTagOptions()">
                <div class="people-filter-toggles">
                    <button class="filter-toggle-btn" onclick="selectAllTags()">All</button>
                    <button class="filter-toggle-btn" onclick="selectNoTags()">None</button>
                </div>
            `;

            if (allAvailableTags.length === 0) {
                html += '<div style="padding: 0.5rem; color: var(--text-muted); font-size: 0.75rem;">No tags found</div>';
                container.innerHTML = html;
                return;
            }

            // Group tags by prefix (e.g., "work:" â†’ "work" section)
            const groups = {};
            const ungrouped = [];
            for (const tag of allAvailableTags) {
                const colonIdx = tag.indexOf(':');
                if (colonIdx > 0 && colonIdx < tag.length - 1) {
                    const prefix = tag.substring(0, colonIdx);
                    if (!groups[prefix]) groups[prefix] = [];
                    groups[prefix].push(tag);
                } else {
                    ungrouped.push(tag);
                }
            }

            // Render grouped tags in specific order: industry, seniority, city, state, then rest alphabetically
            const prefixOrder = ['industry', 'seniority', 'city', 'state'];
            const allPrefixes = Object.keys(groups);
            const orderedPrefixes = prefixOrder.filter(p => allPrefixes.includes(p));
            const remainingPrefixes = allPrefixes.filter(p => !prefixOrder.includes(p)).sort();
            const sortedPrefixes = [...orderedPrefixes, ...remainingPrefixes];
            for (const prefix of sortedPrefixes) {
                html += `<div class="tag-filter-section">`;
                html += `<span class="tag-filter-section-label">${escapeHtml(prefix)}</span>`;
                for (const tag of groups[prefix]) {
                    const checked = peopleTagFilters.has(tag) ? 'checked' : '';
                    const displayName = tag.substring(prefix.length + 1);  // Remove "prefix:" part
                    html += `
                        <label class="people-filter-option">
                            <input type="checkbox" value="${escapeHtml(tag)}" ${checked} onchange="updatePeopleTagFilter()">
                            ${escapeHtml(displayName)}
                        </label>
                    `;
                }
                html += `</div>`;
            }

            // Render ungrouped tags last (under "Other" section if there are groups)
            if (ungrouped.length > 0) {
                if (sortedPrefixes.length > 0) {
                    html += `<div class="tag-filter-section">`;
                    html += `<span class="tag-filter-section-label">Other</span>`;
                }
                for (const tag of ungrouped) {
                    const checked = peopleTagFilters.has(tag) ? 'checked' : '';
                    html += `
                        <label class="people-filter-option">
                            <input type="checkbox" value="${escapeHtml(tag)}" ${checked} onchange="updatePeopleTagFilter()">
                            ${escapeHtml(tag)}
                        </label>
                    `;
                }
                if (sortedPrefixes.length > 0) {
                    html += `</div>`;
                }
            }

            container.innerHTML = html;
        }

        function updatePeopleTagFilter() {
            const checkboxes = document.querySelectorAll('#peopleTagOptions input[type="checkbox"]');
            const prevSize = peopleTagFilters.size;
            peopleTagFilters.clear();
            checkboxes.forEach(cb => {
                if (cb.checked) peopleTagFilters.add(cb.value);
            });

            // Update label
            const label = document.getElementById('peopleTagLabel');
            if (peopleTagFilters.size === 0 || peopleTagFilters.size === allAvailableTags.length) {
                label.textContent = 'Tags';
                peopleTagFilters.clear();  // No filter when all selected
            } else {
                label.textContent = `${peopleTagFilters.size} Tag${peopleTagFilters.size !== 1 ? 's' : ''}`;
            }

            // If tag filter changed from/to active, reload from API to get correct people
            const wasActive = prevSize > 0 && prevSize < allAvailableTags.length;
            const isActive = peopleTagFilters.size > 0 && peopleTagFilters.size < allAvailableTags.length;
            if (wasActive !== isActive || isActive) {
                loadPeople();  // Fetch from API with tag filter
            } else {
                renderPeopleList();  // Just re-render local data
            }
        }

        function selectAllTags() {
            document.querySelectorAll('#peopleTagOptions input[type="checkbox"]').forEach(cb => cb.checked = true);
            updatePeopleTagFilter();
        }

        function selectNoTags() {
            document.querySelectorAll('#peopleTagOptions input[type="checkbox"]').forEach(cb => cb.checked = false);
            updatePeopleTagFilter();
        }

        function filterTagOptions() {
            const searchInput = document.getElementById('tagSearchInput');
            const query = (searchInput?.value || '').toLowerCase().trim();
            const sections = document.querySelectorAll('#peopleTagOptions .tag-filter-section');
            const standaloneOptions = document.querySelectorAll('#peopleTagOptions > .people-filter-option');

            // Filter sections (grouped tags)
            sections.forEach(section => {
                const options = section.querySelectorAll('.people-filter-option');
                let anyVisible = false;
                options.forEach(option => {
                    const label = option.textContent.toLowerCase();
                    const matches = !query || label.includes(query);
                    option.style.display = matches ? '' : 'none';
                    if (matches) anyVisible = true;
                });
                // Hide section if no options match
                section.style.display = anyVisible ? '' : 'none';
            });

            // Filter standalone options (ungrouped tags)
            standaloneOptions.forEach(option => {
                const label = option.textContent.toLowerCase();
                option.style.display = (!query || label.includes(query)) ? '' : 'none';
            });
        }

        // ===============================
        // Bulk Tag Functions
        // ===============================

        function openBulkTagModal() {
            const count = selectedForMerge.size;
            if (count === 0) return;

            document.getElementById('bulkTagCount').textContent = count;
            document.getElementById('bulkTagInput').value = '';
            document.getElementById('bulkTagModal').style.display = 'flex';

            // Populate tag suggestions from existing tags
            const suggestions = document.getElementById('tagSuggestions');
            if (allAvailableTags.length > 0) {
                const topTags = allAvailableTags.slice(0, 10);  // Show up to 10 suggestions
                suggestions.innerHTML = topTags.map(tag =>
                    `<span class="tag-suggestion" onclick="selectTagSuggestion('${escapeHtml(tag)}')">${escapeHtml(tag)}</span>`
                ).join('');
            } else {
                suggestions.innerHTML = '';
            }

            // Focus input
            setTimeout(() => document.getElementById('bulkTagInput').focus(), 100);
        }

        function closeBulkTagModal() {
            document.getElementById('bulkTagModal').style.display = 'none';
        }

        function selectTagSuggestion(tag) {
            document.getElementById('bulkTagInput').value = tag;
        }

        async function applyBulkTag() {
            const tag = document.getElementById('bulkTagInput').value.trim();
            if (!tag) return;

            const selectedIds = [...selectedForMerge];
            if (selectedIds.length === 0) return;

            closeBulkTagModal();

            // Apply tag to each selected person
            for (const personId of selectedIds) {
                try {
                    const person = people.find(p => p.id === personId);
                    if (!person) continue;

                    const currentTags = person.tags || [];
                    if (!currentTags.includes(tag)) {
                        const newTags = [...currentTags, tag];
                        await api(`/people/${personId}`, {
                            method: 'PATCH',
                            body: JSON.stringify({ tags: newTags })
                        });
                        // Update local state
                        person.tags = newTags;
                    }
                } catch (error) {
                    console.error(`Failed to add tag to person ${personId}:`, error);
                }
            }

            // Clear selection and refresh
            clearSelection();
            // Clear search cache so tag changes are reflected in filters
            clearSearchCache();
            // Rebuild tag filter options to include new tag
            collectAllTags();
        }

        // Close people filter dropdowns when clicking outside
        document.addEventListener('click', function(e) {
            const categoryDropdown = document.getElementById('peopleCategoryDropdown');
            const dunbarDropdown = document.getElementById('peopleDunbarDropdown');
            const tagDropdown = document.getElementById('peopleTagDropdown');

            if (categoryDropdown && !categoryDropdown.contains(e.target)) {
                document.getElementById('peopleCategoryOptions').classList.remove('show');
            }
            if (dunbarDropdown && !dunbarDropdown.contains(e.target)) {
                document.getElementById('peopleDunbarOptions').classList.remove('show');
            }
            if (tagDropdown && !tagDropdown.contains(e.target)) {
                document.getElementById('peopleTagOptions').classList.remove('show');
            }
        });

        // Handle search
        let searchTimeout;
        function handleSearch() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                searchQuery = document.getElementById('searchInput').value;
                loadPeople();
            }, 300);
        }

        // Clear search field
        function clearSearch() {
            const input = document.getElementById('searchInput');
            input.value = '';
            searchQuery = '';
            loadPeople();
            input.focus();
        }

        // Handle keydown in search field (Esc clears)
        function handleSearchKeydown(event) {
            if (event.key === 'Escape') {
                clearSearch();
                event.preventDefault();
            }
        }

        // Utility functions
        function getInitials(name) {
            if (!name) return '?';
            const parts = name.split(' ').filter(p => p.length > 0);
            if (parts.length === 0) return '?';
            if (parts.length === 1) return parts[0][0].toUpperCase();
            return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
        }

        // Avatar colors by category
        const avatarColors = {
            self: { bg: '#ffffff', text: '#1a1a2e' },           // White with dark text
            family: { bg: '#daa520', text: '#1a1a2e' },         // Goldenrod
            work: { bg: '#4f46e5', text: '#ffffff' },           // Indigo
            personal: { bg: '#00bcd4', text: '#1a1a2e' },       // Light blue (cyan)
        };

        function getAvatarStyle(category) {
            const colors = avatarColors[category] || avatarColors.personal;
            return `background: ${colors.bg}; color: ${colors.text};`;
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Copy text to clipboard and show visual feedback on the button.
         * Uses navigator.clipboard when available, falls back to execCommand for HTTP contexts.
         * @param {string} text - Text to copy
         * @param {string} buttonSelector - CSS selector for the button to animate
         */
        async function copyToClipboardWithFeedback(text, buttonSelector) {
            try {
                // Try modern clipboard API first (requires HTTPS or localhost)
                if (navigator.clipboard && window.isSecureContext) {
                    await navigator.clipboard.writeText(text);
                } else {
                    // Fallback for HTTP contexts (e.g., Tailscale)
                    const textArea = document.createElement('textarea');
                    textArea.value = text;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-9999px';
                    textArea.style.top = '-9999px';
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                }
                const btn = document.querySelector(buttonSelector);
                if (btn) {
                    btn.classList.add('copied');
                    setTimeout(() => btn.classList.remove('copied'), 1000);
                }
            } catch (err) {
                console.error('Failed to copy:', err);
            }
        }

        function formatDate(dateStr) {
            if (!dateStr) return 'Never';
            let date = new Date(dateStr);
            const now = new Date();

            // Cap future dates at today (e.g., future calendar events)
            if (date > now) {
                return 'Today';
            }

            const diff = now - date;

            if (diff < 60000) return 'Just now';
            if (diff < 3600000) return Math.floor(diff / 60000) + 'm ago';
            if (diff < 86400000 && date.toDateString() === now.toDateString()) {
                return Math.floor(diff / 3600000) + 'h ago';
            }

            const yesterday = new Date(now);
            yesterday.setDate(yesterday.getDate() - 1);
            if (date.toDateString() === yesterday.toDateString()) {
                return 'Yesterday';
            }

            return date.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined
            });
        }

        // Initialize on load
        init();
    </script>
</body>
</html>
